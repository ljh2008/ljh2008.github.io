<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[☺分类☺：java | 刘江华的博客]]></title>
  <link href="http://yanyaner.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://yanyaner.com/"/>
  <updated>2014-06-04T13:59:08+08:00</updated>
  <id>http://yanyaner.com/</id>
  <author>
    <name><![CDATA[冰雨]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[分布式文件系统fastdfs解析-配置]]></title>
    <link href="http://yanyaner.com/blog/2014/06/03/fastDFS-config/"/>
    <updated>2014-06-03T15:18:00+08:00</updated>
    <id>http://yanyaner.com/blog/2014/06/03/fastDFS-config</id>
    <content type="html"><![CDATA[<p>&emsp;&emsp;我计划在两台服务器上安装fdfs，ip分别是:192.168.68.133（1号服务器）, 192.168.68.136（2号服务器），fdfs在两台服务器上的安装部署图如下。</p>

<p><span class='caption-wrapper'><img class='caption' src='/uploads/2014/05/fdfs_deploy.jpg' width='' height='' title='fastdfs部署示意图'><span class='caption-text'>fastdfs部署示意图</span></span></p>

<p>&emsp;&emsp;1号服务器上安装tracker实例一个，storage实例2个，分别位于group1,group2两个不同的组中；2号服务器上也安装tracker实例一个，storage实例1个，这个storage和1号服务器中的其中一个storage位于同一个组中。下面给大家贴出具体配置。</p>

<p>&emsp;&emsp;1号服务器中，我们先： vim /usr/local/fastdfs/conf/storage_ids.conf</p>

<p>```</p>

<h1><id>  &lt;group_name>  &lt;ip_or_hostname></h1>

<p>100001   group1  192.168.68.133
100002   group2  192.168.68.133
100003   group1  192.168.68.136
```</p>

<p>&emsp;&emsp;在这个文件中为所有存储服务器指定id, 这样可以免更换ip带来的影响，也就是说当服务器ip发生改变后只需要更改这个文件中的ip地址即可。</p>

<p>&emsp;&emsp;编辑tracker.conf，vim /usr/local/fastdfs/conf/tracker.conf配置文件，以下仅仅列出我改过的或者我认为需要给大家说明的配置项，没有贴出的均保持配置文件中的默认值。</p>

<p>```</p>

<h1>the tracker server port</h1>

<p>port=22122</p>

<h1>the base path to store data and log files</h1>

<p>base_path=/var/fastdfs/tracker</p>

<h1>the method of selecting group to upload files</h1>

<h1>0: round robin</h1>

<h1>1: specify group</h1>

<h1>2: load balance, select the max free space group to upload file</h1>

<p>store_lookup=2</p>

<h1>which group to upload file</h1>

<h1>when store_lookup set to 1, must set store_group to the group name</h1>

<p>store_group=group2</p>

<h1>unix group name to run this program,</h1>

<h1>not set (empty) means run by the group of current user</h1>

<p>run_by_group=</p>

<h1>unix username to run this program,</h1>

<h1>not set (empty) means run by current user</h1>

<p>run_by_user=</p>

<h1>if use storage ID instead of IP address</h1>

<h1>default value is false</h1>

<h1>since V4.00</h1>

<p>use_storage_id = true</p>

<h1>the max time of storage sync a file</h1>

<h1>default value is 300 seconds</h1>

<h1>since V2.00</h1>

<p>storage_sync_file_max_time = 300</p>

<p>```</p>

<p>&emsp;&emsp;现对上面列出的一些配置项进行解释：</p>

<p>&emsp;&emsp;<strong>port</strong>：tracker服务器的端口号，如果一台服务器上要运行多个tracker实例就需要更改此端口号以避免冲突。</p>

<p>&emsp;&emsp;<strong>base_path</strong>：tracker自身配置信息以及日志信息保存的位置，这个目录本不会占用太大的空间，但日志文件会随着使用而慢慢变大。</p>

<p>&emsp;&emsp;<strong>store_lookup</strong>：负载分配机制，2表示选择存储空间最大的组来保存文件。</p>

<p>&emsp;&emsp;<strong>run_by_group，run_by_user</strong>：指定运行tracker的用户组及用户，这是为了保存系统的安全，我们一般会为fdfs新建组及用户。</p>

<p>&emsp;&emsp;<strong>use_storage_id</strong>：使用存储服务器id替代ip地址，我们刚才编辑的storage_ids.conf中指定了每个实例的id。</p>

<p>&emsp;&emsp;<strong>storage_sync_file_max_time</strong>：同一组中的不同storate进行文件同步的时间，默认是5分钟内完成同步，你可以根据实际情况把这个值改小（改变这个值后可以观察到文件同步的效果，这个值不要设置得太小以避免造成系统同步网络压力）。</p>

<p>&emsp;&emsp;接下来我们配置本台服务器上的storage实例，先配置storage1.conf实例，这个实例位于group1中。</p>

<p>&emsp;&emsp;vim /usr/local/fastdfs/conf/storage1.conf，同样限于篇幅，我仅仅贴出重要配置项，其它的使用默认值。<!-- more--></p>

<p>```</p>

<h1>the name of the group this storage server belongs to</h1>

<p>group_name=group1</p>

<h1>the storage server port</h1>

<p>port=23001</p>

<h1>the base path to store data and log files</h1>

<p>base_path=/var/fastdfs/storage1</p>

<h1>store_path#, based 0, if store_path0 not exists, it&rsquo;s value is base_path</h1>

<h1>the paths must be exist</h1>

<p>store_path0=/var/fastdfs/store_group1_path0</p>

<h1>tracker_server can ocur more than once, and tracker_server format is</h1>

<h1>&ldquo;host:port&rdquo;, host can be hostname or ip address</h1>

<p>tracker_server=192.168.68.133:22122
tracker_server=192.168.68.136:22122</p>

<p>run_by_group=
run_by_user=</p>

<p>```
&emsp;&emsp;现在对上面的配置项进行解释：</p>

<p>&emsp;&emsp;<strong>group_name</strong>：本storage实例所属的组名称。</p>

<p>&emsp;&emsp;<strong>port</strong>：storage的端口号，同一组的storage实例必须采用同样的端口号，这就是说同一组中的storage实例必须部署在不同学的机器上，因为同一台机器上的端口号不能相同。</p>

<p>&emsp;&emsp;<strong>base_path</strong>：本storage的配置数据及运行日志文件存放的位置，和tracker中的base_path含义相同。</p>

<p>&emsp;&emsp;<strong>store_path0</strong>：真正的用户上传文件保存的位置目录，fastDfs会在该目录下新建许多子目录，在第一次启动实例时会进行这个操作。store_path可以有多个，一般可以分配成单独的磁盘挂载点。</p>

<p>&emsp;&emsp;<strong>tracker_server</strong>：指定本storaged的信息会注册到哪些tracker中去，故这里的tracker_server可以配置多个。</p>

<p>&emsp;&emsp;<strong>run_by_group、run_by_user</strong>与tracker中的含义相同，不再细说。</p>

<p>&emsp;&emsp;接下来，我们再来看本服务器上的另一个storage实例，这个实例是运行在group2中的，端口号与上面配置的那个storage是不同的，请看配置关键项：</p>

<p>```</p>

<h1>the name of the group this storage server belongs to</h1>

<p>group_name=group2</p>

<h1>the storage server port</h1>

<p>port=23002</p>

<p>base_path=/var/fastdfs/storage2</p>

<h1>store_path#, based 0, if store_path0 not exists, it&rsquo;s value is base_path</h1>

<h1>the paths must be exist</h1>

<p>store_path0=/var/fastdfs/store_group2_path0</p>

<h1>tracker_server can ocur more than once, and tracker_server format is</h1>

<h1>&ldquo;host:port&rdquo;, host can be hostname or ip address</h1>

<p>tracker_server=192.168.68.133:22122</p>

<p>```</p>

<p>&emsp;&emsp;上面配置文件中的内容和storage1.conf中的类似，只不过group_name、port不相同，两个文件的保存路径也是不同的，经过这些配置后，我们就可以启动服务实例了。</p>

<p>&emsp;&emsp;先来启动tracker实例，先编辑启动脚本文，vim /etc/init.d/fdfs_trackerd。</p>

<p>``` sh fdfs_trackerd</p>

<h1>!/bin/bash</h1>

<p>#</p>

<h1>fdfs_trackerd Starts fdfs_trackerd</h1>

<p>#
#</p>

<h1>chkconfig: 2345 99 01</h1>

<h1>description: FastDFS tracker server</h1>

<h3>BEGIN INIT INFO</h3>

<h1>Provides: $fdfs_trackerd</h1>

<h3>END INIT INFO</h3>

<h1>Source function library.</h1>

<p>. /etc/init.d/functions
FastDfs=&lsquo;/usr/local/fastdfs&rsquo;
CONF=&ldquo;$FastDfs/conf/tracker.conf&rdquo;
if [ ! -f $CONF ]; then
  echo &ldquo;file $CONF does not exist!&rdquo;
  exit 2
fi
PRG=&ldquo;$FastDfs/bin/fdfs_trackerd&rdquo;
if [ ! -f $PRG ]; then
  echo &ldquo;file $PRG does not exist!&rdquo;
  exit 2
fi
Stop=&ldquo;$FastDfs/bin/stop.sh&rdquo;
if [ ! -f $Stop ]; then
  echo &ldquo;file $Stop does not exist!&rdquo;
  exit 2
fi
Restart=&ldquo;$FastDfs/bin/restart.sh&rdquo;
if [ ! -f $Restart ]; then
  echo &ldquo;file $Restart does not exist!&rdquo;
  exit 2
fi
RETVAL=0
start() {</p>

<pre><code>echo -n $"Starting FastDFS tracker server: "
$PRG $CONF &amp;
RETVAL=$?
echo
return $RETVAL
</code></pre>

<p>}
stop() {</p>

<pre><code>echo -n $"Stop FastDFS tracker server: "
$Stop $PRG $CONF
RETVAL=$?
return $RETVAL
</code></pre>

<p>}
rhstatus() {</p>

<pre><code>status fdfs_trackerd
</code></pre>

<p>}
restart() {</p>

<pre><code>    $Restart $PRG $CONF &amp;
</code></pre>

<p>}
case &ldquo;$1&rdquo; in
  start)</p>

<pre><code>start
;;
</code></pre>

<p>  stop)</p>

<pre><code>stop
;;
</code></pre>

<p>  status)</p>

<pre><code>rhstatus
;;
</code></pre>

<p>  restart|reload)</p>

<pre><code>restart
;;
</code></pre>

<p>  condrestart)</p>

<pre><code>restart
;;
</code></pre>

<p>  *)</p>

<pre><code>echo $"Usage: $0 {start|stop|status|restart|condrestart}"
exit 1
</code></pre>

<p>esac
exit $?
```</p>

<p>&emsp;&emsp;这篇启动脚本中，主要修改的地方是FastDfs及CONF变量参数，这两个用来指定tracker配置文件所在的位置。</p>

<p>&emsp;&emsp;完成编辑后，使用命令：sudo /etc/init.d/fdfs_trackerd start，即可完成服务器的启动，如果启动成功你可通过netstat -lnpt查看到tracker的端口号。</p>

<p>&emsp;&emsp;接下来，将fdfs_storaged拷贝为fdfs_storaged1，用于启动storage1实例，要修改的地方也是FastDfs及CONF参数，这两个参数用来指定storage1.conf文件的在的目录及配置文件的名称。</p>

<p>``` sh fdfs_storaged1</p>

<h1>!/bin/bash</h1>

<p>#</p>

<h1>fdfs_storaged Starts fdfs_storaged</h1>

<p>#
#</p>

<h1>chkconfig: 2345 99 01</h1>

<h1>description: FastDFS storage server</h1>

<h3>BEGIN INIT INFO</h3>

<h1>Provides: $fdfs_storaged</h1>

<h3>END INIT INFO</h3>

<h1>Source function library.</h1>

<p>. /etc/init.d/functions
FastDfs=&lsquo;/usr/local/fastdfs&rsquo;
CONF=&ldquo;$FastDfs/conf/storage1.conf&rdquo;
if [ ! -f $CONF ]; then
  echo &ldquo;file $CONF does not exist!&rdquo;
  exit 2
fi
PRG=&ldquo;$FastDfs/bin/fdfs_storaged&rdquo;
if [ ! -f $PRG ]; then
  echo &ldquo;file $PRG does not exist!&rdquo;
  exit 2
fi
Stop=&ldquo;$FastDfs/bin/stop.sh&rdquo;
if [ ! -f $Stop ]; then
  echo &ldquo;file $Stop does not exist!&rdquo;
  exit 2
fi
Restart=&ldquo;$FastDfs/bin/restart.sh&rdquo;
if [ ! -f $Restart ]; then
  echo &ldquo;file $Restart does not exist!&rdquo;
  exit 2
fi
RETVAL=0
start() {</p>

<pre><code>echo -n $"Starting FastDFS storage server: "
$PRG $CONF &amp;
RETVAL=$?
echo
return $RETVAL
</code></pre>

<p>}
stop() {</p>

<pre><code>echo -n $"Stop FastDFS storage server: "
$Stop $PRG $CONF
RETVAL=$?
return $RETVAL
</code></pre>

<p>}
rhstatus() {</p>

<pre><code>status fdfs_storaged
</code></pre>

<p>}
restart() {</p>

<pre><code>    $Restart $PRG $CONF &amp;
</code></pre>

<p>}
case &ldquo;$1&rdquo; in
  start)</p>

<pre><code>start
;;
</code></pre>

<p>  stop)</p>

<pre><code>stop
;;
</code></pre>

<p>  status)</p>

<pre><code>rhstatus
;;
</code></pre>

<p>  restart|reload)</p>

<pre><code>restart
;;
</code></pre>

<p>  condrestart)</p>

<pre><code>restart
;;
</code></pre>

<p>  *)</p>

<pre><code>echo $"Usage: $0 {start|stop|status|restart|condrestart}"
exit 1
</code></pre>

<p>esac</p>

<p>exit $?
```</p>

<p>&emsp;&emsp;好，该来启动storaged1实例了，命令： sudo /etc/init.d/fdfs_storaged1 start，如果是第一次启动会观察到创建存储目录的过程。</p>

<p>&emsp;&emsp;启动storaged2实例的过程和storaged1相同，先编辑fdfs_storaged2文件，再fdfs_storaged2 start即完成。</p>

<p>&emsp;&emsp;当1号服务器上的fdfs全部服务都成功启动后，我们可以看到如下目录结构会建立起来。</p>

<p><span class='caption-wrapper'><img class='caption' src='/uploads/2014/05/fdfs_dir_struct.jpg' width='' height='' title='fastdfs目录结构'><span class='caption-text'>fastdfs目录结构</span></span></p>

<p>&emsp;&emsp;至此，1号服务器上的所有配置及服务启动工作已经完成。2号服务器的配置及服务实例启动与1号服务器基本相同，惟一需要大家要注意的是group的名称，port端口号等，要和1号服务器相“呼应”，同时，我们在2号服务器上也配置了一个tracker实例以保证高可用性。</p>

<p>&emsp;&emsp;好了，fastDFS的配置先告一段落，下一篇我们来聊聊客户端对fastDFS的调用，除了java客户端外，还包括tengine-2.0.1服务器上访问插件的配置。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分布式文件系统fastdfs解析之一(安装)]]></title>
    <link href="http://yanyaner.com/blog/2014/05/30/fastDFS-setup/"/>
    <updated>2014-05-30T15:18:00+08:00</updated>
    <id>http://yanyaner.com/blog/2014/05/30/fastDFS-setup</id>
    <content type="html"><![CDATA[<p>&emsp;&emsp;fastdfs是一个轻量级的分布式文件系统服务，它在互联网项目中有比较广泛的用途，类似的还有tfs等，但fastdfs和hadoop这些又不相同，hadoop是分布式存储计算框架，比较重量级，而fastdfs针对的是海量的小文件。</p>

<p>&emsp;&emsp;项目中经常会有这样一些应用场景，比如：文件服务器需要存储海量的用户文件并且对外提供用户的访问操作；文件服务器需要高可用性和高性能；文件服务器需要实现负载均衡；文件服务器可实时扩容等等，这些需求在Fastdfs中有实现，因此它可以满足大部的项目需求。</p>

<p>&emsp;&emsp;先给大家简单介绍一下fastdfs的原理，下面这张图有助于大家了解分布式文件系统的原理（hadoop之类的分布式体系与之有相似之处）。</p>

<p><span class='caption-wrapper'><img class='caption' src='/uploads/2014/04/seq_fastdfs.jpg' width='' height='' title='fastdfs调用时序图'><span class='caption-text'>fastdfs调用时序图</span></span></p>

<p>&emsp;&emsp;上面这张图中客户端针对文件服务系统的调用，首先得通过tracker服务器，这个服务器充当了调度者的作用。客户端可以是任何的程序客户端，比如java客户端、php客户端、nginx插件客户端等。</p>

<p>&emsp;&emsp;在客户端调用之前先得启动tracker server，然后再分别启动各个storage server，每个storage server启动后会注册自己的信息到指定的tracker server中（其实，tracker server服务器也可以有多个，从高可用性方面考虑我们一般会启动多个tracker server实例）。</p>

<p>&emsp;&emsp;storage server负责具体文件的存储。storage server按照分组的方式来保存文件的，比如group1,group2等。一个组中可以有多台服务器，同一个组里的所有服务器中保存的文件内容都是相同的，因为同一个组中的服务器之间会相互自动同步文件，这样就实现了冗余备份及负载均衡的功能（负载均衡由tracker server调试的哦）。</p>

<p>&emsp;&emsp;不同组中的storage server之间是独立的，当系统存储容量不够时，通过添加新服务器并分配到新的组中，tracker server发现新的服务器后会自动调度以实现后续客户文件的写入位置。</p>

<p>&emsp;&emsp;上图中，客户通过询问tracker server得到可用的storage server（tracker server会通过负载均衡及各个storage的存储可用容量大小算法决定，当然这个也可以在配置文件中指定），客户端得到storage server后进行相应的文件操作，同组服务器间会根据操作的结果进行文件同步（时序9，10是同步操作）。</p>

<p>&emsp;&emsp;好了，原理先说到这。下面，我将给大家简单介绍FastDfs的安装及使用，以及一些注意事项。</p>

<p>&emsp;&emsp;我的服务器是ubuntu server，我计划安装在两台服务器上，ip分别是:192.168.68.133, 192.168.68.136，暂时简称为1号服务器，2号服务器。</p>

<p>&emsp;&emsp;一号服务器上，将安装一个tracker server实例，一个位于group1中的storage server实例，一个位于group2中storage server实例。</p>

<p>&emsp;&emsp;二号服务器上，也将安装一个tracker server实例，一个位于group1中的storage server实例。需要大家注意的是，fastdfs中一台服务器上可以安装多个组，但一个组中的多个storade server必须安装在不同的服务器上，并且同组中的storage server的服务端口必须一致，否则无法实现文件同步。</p>

<p>&emsp;&emsp;我先在一号服务器192.168.68.133上安装fastdfs。首先要准备安装环境，不同的linux发行版本可能会有所不同，我用的服务器版本是ubuntu 12.04 server，以下的操作均以这个版本的ubuntu服务器为例。<!--more--></p>

<p><code>
vim /etc/profile
export LANGUAGE="en_US.UTF-8"
export LANG=en_US:zh_CN.UTF-8
export LC_ALL=C
</code>
&emsp;&emsp;接下来让语言环境配置参数立即生效：</p>

<p><code>
source /etc/profile
</code>
&emsp;&emsp;再接着，安装fastdfs编译依赖包，大家要注意的是少一个依赖都不行，我先前安装时缺少了libevent-dev，致使安装不成功但安装过程又不报错，花费了大量的时间。</p>

<p>```
aptitude install libevent
apt-get install libevent-dev</p>

<p>sudo apt-get update
sudo aptitude install build-essential m4</p>

<p>sudo ln -s /lib/lsb/init-functions  /etc/init.d/functions</p>

<p>```</p>

<p>&emsp;&emsp;好了，环境准备好了后就到<a href="https://code.google.com/p/fastdfs">fastdfs官网</a>上去下载安装包吧，地址<a href="https://code.google.com/p/fastdfs/downloads/list">https://code.google.com/p/fastdfs/downloads/list</a>，我下载的是
FastDFS_v4.06.tar.gz ，如果你想要安装最新版本，请用svn去下载最新的5.x版本。</p>

<p><code>
tar -zxvf FastDFS_v4.06.tar.gz
cd FastDFS
</code>
&emsp;&emsp;这样就进入了源代码目录，我们先要对安装的目录做一个规划(4.06版本默认的安装目录似乎不太合理)，我将fastdfs的所有文件都安装到/usr/local/fastdfs中，配置文件存放在/usr/local/fastdfs/conf下，这就需要我们修改源代码目录下的make.sh，下面是一些要修改的地方：</p>

<p><code>
vim make.sh
</code></p>

<p>&emsp;&emsp;需要对：</p>

<ol>
<li><p> TARGET_PREFIX，TARGET_CONF_PATH进行修改;</p></li>
<li><p> 需要对libpthread.so、libpthread.a的路径进行修改，这和ubuntu有关，其它linux发行版本并不需要改这个(你可以用find / -name &lsquo;libpthread.so&rsquo;  ，以及ind / -name &lsquo;libpthread.a&rsquo;  找到这两文件在系统中的位置)；</p></li>
<li><p> 另外要对mkdir,cp操作的几个路径进行修改为我们配置文件所在的路径。</p></li>
</ol>


<p>&emsp;&emsp;我贴出make.sh修改过的地方，请大家自行对照：</p>

<p>```
TARGET_PREFIX=/usr/local/fastdfs
TARGET_CONF_PATH=/usr/local/fastdfs/conf</p>

<p>if [ -f /usr/lib/i386-linux-gnu/libpthread.so ] || [ -f /usr/local/lib/libpthread.so ] || [ -f /lib64/libpthread.so ] || [ -f /usr/lib64/libpthread.so ] || [ -f /usr/lib/i386-linux-gnu/libpthread.a ] || [ -f /usr/local/lib/libpthread.a ] || [ -f /lib64/libpthread.a ] || [ -f /usr/lib64/libpthread.a ]; then
&hellip;&hellip;&hellip;&hellip;
&hellip;&hellip;&hellip;&hellip;</p>

<p>if [ &ldquo;$uname&rdquo; = &ldquo;Linux&rdquo; ]; then</p>

<pre><code>if [ "$WITH_LINUX_SERVICE" = "1" ]; then
  if [ ! -d /usr/local/fastdfs/conf ]; then
    mkdir -p /usr/local/fastdfs/conf
    cp -f conf/tracker.conf /usr/local/fastdfs/conf/
    cp -f conf/storage.conf /usr/local/fastdfs/conf/
    cp -f conf/client.conf /usr/local/fastdfs/conf/
    cp -f conf/http.conf /usr/local/fastdfs/conf/
    cp -f conf/mime.types /usr/local/fastdfs/conf/
  fi
</code></pre>

<p>&hellip;&hellip;&hellip;&hellip;</p>

<p>```</p>

<p>&emsp;&emsp;下面开始安装吧，如下命令：</p>

<p><code>
sudo make;
sudo make install;
sudo make clean;
</code>
&emsp;&emsp;不同的linux发行版本可能存在依赖包没有安装而报错，具体情况需要根据出错信息具体解决，我试过redhead,freebsd,openSuse,centos几个系统，都是要进行一些环境的配置才可以安装成功。</p>

<p>&emsp;&emsp;下一篇文章我将按照文章开头的服务器规划进行具体的配置，请大家关注。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分享几段数据导入导出参考代码]]></title>
    <link href="http://yanyaner.com/blog/2014/05/29/code-share-poi/"/>
    <updated>2014-05-29T15:18:00+08:00</updated>
    <id>http://yanyaner.com/blog/2014/05/29/code-share-poi</id>
    <content type="html"><![CDATA[<p>&emsp;&emsp;给童鞋写的几段参考demo代码，有需要的可以参考一下哦：</p>

<ol>
<li><p>poi excel数据导入（导入数据是考虑该数据已经存在的情况，如果存在则进行更新操作）</p></li>
<li><p>zip照片包导入（照片的导入会更新已经存在的照片并且会按业务规则建立照片目录分类存放）</p></li>
<li><p>按模板导格式导出数据至excel中（excel导出需要提供一个excel文件模板，将数据直接写到模板中，这样才能更好地符合用户的实际业务场景）</p></li>
</ol>


<p>&emsp;&emsp;下面这demo写得非常简单，并没有考虑导入出错时给予调用者出错的细节信息，这些代码大家都可以继续完善。另外你也可以将表和excel的字段对应关系保存在数据库中，让用户通过界面自由定义指定映射关系（当然这需要更深层次的封装，这个代码我以后贴出来）。</p>

<p>&emsp;&emsp;业务接口核心方法共3个，大家可以参考这种设计以简化调用者的复杂性：</p>

<p>``` java ISystemService.java
/<em>*
 * demo系统业务接口
 * @author ljh
 *
 </em>/
public interface ISystemService {</p>

<pre><code>public void importStudents(InputStream excelIs, int classesId);

public void importStudentPhotos(byte[] zipFileByte, String uploadDir, int classesId);

public void exportStudents(String title , InputStream templateFile, OutputStream outputFile);
</code></pre>

<p>}</p>

<p>```
&emsp;&emsp;业务实现类代码如下：<!-- more --></p>

<p>``` java SystemServiceImpl.java
/<em>*
 * demo系统业务类实现
 *
 * @author ljh
 *
 </em>/
@Service(&ldquo;systemService&rdquo;)
@Transactional(readOnly = true)
public class SystemServiceImpl implements ISystemService {</p>

<pre><code>// 通用dao
@Resource
private IBaseDao dao;
// 用来输出日志
private static final Logger LOG = LoggerFactory
        .getLogger(SystemServiceImpl.class);

public void exportStudents(String title ,InputStream templateFile, OutputStream outputFile) {

    try {
        HSSFWorkbook wb = new HSSFWorkbook(templateFile);
        HSSFSheet sheet = wb.getSheetAt(0);

        //设置标题
        sheet.getRow(0).getCell(0).setCellValue(title);

        //取得模板行数据
        HSSFRow templateRow = sheet.getRow(2);

        //查询要导出的数据 
        List&lt;Student&gt; students = dao.queryEntitys("from Student s", new Object[]{});

        int startRow = 2;

        for (Student s : students) {

            HSSFRow row = sheet.createRow(startRow);

            HSSFCell cell_id = row.createCell(0);
            cell_id.setCellStyle(templateRow.getCell(0).getCellStyle());
            cell_id.setCellValue(s.getId());

            HSSFCell cell_name = row.createCell(1);
            cell_name.setCellStyle(templateRow.getCell(1).getCellStyle());
            cell_name.setCellValue(s.getName());

            HSSFCell cell_sex = row.createCell(2);
            cell_sex.setCellStyle(templateRow.getCell(2).getCellStyle());
            cell_sex.setCellValue(s.getSex());

            HSSFCell cell_bm_code = row.createCell(3);
            cell_bm_code.setCellStyle(templateRow.getCell(3).getCellStyle());
            cell_bm_code.setCellValue(s.getClasses().getCode() + s.getId());


            HSSFCell cell_classes_code = row.createCell(4);
            cell_classes_code.setCellStyle(templateRow.getCell(4).getCellStyle());
            cell_classes_code.setCellValue(s.getClasses().getCode());

            startRow = startRow + 1;
        }

        wb.write(outputFile);


    } catch (Exception e) {
        LOG.error("export excel error!", e);
        throw new RuntimeException("导出excel文件出错！");
    }

}

@Transactional(readOnly = false)
public void importStudentPhotos(byte[] zipFileByte, String uploadDir, int classId) {

            //班级编码
            String classesCode = this.getClassesById(classId).getCode();

            //解压缩zip文件
            try {

                String tempFileName = System.getProperty("java.io.tmpdir") +  UUID.randomUUID().toString();
                File tempFile = new File(tempFileName);
                FileUtils.writeByteArrayToFile(tempFile, zipFileByte);

                //本班的所有学生
                List&lt;Student&gt; students = new ArrayList&lt;Student&gt;(getClassesById(classId).getStudents());

                ZipFile zipfile = new ZipFile(tempFile, "gb2312");
                Enumeration&lt;ZipArchiveEntry&gt; entries = zipfile.getEntries();
                while (entries.hasMoreElements()) { 

                    ZipArchiveEntry entry = entries.nextElement();

                    if (! entry.isDirectory()) {
                        String name = entry.getName();
                        String studentName = name.substring(name.lastIndexOf("/") + 1, name.lastIndexOf("."));

                        for (Student stu : students) {
                            if (studentName.equals(stu.getName())) {
                                String newPhotoName = UUID.randomUUID().toString() + name.substring(name.lastIndexOf("."));
                                if (! "upload/default.jpg".equals(stu.getPhoto())) {
                                    newPhotoName = stu.getPhoto().substring(stu.getPhoto().lastIndexOf("/") + 1);
                                }

                                FileUtils.copyInputStreamToFile(zipfile.getInputStream(entry), 
                                        new File(uploadDir + File.separator + classesCode + File.separator + newPhotoName));
                                stu.setPhoto("upload/" + classesCode + "/" + newPhotoName);
                                dao.updateEntity(stu);
                                break;
                            }
                        }

                    }
                }

            } catch (Exception e) {
                LOG.error("import zip photo error.", e);
                throw new IllegalArgumentException("导入学生照片信息失败，详细错误：" + e.getMessage());
            }

}

@Override
@Transactional(readOnly = false)
public void importStudents(InputStream excelIs, int classesId) {

    //查询出要导入的学生信息所在的班级
    Classes classes = this.getClassesById(classesId);

    try {

        HSSFWorkbook excel = new HSSFWorkbook(excelIs);
        HSSFSheet sheet = excel.getSheetAt(0);

        int rows = sheet.getPhysicalNumberOfRows();

        //有效行起始位置，因为原excel文件中，有两行标题
        int startRow = 2;

        for (int i = startRow; i &lt; rows; i++) {

            HSSFRow row = sheet.getRow(i);
            HSSFCell cell = row.getCell(1);

            Student student = new Student();

            //excel文件列顺序：序号，姓名，性别，年龄
            student.setName(row.getCell(1).getStringCellValue());
            student.setSex(row.getCell(2).getStringCellValue());
            student.setAge((int) row.getCell(3).getNumericCellValue());
            student.setClasses(classes);
            student.setPassword("123");
            student.setState(Student.STATE_STUDING);
            student.setEmployment(false);
            student.setCode(classesId + ""
                    + (int) row.getCell(0).getNumericCellValue());

            this.addStudent(student);

        }

    } catch (Exception e) {
        // TODO Auto-generated catch block
        //e.printStackTrace();
        LOG.info("导入excel文件失败！", e);
    }

}
</code></pre>

<p>}</p>

<p>```</p>

<p>&emsp;&emsp;前端控制器代码如下：</p>

<p>``` java StudentAction.java
@Controller
public class StudentAction {</p>

<pre><code>@Resource
private ISystemService systemService;

@Resource
private WebApplicationContext appContext;


private ObjectMapper om = new ObjectMapper();

/**
 * 导出学生信息到excel
 * @param sid
 * @param resp
 * @throws Exception
 */
@RequestMapping(value = "/student/export_excel", method = RequestMethod.GET)
public void exportStudents(HttpServletResponse resp) throws Exception {

    String templateFile = appContext.getServletContext().getRealPath("template/student_template.xls");

    String title = "xxxxxx缴费情况表（2014）";
    String fileName = title + ".xls";

    //设置客户端默认文件名
    resp.addHeader("Content-Disposition", "attachment;filename=" + new String(fileName.getBytes(),"ISO8859-1"));

    systemService.exportStudents(title, new FileInputStream(templateFile), resp.getOutputStream());

}


/**
 * 导入学生照片信息
 * @param sid
 * @param resp
 * @throws Exception
 */
@RequestMapping(value = "/student/importPhoto", method = RequestMethod.POST)
public void inportStudentPhoto(@RequestParam("file")CommonsMultipartFile file,
        @RequestParam("classId")int classId,
        HttpServletResponse resp) throws Exception {


    boolean successFlag = false;

    String dir = appContext.getServletContext().getRealPath("upload");

    try {
        systemService.importStudentPhotos(file.getBytes(), dir , classId);
        successFlag = true;
    } catch (Exception ex) {

    }

    resp.getWriter().println("&lt;script&gt;parent.callBack("+successFlag+");&lt;/script&gt;");


}

//导入excle的action代码非常简单，我就不再写了
</code></pre>

<p>```</p>

<p>&emsp;&emsp;以前还写过一篇简单的excel导出代码，大家可以看看<a href="/blog/2012/10/30/poi-excel/">《Excel文件导出代码》</a>一文。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[java安全那些事之六（客户端安全）]]></title>
    <link href="http://yanyaner.com/blog/2014/05/23/security6/"/>
    <updated>2014-05-23T15:18:00+08:00</updated>
    <id>http://yanyaner.com/blog/2014/05/23/security6</id>
    <content type="html"><![CDATA[<p>&emsp;&emsp;这篇文章我想说一下客户端保存密码的安全性问题。目前在客户端保存用户登录密码的场景非常的普遍，尤其是在手机客户端应用中更为常见。下图是一个浏览器端中设计的保存密码界面。</p>

<p><span class='caption-wrapper'><img class='caption' src='/uploads/2014/05/auto_login.jpg' width='' height='' title='保存密码及自动登录界面'><span class='caption-text'>保存密码及自动登录界面</span></span></p>

<p>&emsp;&emsp;图中，用户可以选择保存自己的用户名和密码，如果用户选择了这一项，密码当然是保存在客户端的哦（浏览器中就是cookie）。在保存了上次登录密码的情况下客户端再次进行手动或自动登录时，客户端将取出自动保存的密码提交到服务器。</p>

<p>&emsp;&emsp;我们可以想像到，如果将密码以明文的方式保存到客户端显然是不可取的。对密码进行加密处理后再保存客户端是一个可行的做法，但对密码加密的算法就值得我们去选择，base64肯定是不行的了，DES、RSA都是可以选择的加密方法，因为这些算法是可还原的算法，也就是说服务器收到加密密码后须还原成明文，再执行后续的登录业务。</p>

<p>&emsp;&emsp;交互示意图如下：</p>

<p><span class='caption-wrapper'><img class='caption' src='/uploads/2014/05/seq_auto_login.jpg' width='' height='' title='保存密码登录处理时序'><span class='caption-text'>保存密码登录处理时序</span></span></p>

<p>&emsp;&emsp;简单地给大家解释一下上图中的流程：</p>

<p>&emsp;&emsp;客户端在第一次登录时，如果选择了记录用户名和密码，在第一次登录成功后系统将返回经过加密处理的密码，客户端在得加密密码后进行本地保存（时序2.1为客户端保存服务器端返回的经过加密处理的密码）。</p>

<p>&emsp;&emsp;客户端在第二次登录时提交的是曾经保存的加密密码，服务器得到密码后检测出来是经过加密处理的密码（时序3.1的处理）。</p>

<p>&emsp;&emsp;服务器端进行安全检测（比如本次登录ip和上次不同等方法），如果检测没有通过就进行异常处理，比如返回图片验证码让用户输入或要求用户重新输入密码等（时序3.2即是这个处理）。</p>

<p>&emsp;&emsp;安全检测通过后，系统将解密还原加密的密码（时序3.3的处理），这个过程可能会用到密钥，如果采用的是RSA加密算法，这时可从数据库中取出模和指数生成私钥，以便进行解密处理。</p>

<p>&emsp;&emsp;解密成功后，即可调用正常登录业务逻辑（时序3.4）。</p>

<p>&emsp;&emsp;下图是在浏览器cookies中保存了加密密码的界面截图：</p>

<p><span class='caption-wrapper'><img class='caption' src='/uploads/2014/05/auto_login_cookies.jpg' width='' height='' title='cookies中的内容'><span class='caption-text'>cookies中的内容</span></span></p>

<p>&emsp;&emsp;不多说了，下面给出演示代码，我用的是RSA密码加密算法。首先贴出登录的html代码:<!--more--></p>

<p>``` html</p>

<div class="container">
         <div class="row" style="height: 50px;"></div>
          <div class="row">
              <div class="col-md-6 col-md-offset-2">
                  <form class="form-horizontal" role="form" id="loginForm">
                      <div class="form-group">
                          <label  class="col-sm-4 control-label">登录编码:</label>
                          <div class="col-sm-8">
                              <input value="lovo" type="text" name="name" class="form-control"  placeholder="请输入用户名">
                          </div>
                      </div>
                      <div class="form-group">
                          <label  class="col-sm-4 control-label">登录密码:</label>
                          <div class="col-sm-8">
                              <input value="111" type="password" name="password" id="i_pwd" class="form-control"  placeholder="请输入密码">
                          </div>
                      </div>
                       <div class="form-group">
                          <label  class="col-sm-4 control-label"></label>
                          <div class="col-sm-8">
                              <input value="1" type="checkbox" name="savePwd" id="chk_sp" >保存用户名和密码
                              <input value="1" type="checkbox" name="autoLogin"  id="chk_al">自动登录
                          </div>
                      </div>
                      <div class="form-group">
                          <div class="col-sm-offset-5 ">
                              <button type="button" class="btn btn-lg btn-primary" id="btn_login">登录</button>
                              <button type="reset" class="btn btn-lg col-sm-offset-2">重置</button>
                          </div>
                      </div>
                  </form>

              </div>
          </div>
     </div>


<p>```</p>

<p>&emsp;&emsp;接下来是页面的行为，即js代码：</p>

<p>``` js
<link rel="stylesheet" href="lib/bootstrap/css/bootstrap.min.css">
<link rel="stylesheet" href="lib/bootstrap/css/bootstrap-theme.min.css">
<link rel="stylesheet"  href="css/project.css"></p>

<script type="text/javascript" src="lib/jquery/jquery-1.7.2.min.js"></script>


<script type="text/javascript" src="lib/cookie/jquery.cookie.js"></script>


<script type="text/javascript">

$(function(){
    
    if ($.cookie("pwd")) {
        $("#i_pwd").val($.cookie("pwd"));
        $("#chk_sp").attr("checked", "checked");
    }

    $("#btn_login").click(function(){   
        
        //登录系统调用
        $.ajax({
            url:"login",
            type:"get",
            data:$("#loginForm").serialize(),
            //data:{"name":encodeURI($("input[name='name']").val()),"password":$("input[name='password']").val()},
            dataType:"json",
            success:function(result) {
                if (result.code == 0) {
                    alert(result.msg);
                } else {
                    if (!$.cookie("auto_login")) {
                        alert("恭喜" + result.data.name + "登录成功！");
                    }
                    //进行cookie的设置
                    if ($("#chk_sp").is(":checked")) {
                        $.cookie("pwd",result.data.encyPwd,{expires:result.data.expires});
                    } else {
                        $.cookie("pwd","",{expires:-1});
                    }
                    
                    if ($("#chk_al").is(":checked")) {
                        $.cookie("auto_login","1",{expires:result.data.expires});
                    } else {
                        $.cookie("auto_login","",{expires:-1});
                    }
                    
                    window.location.href = "main/pet_list.html";
                }
            }
            
        });

    })
    
    if ($.cookie("auto_login")) {
        $("#chk_al").attr("checked", "checked");
        $("#btn_login").click();
    }
    
});

</script>


<p>```</p>

<p>&emsp;&emsp;服务器端登录部分的代码：</p>

<p>``` java
@Controller
public class LoginAction {</p>

<pre><code>@Resource
private IMyService myService;

//保存用户名和密码天数
public static int EXPIRES_DAYS = 7;
//加密后的密码后缀
public static String ENCY_PWD_END = "*ENCY*";


/**
 * 登录系统
 */
@RequestMapping(value="/login", method=RequestMethod.GET)
public void login(
        @RequestParam("name") String nickName, 
        @RequestParam("password") String password,
        @RequestParam(value="savePwd",defaultValue="0") int savePassword,
        HttpSession session,
        HttpServletRequest request,
        HttpServletResponse response
        ) throws Exception {

    //nickName = URLDecoder.decode(nickName,"utf-8");
    nickName = new String(nickName.getBytes("iso8859-1"),"utf-8");


    ObjectMapper om = new ObjectMapper();

    ResponseResult result = new ResponseResult();

    try {
        if (password.endsWith(ENCY_PWD_END)) {
            //加密的密码，取掉最后的标识 
            Pet p = myService.getPetByNickName(nickName);
            if (p == null) {
                result.setCode(ResponseResult.FAIL);
                result.setMsg("登录用户不存！");
                om.writeValue(response.getOutputStream(), result);
                return ;
            }

            //check safe
            if (p.getLastLoginIp() != null 
                    &amp;&amp; ! p.getLastLoginIp().equals(request.getRemoteAddr())) {
                //安全检测规则，及安全检测失败的处理，由用户给出实现
            }
            //根据数据库保存的moduls和exponent生成私钥
             RSAPrivateKey rpk = RSAUtil.generatePrivateKey(p.getPrivateModulus(), p.getPrivateExponent());

            //将密码解密为原文处理
            Cipher cipherDecoder = Cipher.getInstance("RSA");
            cipherDecoder.init(Cipher.DECRYPT_MODE, rpk);
            byte[] orgDec = cipherDecoder.doFinal(Hex.decodeHex(password.substring(0,password.length() - ENCY_PWD_END.length()).toCharArray()));

            password = new String(orgDec) ;
        }

        Pet pet = myService.login(nickName, password);

        session.setAttribute(IConst.LOGIN_KEY, pet);

        Map data = new HashMap();
        data.put("name", pet.getNickName());


        //响应中加入cookie信息
        Cookie cookie = new Cookie("pwd", "");

        if (savePassword == 1) {
            //用户需要保存密码

            //生成rsa keyPair
            Map keyPair = RSAUtil.generateKeyPair();
            RSAPublicKey publicKey = (RSAPublicKey)keyPair.get(RSAUtil.PUBLIC_KEY);
            RSAPrivateKey privateKey = (RSAPrivateKey)keyPair.get(RSAUtil.PRIVATE_KEY);

            //下面私钥的模和指数保存至数据库
            pet.setPrivateModulus(privateKey.getModulus().toString());
            pet.setPrivateExponent(privateKey.getPrivateExponent().toString());
            pet.setLastLoginIp(request.getRemoteAddr());

            myService.updatePet(pet);

            Cipher cipherEncoder = Cipher.getInstance("RSA");
            cipherEncoder.init(Cipher.ENCRYPT_MODE, publicKey);
            //加密字串结果
            byte[] strEnc = cipherEncoder.doFinal(password.getBytes());

            String encyPwd = Hex.encodeHexString(strEnc) + ENCY_PWD_END;

            //响应中加入cookie信息
            cookie.setValue(encyPwd);
            cookie.setMaxAge(EXPIRES_DAYS*24*60*60);
            //cookie.seth

            data.put("encyPwd", encyPwd);
            data.put("expires", EXPIRES_DAYS);
        } else {
            //删除cookie
            cookie.setMaxAge(0);    
        }

        result.setData(data);

        response.addCookie(cookie);
        om.writeValue(response.getOutputStream(), result);

    } catch (SecurityException se ) {
        se.printStackTrace();

        result.setCode(ResponseResult.FAIL);
        result.setMsg(se.getMessage());

        om.writeValue(response.getOutputStream(), result);
    }

}
</code></pre>

<p>}</p>

<p>@Entity
@Table(name=&ldquo;t_pet&rdquo;)
@JsonFilter(&ldquo;myPet&rdquo;)
class Pet {</p>

<pre><code>private int id;
private String nickName;
private String password;
private boolean gender;
private Date birthday;


private String privateModulus;
private String privateExponent;
private String lastLoginIp;
//......略
</code></pre>

<p>```</p>

<p>&emsp;&emsp;最后贴出RSA工具类，因为上面的登录代码中用到了。</p>

<p>``` java RSAUtil.java
public class RSAUtil {</p>

<pre><code>public static final String PUBLIC_KEY = "public_key";
public static final String PRIVATE_KEY = "private_key";

//生成RSA密钥的位数
public static final int ENC_LENGTH = 512;

public static Map generateKeyPair() {

    KeyPairGenerator keyPairGen;
    try {
        keyPairGen = KeyPairGenerator.getInstance("RSA");
        keyPairGen.initialize(ENC_LENGTH);
        KeyPair keyPair = keyPairGen.generateKeyPair();

        Map keys = new HashMap();
        keys.put(PUBLIC_KEY, keyPair.getPublic());
        keys.put(PRIVATE_KEY, keyPair.getPrivate());

        return keys;

    } catch (NoSuchAlgorithmException e) {
        throw new RuntimeException(e);
    }


}

/**
 * 使用模和指数生成RSA公钥
 * 注意：【此代码用了默认补位方式，为RSA/None/PKCS1Padding，不同JDK默认的补位方式可能不同，如Android默认是RSA
 * /None/NoPadding】
 * 
 * @param modulus
 *            模
 * @param exponent
 *            指数
 * @return
 */
public static RSAPublicKey generatePublicKey(String modulus, String exponent) {
    try {
        BigInteger b1 = new BigInteger(modulus);
        BigInteger b2 = new BigInteger(exponent);
        KeyFactory keyFactory = KeyFactory.getInstance("RSA");
        RSAPublicKeySpec keySpec = new RSAPublicKeySpec(b1, b2);
        return (RSAPublicKey) keyFactory.generatePublic(keySpec);
    } catch (Exception e) {
        e.printStackTrace();
        return null;
    }
}

/**
 * 使用模和指数生成RSA私钥
 * 注意：【此代码用了默认补位方式，为RSA/None/PKCS1Padding，不同JDK默认的补位方式可能不同，如Android默认是RSA
 * /None/NoPadding】
 * 
 * @param modulus
 *            模
 * @param exponent
 *            指数
 * @return
 */
public static RSAPrivateKey generatePrivateKey(String modulus,
        String exponent) {
    try {
        BigInteger b1 = new BigInteger(modulus);
        BigInteger b2 = new BigInteger(exponent);
        KeyFactory keyFactory = KeyFactory.getInstance("RSA");
        RSAPrivateKeySpec keySpec = new RSAPrivateKeySpec(b1, b2);
        return (RSAPrivateKey) keyFactory.generatePrivate(keySpec);
    } catch (Exception e) {
        e.printStackTrace();
        return null;
    }
}
</code></pre>

<p>}
```</p>

<p>&emsp;&emsp;上面的代码写得比较乱且粗糙，仅供大家了解我描述的处理步骤哦。如果你要把上面的代码用于生产环境则必须进行重构，可考虑把所有的逻辑都放入login这个业务方法中。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[java安全那些事之五（客户端安全）]]></title>
    <link href="http://yanyaner.com/blog/2014/04/21/security5/"/>
    <updated>2014-04-21T15:18:00+08:00</updated>
    <id>http://yanyaner.com/blog/2014/04/21/security5</id>
    <content type="html"><![CDATA[<p>&emsp;&emsp;安全问题的水很深，“乌云”平台上曝光的一些漏洞不凡BAT(百度、阿里、腾讯)等一些大的公司，这些公司一般都有专业的安全团队都会出问题，更何况一些小的公司。本文简单讲解前端的一些安全知识，以引起大家注意。</p>

<p>&emsp;&emsp;前端常见的安全问题有：sql注入，xss以及csrf这几大类，而解决的核心思路就是：不要信任用户提交的任何东西。</p>

<p>&emsp;&emsp;sql注入问题虽然是一个古老的问题，但目前仍然还是有很多系统存在这个漏洞，避免sql注入漏洞说来也是比较简单的，程序开发人员要特别注意的是：不要把用户的输入直接拼装成sql然后执行。java中的主流orm框架如hibernate、ibatis等都考虑到这个问题，如果你用原生jdbc编程则需要预编译你的sql得到PreparedStatement，另外，alibaba的druid数据源中如果开启了wall filter也具备jdbc底层的sql注入防护功能。</p>

<p>&emsp;&emsp;再来看xss，xss是跨站脚本攻击，比如你的一个界面字段中用户输入了有具有执行能力的js代码，如果服务器端不做任何处理就将用户输入保存到数据库中，前端展示又直接将数据库中取出的内容拼在页面中，就会存在xss漏洞。当有其它用户在查看到这段信息时，就有可能把用户的cookie等信息发送到对方指定的服务器上，这真的是太危险了。</p>

<p>&emsp;&emsp;xss的解决办法主要是对客户输入的内容进行过淲处理，也有人叫“消毒”。</p>

<p>&emsp;&emsp;比如下面的一段代码，就实现了简单粗暴式的用户输入消毒。<!--more--></p>

<p>``` java</p>

<pre><code>private static Logger log = LoggerFactory.getLogger("[HtmlCodeUtil]");
private static final String regEx_script = "&lt;[\\s]*?script[^&gt;]*?&gt;[\\s\\S]*?&lt;[\\s]*?\\/[\\s]*?script[\\s]*?&gt;";//定义script的正则表达式{或&lt;script[^&gt;]*?&gt;[\\s\\S]*?&lt;\\/script&gt; }
private static final String regEx_style = "&lt;[\\s]*?style[^&gt;]*?&gt;[\\s\\S]*?&lt;[\\s]*?\\/[\\s]*?style[\\s]*?&gt;";  // 定义style的正则表达式{或&lt;style&gt;]*?&gt;[\s\S]*?&lt;\/style&gt; }
private static final String regEx_html = "&lt;[^&gt;]+&gt;";  // 定义HTML标签的正则表达式
private static Pattern p_script;
private static Pattern p_style;
private static Pattern p_html;

/**
 * 将字符串中的html内容替换成 “”
 * @param inputString
 * @return
 */
public static String html2Text(String inputHtmlString) {

    Matcher m_script;
    Matcher m_style;
    Matcher m_html;

    if (inputHtmlString == null) {
        return "";
    }
    ;

    try {
        m_script = p_script.matcher(inputHtmlString);
        inputHtmlString = m_script.replaceAll("");  // 过滤script标签

        m_style = p_style.matcher(inputHtmlString);
        inputHtmlString = m_style.replaceAll("");  // 过滤style标签

        m_html = p_html.matcher(inputHtmlString);
        inputHtmlString = m_html.replaceAll("");  // 过滤html标签
    } catch (Exception e) {
        log.error("filter html code error, content is:{}", inputHtmlString);
        //清空
        inputHtmlString = "您提交的内容有系统不允许的标签！";
    }

    return inputHtmlString; // 返回文本字符串
}
</code></pre>

<p>```</p>

<p>&emsp;&emsp;使用如下测试代码：</p>

<p>```java</p>

<pre><code>public static void main(String[] args) {
    System.out.println(HtmlUtils.htmlEscape("&lt;script&gt;while (true) {alert('aa');};&lt;/script&gt;&lt;p&gt;Hello&lt;/p&gt;"));
}
</code></pre>

<p>```
&emsp;&emsp;但是，上面的消毒代码过于简单粗暴，在一般在项目中我们可以使用开源的工具来帮助我们做过滤消毒的事。<a href="http://code.google.com/p/xssprotect/">xssprotect</a>、<a href="http://josephoconnell.com/java/xss-html-filter/">HTML filtering utility for Java</a>都实现了过滤消毒的功能。</p>

<p>&emsp;&emsp;请大家看看HTML filtering使用的演示代码如下：</p>

<p>```java</p>

<pre><code>    String html = "&lt;script&gt;while (true) {alert('aa');};&lt;/script&gt;&lt;p&gt;Hello&lt;/p&gt;";

    String result  = new HTMLFilter().filter(html);
    System.out.println(result);


    //输出的结果是：while (true) {alert('aa');};Hello
</code></pre>

<p>```</p>

<p>&emsp;&emsp;最后一个，也是比较棘手的个是CSRF漏洞攻击，CSRF和XSS不相同，CSRF以用户的身份进行合法的操作的一种攻击方式，也叫做跨站请求伪造。比如：伪造用户的一个合法请求<a href="">http://www.domain.com/addNews.do?title=发布重大新闻啦</a>,将这个地址放入一个超链接的href中，然后再发布到系统中。这个时候，如果一个合法用户登录成功后，无意中点击了这个链接，那么系统就会以他的身份发布一条新闻，而用户可能对自己发布新闻这个行为浑然不知。如果这个链接是一个转账或删除某些数据的操作，那么危险性就显而易见了。</p>

<p>&emsp;&emsp;解决CSRF不能简单地用过滤消毒、不允许发布本站地址的url等方式解决（因为url可以通过另的方式发送给用户），我们需要另想办法。</p>

<p>&emsp;&emsp;一种方案是使用restful风格设计系统api，get请求仅仅做等幂的数据查询，而post、delete、put会对数据进行修改，这样一来就可以防止链接中的CSRF修改数据带来的风险，但这并不能完全保证数据的安全，因为通过js、iframe、表单等方式还是可让伪造的地址以合法的身份运行，但是restful风格的设计确实可以提高CSRF攻击门槛，也是我们在今后所有项目中都必须采用的一种系统对外接口。</p>

<p>&emsp;&emsp;也有人采用检测http referer的方式，如果referer不是本站域名中的，则不予功能的执行，就像很多网站图片防盗链接的做法相同，这种检测referer的方式也可以阻止很大一部分通过QQ、邮件发来的CSRF攻击链接。</p>

<p>&emsp;&emsp;还有一种做法比较好，就是对每个url都带一个服务器端生成的token令牌，一个token用过一次后就失效（记得在struts1中就曾经有防止表单重复提交的功能，原理和我这讲的是相同的），这样可以有效防止CSRF，但同时也增加了系统的复杂性，因为服务器要在会话状态中记住每一个页面每一个操作链接的token，实际项目中可采用专门提取出来一个抽象层来做这事会更好些。</p>

<p>&emsp;&emsp;还是那句话，“道高一尺魔高一丈”，今天看似安全的东西也许明天就出现漏洞，没有绝对的安全，做为企业必须要有安全意识，并随时关注安全方面的资讯及内容。更多xss与csrf的内容请大家参阅<a href="https://blog.tonyseek.com/post/introduce-to-xss-and-csrf/">《总结 XSS 与 CSRF 两种跨站攻击》</a>一文。</p>
]]></content>
  </entry>
  
</feed>
