<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[☺分类☺：技术 | 刘江华的博客]]></title>
  <link href="http://yanyaner.com/blog/categories/ji-zhu/atom.xml" rel="self"/>
  <link href="http://yanyaner.com/"/>
  <updated>2014-03-08T15:59:44+08:00</updated>
  <id>http://yanyaner.com/</id>
  <author>
    <name><![CDATA[冰雨]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[项目中ibatis与hibernate混用示例详解]]></title>
    <link href="http://yanyaner.com/blog/2014/03/06/ibatis-hibernate-in-query/"/>
    <updated>2014-03-06T12:18:00+08:00</updated>
    <id>http://yanyaner.com/blog/2014/03/06/ibatis-hibernate-in-query</id>
    <content type="html"><![CDATA[<p>&emsp;&emsp;对于一般的项目hibernate足以胜任，但在选择一个框架时都要考虑适用场景（比如非功能性需求），hibernate也不例外，比如：复杂多条件组合查询对于hibernate来说并不方便（我们需要手工拼接sql）。基于这样的原因，很多项目中会引入ibatis来做复杂查询操作以做为补充，这主要是针对编码复杂度的考虑，性能也是其次的一个因素（其实hibernate也不存在问题的，你还记得到hibernater中有SqlQuery么，呵呵）。</p>

<p>&emsp;&emsp;下面我给出一个简单的ibatis与hibernate混用示例，并在最后说明在实际使用过程中应该注意的问题。先来看spring的核心配置文件：</p>

<p>``` xml spring-core.xml</p>

<pre><code>&lt;!-- 读取配置参数 --&gt;
&lt;bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt;
    &lt;property name="location"&gt;
        &lt;value&gt;classpath:database.properties&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;!-- 配置数据源 --&gt;
&lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"
      init-method="init" destroy-method="close"
&gt;
    &lt;property name="driverClassName"&gt;
        &lt;value&gt;${driverClassName}&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="url"&gt;
        &lt;value&gt;${url}&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="username"&gt;
        &lt;value&gt;${username}&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="password"&gt;
        &lt;value&gt;${pwd}&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="defaultAutoCommit"&gt;
        &lt;value&gt;false&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="initialSize" value="1" /&gt;
    &lt;property name="filters" value="stat,log4j" /&gt;
    &lt;property name="name" value="myDatasource1"&gt;&lt;/property&gt;
    &lt;!-- 最大活动连接数，也就是连接池中的最大缓存连接数 --&gt;
    &lt;property name="maxActive" value="20" /&gt;
    &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt;
    &lt;property name="timeBetweenEvictionRunsMillis" value="10000" /&gt;
    &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt;
    &lt;property name="minEvictableIdleTimeMillis" value="10000" /&gt;
    &lt;property name="minIdle" value="1" /&gt; 


&lt;/bean&gt;

&lt;!-- hibernate参数配置文件，包括缓存的信息 --&gt;
&lt;bean id="hibernateProperties" class="org.springframework.beans.factory.config.PropertiesFactoryBean"&gt;
    &lt;property name="location"&gt;
        &lt;value&gt;classpath:hibernate-config.properties&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;


&lt;!--  配置sessionFactory--&gt;
&lt;bean id="sessionFactory" class="org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean"&gt;
    &lt;property name="dataSource"&gt;
        &lt;ref bean="dataSource" /&gt;
    &lt;/property&gt;
    &lt;property name="hibernateProperties" ref="hibernateProperties"&gt;&lt;/property&gt;
    &lt;property name="packagesToScan"&gt;
        &lt;list&gt;
            &lt;value&gt;com.my.monitor.model&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt; 
&lt;/bean&gt;

&lt;!-- 配置事务管理器 --&gt;
&lt;bean id="transactionManager"
    class="org.springframework.orm.hibernate3.HibernateTransactionManager"&gt;
    &lt;property name="sessionFactory" ref="sessionFactory"&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;!-- 对注解事务的支持 --&gt;
&lt;tx:annotation-driven transaction-manager="transactionManager" /&gt;

&lt;!-- 注解驱动 --&gt;
&lt;context:component-scan base-package="com.my.monitor" &gt;&lt;/context:component-scan&gt; 

&lt;!-- hibernate通用dao --&gt;
&lt;bean id="hibernateBaseDao"
    class="com.my.ms.framework.persistence.hibernate.BaseDaoHibernateImpl"&gt;
    &lt;property name="sessionFactory" ref="sessionFactory"&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;!-- ibatis通用dao，一般用于查询 --&gt;
&lt;bean id="ibatisBaseDao" class="com.my.ms.framework.persistence.ibatis.BaseDao"&gt;
    &lt;property name="sqlMapClient"&gt;
        &lt;bean class="org.springframework.orm.ibatis.SqlMapClientFactoryBean"&gt;
            &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;
            &lt;property name="configLocation"&gt;
                &lt;value&gt;classpath:config/ibatis/sqlMapConfig.xml&lt;/value&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>

<p>```</p>

<p>&emsp;&emsp;这里封装了两个baseDao，分别针对的是hibernate与ibatis书写，源代码如下：<!-- more --></p>

<p>``` java BaseDaoHibernateImpl.java
package com.my.ms.framework.persistence.hibernate;</p>

<p>import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;</p>

<p>import org.hibernate.HibernateException;
import org.hibernate.Query;
import org.hibernate.Session;
import org.springframework.orm.hibernate3.HibernateCallback;
import org.springframework.orm.hibernate3.support.HibernateDaoSupport;
import org.springframework.util.Assert;</p>

<p>import com.my.ms.framework.persistence.model.Page;</p>

<p>public class BaseDaoHibernateImpl extends HibernateDaoSupport implements</p>

<pre><code>    IBaseDao {

@Override
public void addEntity(Object entity) {
    getHibernateTemplate().save(entity);
}

@Override
public void updateEntity(Object entity) {
    getHibernateTemplate().update(entity);
}

@Override
public void deleteEntity(Object entity) {
    getHibernateTemplate().delete(entity);
}

@Override
public void deleteEntityById(Class clazz, Serializable id) {
    getHibernateTemplate().delete(this.queryEntityById(clazz, id));
}

@Override
public &lt;T&gt; T queryEntityById(Class&lt;T&gt; clazz, Serializable id) {
    return getHibernateTemplate().get(clazz, id);
}

@Override
public List queryEntitys(String queryString, Object[] values) {
    return getHibernateTemplate().find(queryString, values);
}

@Override
public Page queryEntityByPage(int pageNo, int pageSize, String queryString,
        Object[] parameters) {
    Assert.isTrue(pageNo &gt; 0, "起始页不能小于0！");
    // 去除select 子句，未考虑union的情况
    int beginPos = queryString.toLowerCase().indexOf("from");
    Assert.isTrue(beginPos != -1, queryString + "无效，必须包含from关键字");
    String hql4Count = " select count(*)  "
            + queryString.substring(beginPos);
    return queryEntityByPage(pageNo, pageSize, queryString, hql4Count,
            parameters);
}

@Override
public Page queryEntityByPage(final int pageNo, final int pageSize,
        final String queryString4Data, final String queryString4Count,
        final Object[] parameters) {
    Assert.hasText(queryString4Count, "用于计数的hql不能为空!");
    Assert.hasText(queryString4Data, "用于查询的hql不能为空！");
    Assert.isTrue(pageNo &gt; 0, "起始页不能小于0！");
    return (Page) getHibernateTemplate().execute(new HibernateCallback() {

        public Object doInHibernate(Session session)
                throws HibernateException {

            // 根据指定的参数执行hibernate hql查询
            List countlist = getHibernateTemplate().find(queryString4Count,
                    parameters);

            long totalCount = ((Long) countlist.get(0)).longValue();
            // 如果记录总数小于1则返回空的Page
            if (totalCount &lt; 1)
                return new Page(pageNo, pageSize, new ArrayList(), 0);
            int startIndex = Page.getStartOfPage(pageNo, pageSize);
            Query query = getSession().createQuery(queryString4Data);
            for (int i = 0; i &lt; parameters.length; i++) {
                query.setParameter(i, parameters[i]);
            }
            List list = query.setFirstResult(startIndex)
                    .setMaxResults(pageSize).list();
            return new Page(pageNo, pageSize, list, (int) totalCount);
        }

    });
}
</code></pre>

<p>}</p>

<p>```</p>

<p>针对ibatis的baseDao封装，主要是添加了一个分页方法，代码如下：</p>

<p>``` java BaseDao.java</p>

<p>package com.my.ms.framework.persistence.ibatis;</p>

<p>import java.util.Map;</p>

<p>import org.springframework.orm.ibatis.SqlMapClientTemplate;</p>

<p>import com.my.ms.framework.persistence.model.Page;</p>

<p>public class BaseDao extends SqlMapClientTemplate {</p>

<pre><code>/**
 * 分页查询(sql语句块中的分页参数，请使用start与end)
 * @param pageNo
 * @param pageSize
 * @param sqlId4Data
 * @param sqlId4count
 * @param queryParam
 * @return
 */
public Page queryEntityByPage(int pageNo, int pageSize, String sqlId4Data, String sqlId4Count, Map queryParam) {

    queryParam.put("start", (pageNo - 1) * pageSize);
    queryParam.put("end", pageSize);

    Page page = new Page(pageNo, pageSize);

    page.setData(queryForList(sqlId4Data, queryParam));
    page.setRowcounts(((Number)queryForObject(sqlId4Count, queryParam)).intValue());

    return page;
}
</code></pre>

<p>}</p>

<p>```</p>

<p>&emsp;&emsp;上面两个实现的分页部分，用到了Page对象，请看分页对象的代码：</p>

<p>``` java</p>

<p>package com.my.ms.framework.persistence.model;</p>

<p>import java.util.List;</p>

<p>/<em>*
 * 分页对象
 * @author ljh
 *
 </em>/
public class Page<T> {</p>

<pre><code>/**
 * 数据对象
 */
private List&lt;T&gt; data;

private int rowcounts;
/**
 * 页码
 */
private int pageNo;
/**
 * 最大显示页数
 */
private int pageSize;

public Page(){

}

public Page(int pageNo, int pageSize) {
    this.pageNo = pageNo;
    this.pageSize = pageSize;
}

public Page(int pageNo, int pageSize, List&lt;T&gt; data, int rowcounts) {
    this.pageNo = pageNo;
    this.pageSize = pageSize;
    this.data = data;
    this.rowcounts = rowcounts;
}

//计算该页对应的数据库下标
public static int getStartOfPage(int pageNo, int pageSize) {
    if (0 &gt; pageNo)
        throw new IllegalArgumentException("页面索引不能小于0!");
    return (pageNo - 1) * pageSize;
}


//共有多少页
public int getPages() {
    if (rowcounts % pageSize == 0) 
    {
        return rowcounts/pageSize;
    } else {
        return rowcounts/pageSize + 1;
    }
}

public int getFirstNo() {
    return 1;
}

public int getLastNo() {
    return getPages();
}

public int getPreNo() {
    if (pageNo - 1 &gt; 0 ) {
        return pageNo - 1;
    } else {
        return 1;
    }
} 

public int getNextNo() {
    if (pageNo + 1  &lt;= getPages()) {
        return pageNo + 1;
    }
    return getPages();
}



public List&lt;T&gt; getData() {
    return data;
}

public void setData(List&lt;T&gt; data) {
    this.data = data;
}

public int getPageNo() {
    return pageNo;
}

public void setPageNo(int pageNo) {
    this.pageNo = pageNo;
}

public int getPageSize() {
    return pageSize;
}

public void setPageSize(int pageSize) {
    this.pageSize = pageSize;
}

public int getRowcounts() {
    return rowcounts;
}

public void setRowcounts(int rowcounts) {
    this.rowcounts = rowcounts;
}
</code></pre>

<p>}</p>

<p>```</p>

<p>&emsp;&emsp;具体使用时就比较方便了，下面是一个调用示例：</p>

<p>``` java UserServiceImpl.java</p>

<p>@Service
@Transactional(readOnly=false)
public class UserServiceImpl implements IUserService{</p>

<pre><code>@Resource
private IBaseDao hibernateDao;

@Resource
private BaseDao ibatisDao;

@Override
public User someBizMethod(int userId) {

    ......

    User u1 = (User)hibernateDao.queryEntityById(User.class, userId);
    u1.setUserName(u2.getUserName() + "hibernate");
    hibernateDao.updateEntity(u1);

    User u2 = (User)ibatisDao.queryForObject("znjk.getUserById", userId);
    u2.setUserName(u2.getUserName() + "ibatis");
    ibatisDao.update("znjk.updateUser",  u2);

    ......
</code></pre>

<p>```</p>

<p>&emsp;&emsp;好了，在上面的示例中还存在一些必须要弄明白的问题。</p>

<p>&emsp;&emsp;一、事务管理问题。大家可以看到，我在spring文件中只配置了一个事务管理器，并且是hibernate的事务管理器，那么，有人就有会疑问：hibernater的事务可以应用在ibatis的dao上么？答案是肯定的。至于原因，你想想spring事务管理是通过AOP来实现的，并且最终映射到底层的话，事务是通过在jdbc的connection上完成的，而在我上面的这个业务方法中，两个dao拿到的是同一个连接，因此，方法中的所有操作都在一个事务环境中了，这个事务是通过hibernate事务管理器启动的。</p>

<p>&emsp;&emsp;二、缓存同步问题。两个框架都有自己不同的缓存配置及实现，而且互不相关。因为这个原因，我上面的代码没法对保证缓存的一致性，所以，我的建议是：ibatis仅仅只做复杂查询，hibernate什么都可以做。此外，还有一个方案是，配置ibatis的数据源事务管理器，在不同的方法中，通过@Transactional注解来指定这个业务方法使用的事务管理器（比如：@Transactional(readOnly=false,value=&ldquo;dataSourceTransactionManager&rdquo;)），也就是说，在每一个方法中不存在两个dao混用的情况，而在不同的方法中，用不同的事务管理器操作事务的提交。</p>

<p>&emsp;&emsp;ibatis的优势在于查询，特别是类似下面的组合查询，十分的方便。复杂查询更是如此。</p>

<p>``` xml
<sql id="where4pet"></p>

<pre><code>    &lt;dynamic prepend="where"&gt;
        &lt;isNotNull property="nickName" prepend="and"&gt;
            f_nick_name like '%$nickName$%'
        &lt;/isNotNull&gt;
        &lt;isNotNull property="password" prepend="and"&gt;
            f_password like '%$password$%'
        &lt;/isNotNull&gt;
        &lt;isNotNull property="birthday" prepend="and"&gt;
            f_birthday = #birthday#
        &lt;/isNotNull&gt;
        &lt;isNotNull property="gender" prepend="and"&gt;
            &lt;isEqual compareProperty="gender" compareValue="true"&gt;
                f_gender = 'T'
            &lt;/isEqual&gt;
            &lt;isEqual compareProperty="gender" compareValue="false"&gt;
                f_gender = 'F'
            &lt;/isEqual&gt;
        &lt;/isNotNull&gt;
        &lt;isNotNull property="age" prepend="and"&gt;
            f_age = #age#
        &lt;/isNotNull&gt;
    &lt;/dynamic&gt;
&lt;/sql&gt;

&lt;select id="getPetByPage4data" resultMap="resultMapPet" &gt;
    select *
    from t_pet
    &lt;include refid="where4pet"/&gt;
    order by $field$
    limit #start#, #end#
&lt;/select&gt;
&lt;select id="getPetByPage4count" resultClass="int"&gt;
    select count(*)
    from t_pet
    &lt;include refid="where4pet"/&gt;
&lt;/select&gt;
</code></pre>

<p>```</p>

<p>&emsp;&emsp;这样的话，我们就可以充分利用不同框架的优势，达到取长补短的目的。也许你会说，这种方式就是把增、删、改交由hibernate来做，把查询交由ibatis来做。本质上看确实如此，但实际项目中要灵活去做，比如hibernate除了增删改外也可以做查询，特别是简单的查询，这样也可以更好的利用到hibernate的缓存。</p>

<p>&emsp;&emsp;我在<a href="/blog/2010/11/01/p4">四种持久层设计方案比较</a>中，对查询的分离有所介绍，有兴趣的可以去看看其中的一个方案，另外，CQRS架构、mysql读写分离也有这方面的含义。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[再次简单封装的jackson]]></title>
    <link href="http://yanyaner.com/blog/2014/03/04/objectmapper-json/"/>
    <updated>2014-03-04T12:18:00+08:00</updated>
    <id>http://yanyaner.com/blog/2014/03/04/objectmapper-json</id>
    <content type="html"><![CDATA[<p>&emsp;&emsp;接上一篇<a href="/blog/2014/03/03/objectmapper-json">Json类库jackson使用之误区</a>，我对json的常用操作再次进行了简单的封装，上一版的封装大家可参阅<a href="/blog/2012/12/14/jackson">Jackson之json类二次封装</a>。</p>

<p>&emsp;&emsp;总计两个文件，只考虑到了一些简单常用的操作：</p>

<p>``` java FilterProvider.java</p>

<p>package com.my.ms.framework.commons;</p>

<p>import org.codehaus.jackson.map.ser.impl.SimpleBeanPropertyFilter;
import org.codehaus.jackson.map.ser.impl.SimpleFilterProvider;
/<em>*
 * 属性过滤器
 * @author ljh
 *
 </em>/
public class FilterProvider extends SimpleFilterProvider {</p>

<pre><code>/**
 * 将新的需要的属性添加到一个现有的FilterProvider中
 * @param id
 * @param includeProperties
 * @return
 */
public FilterProvider addIncludeProperties(String id,
        String... includeProperties) {
    this.addFilter(id,
            SimpleBeanPropertyFilter.filterOutAllExcept(includeProperties));
    return this;
}
</code></pre>

<p>}</p>

<p>```</p>

<p>&emsp;&emsp;FilterProvider.java中主要增加了一个输出时添加包含属性的方法，并返回自身以支持方法链编程。<!-- more --></p>

<p>``` java JsonMapper.java</p>

<p>package com.my.ms.framework.commons;</p>

<p>import java.io.IOException;
import java.io.OutputStream;
import java.text.SimpleDateFormat;</p>

<p>import org.codehaus.jackson.JsonGenerationException;
import org.codehaus.jackson.map.DeserializationConfig;
import org.codehaus.jackson.map.JsonMappingException;
import org.codehaus.jackson.map.ObjectMapper;
import org.codehaus.jackson.map.SerializationConfig.Feature;
import org.codehaus.jackson.map.ser.impl.SimpleBeanPropertyFilter;
import org.codehaus.jackson.map.ser.impl.SimpleFilterProvider;</p>

<p>/<em>*
 * json之jackson封装
 * 主要对常用的几个json方法进行了再次包装，并具备线程安全性
 * @author ljh
 *
 </em>/
public class JsonMapper {</p>

<pre><code>private ObjectMapper objectMapper;

public JsonMapper() {
    objectMapper = new ObjectMapper();
    // 设置默认日期格式
    objectMapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd"));
    // 提供其它默认设置
    objectMapper
            .disable(DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES);
    objectMapper.configure(Feature.FAIL_ON_EMPTY_BEANS, false);
    objectMapper.setFilters(new SimpleFilterProvider()
            .setFailOnUnknownId(false));

}

/**
 * 创建一个FilterProvider对象
 * 
 * @return
 */
public static FilterProvider buildFilterProvider() {
    FilterProvider filter = new FilterProvider();
    filter.setFailOnUnknownId(false);
    return filter;
}

/**
 * 根据需要的对象属性，创建一个属性过滤器FilterProvider
 * 
 * @param id
 *            对象id，通过jsonFilter声明
 * @param includeProperties
 *            该对象上需要的属性
 * @return  创建好的过滤器
 */
public static FilterProvider buildFilterProvider(String id,
        String... includeProperties) {
    FilterProvider filter = new FilterProvider();
    filter.setFailOnUnknownId(false);

    filter.addFilter(id,
            SimpleBeanPropertyFilter.filterOutAllExcept(includeProperties));
    return filter;
}

// 用提供的过滤器，将对象的json输出到流中
public void writeValue(FilterProvider filter, OutputStream os, Object value)
        throws JsonGenerationException, JsonMappingException, IOException {
    objectMapper.writer(filter).writeValue(os, value);
}

// 用提供的过滤器，将对象的json输出为字符串
public String writeValueAsString(FilterProvider filter, Object value)
        throws JsonGenerationException, JsonMappingException, IOException {
    return objectMapper.writer(filter).writeValueAsString(value);
}

// 将对象的json输出到流中
public void writeValue(OutputStream os, Object value)
        throws JsonGenerationException, JsonMappingException, IOException {
    objectMapper.writeValue(os, value);
}

// 将对象的json输出为字符串
public String writeValueAsString(Object value)
        throws JsonGenerationException, JsonMappingException, IOException {
    return objectMapper.writeValueAsString(value);
}

/**
 * 得到原始的objectMapper，以进行更复杂的操作
 * 
 * @return
 */
public ObjectMapper getObjectMapper() {
    return objectMapper;
}
</code></pre>

<p>}</p>

<p>```</p>

<p>&emsp;&emsp;如果需要更强大的功能，我们可以通过getObjectMapper得到ObjectMapper后进行操作，或都添加你常用的其它方法到JsonMapper中，比如：排除属性的方法等。</p>

<p>&emsp;&emsp;使用时，请把JsonMapper放入spring容器(当然你也可以把这个类做成单例的哦)，在需要转换json的地方，通过@Resource注入即可，调用代码如下：</p>

<p>``` java</p>

<pre><code>@Resource
private JsonMapper mapper;

@Test
public void testJson() throws Exception {

    Object someObject = ....

    String result = mapper.writeValueAsString(
            JsonMapper.buildFilterProvider()
            .addIncludeProperties("myId1", "id","name")
            .addIncludeProperties("myId2", "code","money","name"), 
            someObject);

    assertEquals("xxxxxxxxxxxx", result);

}
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[json类库jackson使用之误区]]></title>
    <link href="http://yanyaner.com/blog/2014/03/03/objectmapper-json/"/>
    <updated>2014-03-03T12:18:00+08:00</updated>
    <id>http://yanyaner.com/blog/2014/03/03/objectmapper-json</id>
    <content type="html"><![CDATA[<p>&emsp;&emsp;json数据类型在系统通讯中得到了非常广泛的应用，jsonlib, Gson, fastJson, jackson等开源的json操作类库层出不穷，根据对这些json的测试，我们发现jsckson的效率比其它的都要高。但在实际中，我发现很多人使用jackson都存在一定的问题，下面我给大家讲讲jackson使用中容易出现的一些问题。</p>

<p>&emsp;&emsp;先来看看下面的这一段代码，很多人在控制器代码中就是这么写的：</p>

<p>``` java
/**</p>

<pre><code> * 得到所有的班级
 * 
 * @param sid
 * @param resp
 * @throws Exception
 */

@RequestMapping(value = "/classes", method = RequestMethod.GET)
public void getAllClasses(HttpServletResponse resp) throws Exception {

    ObjectMapper om = new ObjectMapper();

    RespMessage msg = new RespMessage();

    SimpleFilterProvider filterProvider = new SimpleFilterProvider()
            .setFailOnUnknownId(false);
    filterProvider.addFilter("my_classes",
            SimpleBeanPropertyFilter.filterOutAllExcept("id", "name"));
    om.setFilters(filterProvider);

    List&lt;Classes&gt; data = systemService.getAllClasses();

    msg.setData(data);

    om.writeValue(resp.getOutputStream(), msg);

}
</code></pre>

<p>```</p>

<p>&emsp;&emsp;晃眼一看，似乎没有问题，但是，这段代码在高并发操作下，性能非常的低下。有人说，这个容易，改一下代码即可，如下：<!-- more --></p>

<p>``` java</p>

<pre><code>private ObjectMapper om = new ObjectMapper();

/**
 * 得到所有的班级
 * 
 * @param sid
 * @param resp
 * @throws Exception
 */
@RequestMapping(value = "/classes", method = RequestMethod.GET)
public void getAllClasses(HttpServletResponse resp) throws Exception {

    ....
    SimpleFilterProvider filterProvider = new SimpleFilterProvider()
            .setFailOnUnknownId(false);
    filterProvider.addFilter("my_classes",
            SimpleBeanPropertyFilter.filterOutAllExcept("id", "name"));
    om.setFilters(filterProvider);
    ....

    om.writeValue(resp.getOutputStream(), msg);

}
</code></pre>

<p>```</p>

<p>&emsp;&emsp;上面的代码中，让ObjectMapper做为全局对象（或者干脆放入spring容器中，保持一个实例），不反复创建这个对象，应该就没有问题了吧。</p>

<p>&emsp;&emsp;不幸的是，上面这段代码仍然存在问题，因为ObjectMapper的全局性，致使过渡属性的操作在多线程中出现问题，请看下面的测试代码：</p>

<p>``` java
public class CopyOfTest {</p>

<pre><code>public static void main(String[] args) {

    ObjectMapper o1 = new ObjectMapper();
    ObjectMapper o2 = o1;

    Thread t1 = new MyThread(o1, 1);
    Thread t2 = new MyThread(o2, 2);

    t1.start();
    t2.start();

}
</code></pre>

<p>}</p>

<p>class MyThread extends Thread {</p>

<pre><code>private ObjectMapper om;

private int threadId;

public MyThread(ObjectMapper om, int threadId) {
    this.om = om;
    this.threadId = threadId;
}

//产生1秒内的随机暂停
private void pauseRandomTimes() {
    try {
        Thread.sleep((long)Math.ceil(Math.random()*1000));
    } catch (InterruptedException e1) {
        e1.printStackTrace();
    }
}

@Override
public void run() {

    Student s = new Student();
    s.setId(1);
    s.setName("张三");

    for (int i = 0; i &lt; 10 ; i++) {


        if (threadId == 1)   {
            SimpleFilterProvider filterProvider = new SimpleFilterProvider().setFailOnUnknownId(false);
            filterProvider.addFilter("myStudent", SimpleBeanPropertyFilter.filterOutAllExcept("id"));
            om.setFilters(filterProvider);
            try {
                //随机休眠一段时间
                pauseRandomTimes();
                System.out.println("线程1中的输出是：" + om.writeValueAsString(s));
            } catch (Exception e) {
                e.printStackTrace();
            }
        } else {
            SimpleFilterProvider filterProvider = new SimpleFilterProvider().setFailOnUnknownId(false);
            filterProvider.addFilter("myStudent", SimpleBeanPropertyFilter.filterOutAllExcept("id","name"));
            om.setFilters(filterProvider);
            try {
                //随机休眠一段时间
                pauseRandomTimes();
                System.out.println("线程2中的输出是：" + om.writeValueAsString(s));
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

    }

}
</code></pre>

<p>}</p>

<p>```</p>

<p>&emsp;&emsp;上面的这段多线程测试程序中，本计划在线程1中只输入对象的id属性，线程2中输出id、name两个属性，但通过下面的结果，我们发现事与愿违，两个线程中的输出混乱了，这就是共享了一个ObjectMapper并通过om.setFilters造成的原因。</p>

<p>```</p>

<p>线程2中的输出是：{&ldquo;id&rdquo;:1}
线程2中的输出是：{&ldquo;id&rdquo;:1,&ldquo;name&rdquo;:&ldquo;张三&rdquo;}
线程2中的输出是：{&ldquo;id&rdquo;:1,&ldquo;name&rdquo;:&ldquo;张三&rdquo;}
线程2中的输出是：{&ldquo;id&rdquo;:1,&ldquo;name&rdquo;:&ldquo;张三&rdquo;}
线程1中的输出是：{&ldquo;id&rdquo;:1,&ldquo;name&rdquo;:&ldquo;张三&rdquo;}
线程2中的输出是：{&ldquo;id&rdquo;:1}
线程1中的输出是：{&ldquo;id&rdquo;:1,&ldquo;name&rdquo;:&ldquo;张三&rdquo;}
线程1中的输出是：{&ldquo;id&rdquo;:1}
线程1中的输出是：{&ldquo;id&rdquo;:1}
线程1中的输出是：{&ldquo;id&rdquo;:1}
线程2中的输出是：{&ldquo;id&rdquo;:1}
线程1中的输出是：{&ldquo;id&rdquo;:1,&ldquo;name&rdquo;:&ldquo;张三&rdquo;}
线程1中的输出是：{&ldquo;id&rdquo;:1}
线程2中的输出是：{&ldquo;id&rdquo;:1}
线程2中的输出是：{&ldquo;id&rdquo;:1,&ldquo;name&rdquo;:&ldquo;张三&rdquo;}
线程1中的输出是：{&ldquo;id&rdquo;:1,&ldquo;name&rdquo;:&ldquo;张三&rdquo;}
线程2中的输出是：{&ldquo;id&rdquo;:1}
线程2中的输出是：{&ldquo;id&rdquo;:1,&ldquo;name&rdquo;:&ldquo;张三&rdquo;}
线程1中的输出是：{&ldquo;id&rdquo;:1,&ldquo;name&rdquo;:&ldquo;张三&rdquo;}
线程1中的输出是：{&ldquo;id&rdquo;:1}</p>

<p>```</p>

<p>&emsp;&emsp;如何改造达到我们的要求呢？如下即可，但这又会造成并发下的性能问题。</p>

<p>``` java
ObjectMapper o1 = new ObjectMapper();
ObjectMapper o2 = new ObjectMapper();
Thread t1 = new My2Thread(o1, 1);
Thread t2 = new My2Thread(o2, 2);</p>

<p>```</p>

<p>&emsp;&emsp;最终的做法是：</p>

<p>&emsp;&emsp;1、将ObjectMapper作为全局；</p>

<p>&emsp;&emsp;2、通过om.writer(filterProvider).write&hellip;.. 的方式输出。即保证性能，出满足多线程。</p>

<p>&emsp;&emsp;最后，看一看两种写法的性能测试结果：</p>

<p>``` java
public static void main1(String[] args) {</p>

<pre><code>    Student s = new Student();
    s.setId(1);
    s.setName("张三");

    System.out.println("开始执行.....");
    long start = System.currentTimeMillis();

    ObjectMapper om;
    for (int i = 0; i &lt; 10000; i ++ ) {
        om = new ObjectMapper();
        SimpleFilterProvider filterProvider = new SimpleFilterProvider().setFailOnUnknownId(false);
        filterProvider.addFilter("myStudent", SimpleBeanPropertyFilter.filterOutAllExcept("id","name"));
        om.setFilters(filterProvider);
        try {
            om.writeValueAsString(s);
        } catch (Exception e) {
            e.printStackTrace();
        } 

    }
    long end = System.currentTimeMillis();
    System.out.println("执行所花时间：" + (end - start) + "ms.");


}
</code></pre>

<p>```
&emsp;&emsp;这段测试代码的输出是：执行所花时间：6078ms.</p>

<p>&emsp;&emsp;而另一种写法的测试代码如下：</p>

<p>``` java</p>

<p>public static void main(String[] args) {</p>

<pre><code>    Student s = new Student();
    s.setId(1);
    s.setName("张三");

    System.out.println("开始执行.....");
    long start = System.currentTimeMillis();

    ObjectMapper om = new ObjectMapper();
    for (int i = 0; i &lt; 10000; i ++ ) {
        SimpleFilterProvider filterProvider = new SimpleFilterProvider().setFailOnUnknownId(false);
        filterProvider.addFilter("myStudent", SimpleBeanPropertyFilter.filterOutAllExcept("id","name"));
        try {
            om.writer(filterProvider).writeValueAsString(s);
        } catch (Exception e) {
            e.printStackTrace();
        } 

    }
    long end = System.currentTimeMillis();
    System.out.println("执行所花时间：" + (end - start) + "ms.");
}
</code></pre>

<p>```</p>

<p>&emsp;&emsp;这段测试代码的输出是：执行所花时间：547ms.同样的功能，不同的实现代码，时间差距非常巨大，所以，大家在实际编码须注意到这个问题。</p>

<p>&emsp;&emsp;大家可以对ObjectMapper进行简单封装，具体请参阅我的另一篇文章<a href="/blog/2012/12/14/jackson">Jackson之json类二次封装</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[http长连接在java中的应用示例]]></title>
    <link href="http://yanyaner.com/blog/2014/02/17/comet-java/"/>
    <updated>2014-02-17T12:18:00+08:00</updated>
    <id>http://yanyaner.com/blog/2014/02/17/comet-java</id>
    <content type="html"><![CDATA[<p>&emsp;&emsp;在WEB应用中，我们可能会遇到实时性要求很高的交互场景，浏览器需要及时地显示服务器上的数据变化，服务器也需要知道客户端的一些状况，比如：下面的示例中，我给出了一个简易的在线聊天系统。</p>

<p><span class='caption-wrapper'><img class='caption' src='/uploads/2014/02/chat_login.jpg' width='' height='' title='聊天室登录界面'><span class='caption-text'>聊天室登录界面</span></span></p>

<p><span class='caption-wrapper'><img class='caption' src='/uploads/2014/02/chating.jpg' width='' height='' title='正在聊天的界面'><span class='caption-text'>正在聊天的界面</span></span></p>

<p>&emsp;&emsp;上面的在线聊天演示程序中，先通过用户名登录，登录成功后即可即可发送自己的聊天消息，界面中的在线用户列表中可以看到每一个用户的状态，比如：在线，离开，掉线等。</p>

<p>&emsp;&emsp;好，请大家先思考一下如何去实现这样的一个系统？</p>

<p>&emsp;&emsp;其实，实现的办法很多，下面我给出一些参考：</p>

<p>&emsp;&emsp;一、服务器端用java写一个socket服务器，flash或flex实现聊天客户端(当然也可以用applet之类的技术)，通过socket连接服务器实现实时通讯。这种实现方式我曾经在一个项目中用过，效果还不错。目前的html5中的web socket也可以实现这个功能（具体请参考<a href="http://www.ibm.com/developerworks/cn/web/1112_huangxa_websocket/">http://www.ibm.com/developerworks/cn/web/1112_huangxa_websocket/</a>）。</p>

<p>&emsp;&emsp;二、浏览器中写一定时器，不断发送ajax请求向服务器请求数据，服务器用一个servlet处理请求。在服务器上保存聊天室的内容，每一个用户发言后都将消息内容保存在一个集合中。</p>

<p>&emsp;&emsp;方式二，由客户端按固定的时间发起请求，这种方式虽然可以实现我们的功能，但有一些缺陷，主要表现在：1、在用户并发量大、频率高的时候，网络会拥堵，性能存在问题；2、实时性不高，比如：用户离开，掉线等状态都是要等到下一次请求才能知道，并且服务器上要有某种机制检测到某个用户已经断线；3、如果服务器端数据没有发生变更，那么这个请求只会消耗更多系统资源。</p>

<p>&emsp;&emsp;三、基于http长连接技术。这种方式中可以实现较高的实时性，当有数据发生变化时，服务器主动将数据推送到客户端。</p>

<p>&emsp;&emsp;comet长连接大致有两种实现，第一种是采用长轮询机制实现，大致过程是：由客户端发起http请求，服务器收到这个请求后，进入一个 while(ture)的循环，当有数据需要告知客户端时，将数据响应给客户端，并断开连接。客户端收到信息后进行处理，处理完成后再次发起新的请求，这就是长轮询的长连接实现。当然，客户端一般都采用ajax方式发起请求。</p>

<p>&emsp;&emsp;comet另一种采用基于流的方式实现，利用ajax的readystate为3时表示数据正在传输而保持连接不中断，服务器端可以使用基于NIO的方式提高处理效率，而不是while(true)的多线程方式。 更多关于comet的实现细节，大家可以参阅<a href="http://software.intel.com/zh-cn/articles/comet-java-realtime-system-essay/">http://software.intel.com/zh-cn/articles/comet-java-realtime-system-essay/</a>。</p>

<p>&emsp;&emsp;我这里采用comt4j框架实现http长连接（不要去重复发明轮子哦，直接用现成的）。首先要准备相应的jar包comet4j-tomcat6.jar，将其添加到你的classpath中，大家要根据不同的服务器版本添加不同的实现，因为comet4j使用的是服务器的comet之nio实现。comt4j目前仅提供了tomcat6,tomcat7的支持。<!-- More --></p>

<p>&emsp;&emsp;接下来要修改服务器的server.xml中Connector部分，以启用nio的socket方式，代码如下：</p>

<p>``` xml server.xml</p>

<p><Connector connectionTimeout="20000"
port="8080"
protocol="org.apache.coyote.http11.Http11NioProtocol"
redirectPort="8443"/></p>

<p>```</p>

<p>&emsp;&emsp;在web.xml中加入comet的支持：</p>

<p>``` xml web.xml</p>

<!-- Comet4J长连接请求处理servlet -->


<p>  <servlet></p>

<pre><code>&lt;servlet-name&gt;comet4Memory&lt;/servlet-name&gt;
&lt;servlet-class&gt;org.comet4j.core.CometServlet&lt;/servlet-class&gt;
</code></pre>

<p>  </servlet>
  &lt;servlet-mapping></p>

<pre><code>&lt;servlet-name&gt;comet4Memory&lt;/servlet-name&gt;
&lt;url-pattern&gt;/state&lt;/url-pattern&gt;
</code></pre>

<p>  &lt;/servlet-mapping></p>

<p>  <!--Comet4J容器侦听 -->
  <listener></p>

<pre><code>&lt;listener-class&gt;org.comet4j.core.CometAppListener&lt;/listener-class&gt;
</code></pre>

<p>  </listener></p>

<p>```</p>

<p>&emsp;&emsp;接下来是服务器端的代码，下面的这段代码用来进行初始化，使用Component将对象放入spring容器，并在构造中进行comet初始化：</p>

<p>``` java  CometInit.java</p>

<p>@Component
public class CometInit {</p>

<pre><code>@Resource
private IMyService ms;

public static final String CHANNEL_USER_INFO = "onlineUsers";
public static final String CHANNEL_USER_CHATING_CONTENT = "user_chating_content";

public CometInit() {

    CometContext context = CometContext.getInstance(); 
    CometEngine engine = context.getEngine();

    //添加连接监听
    engine.addConnectListener(new ConnectListener() {
        @Override
        public boolean handleEvent(ConnectEvent event) {

            CometConnection connection = event.getConn();
            String ip = connection.getClientIp();
            String id = connection.getId();

            HttpServletRequest request = connection.getRequest();

            String userName = getCookieValue(request.getCookies(), "userName-chating-client", "");

            if (userName == null) {
                return true;
            }

            try {
                userName = URLDecoder.decode(userName, "utf-8");
            } catch (UnsupportedEncodingException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }

            System.out.println("id是：" + id + "的用户连接服务器，ip是：" + ip + ",用户名是：" + userName);
            User u = UserAction.onlineUsers.get(userName);
            if (u == null) {
                return true;
            }
            u.setState(UserAction.STATE_ONLINE);
            u.setClientId(id);

            ObjectMapper om = new ObjectMapper(); 
            try {
                event.getTarget().sendToAll(CometInit.CHANNEL_USER_INFO, om.writeValueAsString(UserAction.onlineUsers.values()));
            } catch (Exception e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            } 

            return true;
        }
    });

    //添加离线、断线监听
    engine.addDropListener(new DropListener() {

        @Override
        public boolean handleEvent(DropEvent event) {

            CometConnection connection = event.getConn();
            String ip = connection.getClientIp();
            String id = connection.getId();
            HttpServletRequest request = connection.getRequest();
            String userName = getCookieValue(request.getCookies(), "userName-chating-client", "");

            if (userName == null) {
                return true;
            }

            try {
                userName = URLDecoder.decode(userName, "utf-8");
            } catch (UnsupportedEncodingException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }

            System.out.println("id是：" + id + "的用户断开与服务器的连接，ip是："+ ip + ",用户名是：" + userName);
            User u = UserAction.onlineUsers.get(userName);
            if (u == null) {
                return true;
            }
            u.setState(UserAction.STATE_MISSING);

            ObjectMapper om = new ObjectMapper(); 
            try {
                event.getTarget().sendToAll(CometInit.CHANNEL_USER_INFO, om.writeValueAsString(UserAction.onlineUsers.values()));
            } catch (Exception e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            } 
            return true;
        }
    });

    //注册信道 
    context.registChannel(CHANNEL_USER_INFO);
    context.registChannel(CHANNEL_USER_CHATING_CONTENT);


}

/**
 * 从cookiek中得到某个 key的取值
 * @param cookies
 * @param cookieName
 * @param defaultValue
 * @return
 */
public String getCookieValue(Cookie[] cookies, String cookieName, String defaultValue) {
    String result = defaultValue;
    if (cookies != null) {
        for (int i = 0; i &lt; cookies.length; i++) {
            Cookie cookie = cookies[i];
            if (cookieName.equals(cookie.getName())) {
                return cookie.getValue();
            }
        }
    }
    return result;
}
</code></pre>

<p>}</p>

<p>```</p>

<p>&emsp;&emsp;服务器端处理用户聊天请求的Action代码如下：</p>

<p>``` java ChatingAction.java</p>

<p>@Controller
public class ChatingAction {</p>

<pre><code>public static final String STATE_LOGINING = "登录中";
public static final String STATE_ONLINE = "在线";
public static final String STATE_MISSING = "掉线";
public static final String STATE_LEAVE = "离开";


private CometEngine engine;

public UserAction() {
    engine = CometContext.getInstance().getEngine(); 
}


//保存在线用户集合，在些比做持久化的用户数据
public static Map&lt;String, User&gt; onlineUsers = new HashMap&lt;String, User&gt;();

@RequestMapping("loginChat")
public String login(
        @RequestParam(value="name") String name,
        HttpSession session,
        HttpServletResponse response
        ) throws Exception {

    User user = onlineUsers.get(name);
    if (user == null) {
        //更新状态信息
        user = new User();
        user.setName(name);
        onlineUsers.put(name, user);
    } 
    //设置为正在登录状态
    user.setState(STATE_LOGINING);
    session.setAttribute("user_key", user);

    //如果是json方式返回，也可由客户端通过js添加cookie
    Cookie cookie = new Cookie("userName-chating-client",URLEncoder.encode(name,"utf-8"));  
    cookie.setMaxAge(60*60*24*7);//保留7天  
    response.addCookie(cookie);  

    //更新在线用户列表
    ObjectMapper om = new ObjectMapper(); 
    engine.sendToAll(CometInit.CHANNEL_USER_INFO, om.writeValueAsString(onlineUsers.values()));

    //进入主页面
    return "chating";

}


@RequestMapping("getState")
public void getState(
        HttpSession session,
        HttpServletResponse response
        ) throws Exception {

    User user = (User)session.getAttribute("user_key");
    ObjectMapper om = new ObjectMapper(); 
    if (user != null) {
        //返回所有的在线用户
        om.writeValue(response.getWriter(), user);
    } else {
        om.writeValue(response.getWriter(), "{code:0}");
    }

}

@RequestMapping("onlineUser")
public void allUsers(
        HttpServletResponse response
        ) throws Exception {

    //返回所有的在线用户
    ObjectMapper om = new ObjectMapper(); 
    om.writeValue(response.getWriter(), onlineUsers);


}


@RequestMapping("logout")
public String logout(
        HttpSession session,
        HttpServletResponse response
        ) throws Exception {

    User user = (User)session.getAttribute("user_key");
    if (user != null) {
        ObjectMapper om = new ObjectMapper(); 
        onlineUsers.get(user.getName()).setState(STATE_LEAVE);
        engine.sendToAll(CometInit.CHANNEL_USER_INFO, om.writeValueAsString(onlineUsers.values()));
    }

    return "chat_login";

}

@RequestMapping("sendMsg")
public void sendMsg(
        HttpSession session,
        @RequestParam(value="msg") String msg,
        HttpServletResponse response
        ) throws Exception {

    SimpleDateFormat sf = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");

    User user = (User)session.getAttribute("user_key");
    if (user != null) {
        ObjectMapper om = new ObjectMapper(); 
        Map respBody = new HashMap();
        respBody.put("date", sf.format(new Date()));
        respBody.put("user", user.getName());
        respBody.put("msg", msg);
        engine.sendToAll(CometInit.CHANNEL_USER_CHATING_CONTENT, om.writeValueAsString(respBody));
    }

    response.getWriter().print("over");
}
</code></pre>

<p>}</p>

<p>//用户
class User {</p>

<pre><code>//昵称
private String name;
//状态(登录中，在线，掉线，已录出)
private String state;
//长连接id,由comet4j自行分配
private String clientId;

public String getName() {
    return name;
}
public void setName(String name) {
    this.name = name;
}
public String getState() {
    return state;
}
public void setState(String state) {
    this.state = state;
}
public String getClientId() {
    return clientId;
}
public void setClientId(String clientId) {
    this.clientId = clientId;
}
</code></pre>

<p>}</p>

<p>```</p>

<p>&emsp;&emsp;comet4j客户端已经封装了相应的js，以简化我们的编码，我们需要做的是引入comet4j.js到需要的页面中。</p>

<p>``` jsp chat_login.jsp
&lt;%@ page language=&ldquo;java&rdquo; contentType=&ldquo;text/html; charset=UTF-8&rdquo;</p>

<pre><code>pageEncoding="UTF-8"%&gt;
</code></pre>

<p>&lt;!DOCTYPE html PUBLIC &ldquo;&ndash;//W3C//DTD HTML 4.01 Transitional//EN&rdquo; &ldquo;<a href="http://www.w3.org/TR/html4/loose.dtd">http://www.w3.org/TR/html4/loose.dtd</a>&rdquo;>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Insert title here</title>
<link rel="stylesheet" href="lib/bootstrap/css/bootstrap.min.css"/>
</head>
<body></p>

<pre><code>&lt;p class="text-warning"&gt;假设本系统以用户名作为用户的业务主键。&lt;/p&gt;
&lt;form action="loginChat" method="post"&gt;
    用户名：&lt;input type="text" name="name"/&gt;
    &lt;input type="submit" value="进入聊天室" class="btn btn-success"/&gt;
&lt;/form&gt;
</code></pre>

<p></body>
</html></p>

<p>```</p>

<p>``` jsp chating.jsp</p>

<p>&lt;%@ page language=&ldquo;java&rdquo; contentType=&ldquo;text/html; charset=UTF-8&rdquo;</p>

<pre><code>pageEncoding="UTF-8"%&gt;
</code></pre>

<p>&lt;!DOCTYPE html PUBLIC &ldquo;&ndash;//W3C//DTD HTML 4.01 Transitional//EN&rdquo; &ldquo;<a href="http://www.w3.org/TR/html4/loose.dtd">http://www.w3.org/TR/html4/loose.dtd</a>&rdquo;>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>在线聊天</title></p>

<script type="text/javascript" src="lib/jquery/jquery-1.7.2.min.js"></script>


<p><link rel="stylesheet" href="lib/bootstrap/css/bootstrap.min.css"/></p>

<script type="text/javascript" src="lib/jquery-timer/jquery.timer.js"></script>


<script type="text/javascript" src="lib/comet4j/comet4j.js"></script>




<script type="text/javascript">
    $(function(){
        
        $("#btn_send").click(function() {
            $.ajax({
                url:"sendMsg",
                type:"post",
                data:{msg:$("#msg").val()},
                success:function(){
                    $("#msg").val("");
                }
            });
        });
        
        JS.Engine.on({
            user_chating_content:function(data){//侦听聊天内容
                var result = $.parseJSON(data);
                $("<p><b>"+result.date+"</b></p>").appendTo("#msgs");
                $("<p ><b style='color:red;'>"+result.user+"</b>: "+result.msg+"</p>").appendTo("#msgs");
            },
            onlineUsers: function(data){//侦听在线用户
                    var result = $.parseJSON(data);
                    $("#onlineUsers option").remove();
                    $(result).each(function(){
                        $("<option>" + this.name + ":" + this.state + "</option>").appendTo("#onlineUsers");
                    });
                    
            }
        });
        JS.Engine.start('state');
        
       
       var timer = $.timer(
        function() {
            $.ajax({
                url:"getState",
                type:"get",
                dataType:"json",
                success:function(user) {
                    $("#uid").html(user.clientId);
                    $("#nickName").html(user.name);
                }
            });
        }
        );  
       timer.once(5000);
            
    });
</script>


<p></head>
<body></p>

<div style="background-color: silver;width:650px;">
    当前用户长连接id:<span id="uid"></span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    当前用户昵称  :<span id="nickName"></span>
</div>


<div >
<div id="msgs" style="height: 200px; width:650px; overflow: scroll;"></div>
<select multiple="multiple" id="onlineUsers" style="width: 650px;">
</select>
<br>
<form action="logout">
请输入要发送的消息：<input type="text" id="msg" >
<input type="button" value="    发        送    " id="btn_send" class="btn btn-success btn-large"> 
<input type="submit" value="离开聊天室" class="btn btn-warning btn-large">
</form>
</div>


<p></body>
</html></p>

<p>```</p>

<p>&emsp;&emsp;运行上面的代码，即可进行实时聊天了。我们近期的一个实时监控功能就是基于comet做的。</p>

<p>&emsp;&emsp;最后给大家强调几点：</p>

<ol>
<li>在没有深入研究的情况下，引入任何一项新的技术，都会给项目带来风险，comet也如此。</li>
<li>服务器能够接受的comet长连接并发数有待测试，如果并发过高，将考虑使用其它的解决方案。</li>
<li>comet4j上线、下线等监听器中如果注入了service，在service中查询出的hibernate实体bean,必须要主动加载后面需要用到的lazy对象（原因：和openSessionInView失效有关哦）。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于servlet规范中的几个设计模式解析]]></title>
    <link href="http://yanyaner.com/blog/2014/01/22/servlet-container-pattern/"/>
    <updated>2014-01-22T12:18:00+08:00</updated>
    <id>http://yanyaner.com/blog/2014/01/22/servlet-container-pattern</id>
    <content type="html"><![CDATA[<p>&emsp;&emsp;本文属于入门类型文章，给大家简单介绍一下javax.servlet中用到的几个设计模式。</p>

<h3>先看职责链模式</h3>

<p>&emsp;&emsp;这个模式的应用就是大家所熟悉的filter过滤器,演示代码如下：</p>

<p>``` java  Filter.java
package com.my.filter;</p>

<p>/<em>*
 * 定义每一个处理者的通用行为，即对传入的参数进行处理
 * @author ljh
 *
 </em>/
public interface Filter {</p>

<pre><code>public void doFilter(String param, FilterChain fc);
</code></pre>

<p>}</p>

<p>```</p>

<p>&emsp;&emsp;接下来定义一个职责链接口，以规范形为（当然，这个接口也可以不定义，直接给出实现类即可）。</p>

<p>``` java  FilterChain.java
package com.my.filter;</p>

<p>/<em>*
 * 过滤器链接口定义
 * @author ljh
 *
 </em>/
public interface FilterChain {</p>

<pre><code>/**
 * 将请求传给下一个处理者
 * @param param
 */
public void doFilter(String param);
</code></pre>

<p>}</p>

<p>```</p>

<p>&emsp;&emsp;一个具体的责任链实现（注：这个通常是由服务器去实现的，比如tomcat），里面包含了所有的要承担处理责任的处理者（也就是过滤器）。</p>

<p>``` java ConcreteFilterChain.java
package com.my.server;</p>

<p>import java.util.ArrayList;
import java.util.List;</p>

<p>import com.my.biz.Processor;
import com.my.filter.Filter;
import com.my.filter.FilterChain;
/<em>*
 * 一个职责链具体实现
 * @author ljh
 *
 </em>/
public class ConcreteFilterChain implements FilterChain {</p>

<pre><code>//链集合
private List&lt;Filter&gt; filters = new ArrayList&lt;Filter&gt;();
//初始已处理过滤器下标
private int processIndex = -1;

public ConcreteFilterChain(List&lt;Filter&gt; filters) {
    this.filters = filters;
}

@Override
public void doFilter(String param) {
    //处理的过滤器下标
    processIndex = processIndex + 1;

    if (processIndex &gt;= filters.size()) {
        Processor p = new Processor();
        p.working(param);
    } else {
        filters.get(processIndex).doFilter(param, this);
    }

}

/**
 * 返回一个新的FilterChain（这个方法保留待用）
 * 因为在多线程环境下，每一个请求会有自己的processIndex
 * 这个新建的processIndex将设置为初始值-1，表示还没有进入任何一个过滤器
 * @return
 */
public FilterChain cloneFilterChain() {
    return new ConcreteFilterChain(filters);
}
</code></pre>

<p>}
```</p>

<p>&emsp;&emsp;好了，到这里，服务器上该做的事都已经做完，来看看程序员要做的事吧。<!--more-->我们先写一个业务处理类，模拟最终要进行的操作，如下：</p>

<p>``` java Processor.java
package com.my.biz;</p>

<p>public class Processor {</p>

<pre><code>public void working(String param) {

    System.out.println("最后的业务执行与处理....:" + param);
}
</code></pre>

<p>}
```</p>

<p>&emsp;&emsp;在working处理消息前，我定义了两个过滤器。在第一个过滤器中，进行了参数检测，如果参数是"abc"，将终止后续业务的执行。同时，两个过滤器都对消息进行了处理，在消息中添加了自己的东西。</p>

<p>``` java MyFilter1.java与MyFilter2.java
package com.my.concretefilter;</p>

<p>import com.my.filter.Filter;
import com.my.filter.FilterChain;
/<em>*
 * 第一个过滤器,会对消息进行处理
 * @author ljh
 *
 </em>/
public class MyFilter1 implements Filter {</p>

<pre><code>@Override
public void doFilter(String param, FilterChain fc) {

    System.out.println("进入MyFilter1的处理 ....");
    if ("abc".equals(param)) {
        System.out.println("发现参数是abc，终止执行!!!!");
        return;
    }
    fc.doFilter(param + "[●modify by MyFilter1●]");
    System.out.println("离开MyFilter1的处理 ....");

}
</code></pre>

<p>}</p>

<p>/<em>*
 * 第一个过滤器,会对消息进行处理
 * @author ljh
 *
 </em>/
public class MyFilter2 implements Filter {</p>

<pre><code>@Override
public void doFilter(String param, FilterChain fc) {

    System.out.println("进入MyFilter2的处理 ....");
    fc.doFilter(param + "[★modify by MyFilter2★]");
    System.out.println("离开MyFilter2的处理 ....");

}
</code></pre>

<p>}
```</p>

<p>&emsp;&emsp;接下来又是服务器上的处理代码了，我直接写出简单示例，生产环境中的服务器，肯定是读取web.xml反射创建过滤器对象。</p>

<p>``` java Server.java</p>

<pre><code>    //链集合(读取配置文件，反射创建filter，并加入过滤器链)
    List&lt;Filter&gt; filters = new ArrayList&lt;Filter&gt;();
    filters.add(new MyFilter1());
    filters.add(new MyFilter2());
    FilterChain fc = new ConcreteFilterChain(filters);

    //派发请求
    fc.doFilter("abcd");
</code></pre>

<p>```</p>

<p>&emsp;&emsp;输出的结果是如下，和我们的预期相同。</p>

<p><code>
进入MyFilter1的处理 ....
进入MyFilter2的处理 ....
最后的业务执行与处理....:abcd[●modify by MyFilter1●][★modify by MyFilter2★]
离开MyFilter2的处理 ....
离开MyFilter1的处理 ....
</code></p>

<p>&emsp;&emsp;如果用户的输入参数是abc，即fc.doFilter(&ldquo;abc&rdquo;);，执行输出是：</p>

<p><code>  
进入MyFilter1的处理 ....
发现参数是abc，终止执行!!!!
</code></p>

<p>&emsp;&emsp;这就有点类似于权限检测的filter一样，呵呵。</p>

<h3>另一个是监听器（观察者模式）</h3>

<p>&emsp;&emsp;通过监听器，容器会把我们感兴趣的事告诉我们，当然前提是我们必须先向服务器注册。监听器使用了观察者模式。下面我定义了一个会话监听器。</p>

<p>``` java HttpSessionListener.java</p>

<p>package com.my.listener;
/<em>*
 * 会话监听器
 * @author Administrator
 *
 </em>/
public interface HttpSessionListener {</p>

<pre><code>public void sessionCreated(String  event);
public void sessionDestroyed(String  event);
</code></pre>

<p>}</p>

<p>```</p>

<p>&emsp;&emsp;接下来由程序员定义自己的监听器，并在配置文件中进行配置。</p>

<p>``` java MyHttpSessionListener1.java和MyHttpSessionListener2.java
package com.my.concretelistener;</p>

<p>import com.my.listener.HttpSessionListener;</p>

<p>/<em>*
 * 我的会话监听器1
 * @author Administrator
 *
 </em>/
public class MyHttpSessionListener1 implements HttpSessionListener {</p>

<pre><code>private String myName = "监听器1";

@Override
public void sessionCreated(String event) {

    System.out.println(myName + " 监听到创建事件：" + event);

}

@Override
public void sessionDestroyed(String event) {

    System.out.println(myName + "监听到销毁事件：" + event);

}
</code></pre>

<p>}</p>

<p>/<em>*
 * 我的会话监听器2
 * @author Administrator
 *
 </em>/
public class MyHttpSessionListener2 implements HttpSessionListener {</p>

<pre><code>private String myName = "监听器2";

@Override
public void sessionCreated(String event) {

    System.out.println(myName + " 监听到创建事件：" + event);

}

@Override
public void sessionDestroyed(String event) {

    System.out.println(myName + "监听到销毁事件：" + event);

}
</code></pre>

<p>}</p>

<p>```</p>

<p>&emsp;&emsp;服务器上的处理代码如下：</p>

<p>``` java Server.java</p>

<pre><code>    //监听器对队
    HttpSessionListener[] listeners = new HttpSessionListener[2];
    listeners[0] = new MyHttpSessionListener1();
    listeners[1] = new MyHttpSessionListener2();

    //当容器中发生事件的时候，进行通知
    //比如：创建事件
    System.out.println("服务器发生创建事件！");
    for (HttpSessionListener listener : listeners) {
        listener.sessionCreated(new Date() + "创建事件发生了！" );
    }
</code></pre>

<p>```</p>

<p>&emsp;&emsp;下面就是运行的结果，我们可以发现，这就是一个观察者模式的标准应用。</p>

<p>```</p>

<p>服务器发生创建事件！
监听器1 监听到创建事件：Thu Jan 23 15:34:14 CST 2014创建事件发生了！
监听器2 监听到创建事件：Thu Jan 23 15:34:14 CST 2014创建事件发生了！</p>

<p>```</p>

<h3>最后，给大家说一下包装器</h3>

<p>&emsp;&emsp;包装器，也叫装饰器，这个模式的本意是在不改变原有类的情况下，增强类的功能（包括添加行为或添加状态）。</p>

<p>``` java  Request.java</p>

<p>package com.my.wrapper;
/<em>*
 * 抽象请求对象
 * @author ljh
 *
 </em>/
public interface Request {</p>

<pre><code>//得到内容
public String getContent();
</code></pre>

<p>}</p>

<p>```</p>

<p>``` java OriginalRequest.java</p>

<p>package com.my.wrapper;</p>

<p>/<em>*
 * 原始请求
 * @author ljh
 *
 </em>/
public class OriginalRequest implements Request {</p>

<pre><code>private String content;

public OriginalRequest(String content) {
    this.content = content;
}

@Override
public String getContent() {
    // TODO Auto-generated method stub
    return content;
}
</code></pre>

<p>}</p>

<p>```</p>

<p>``` java RequestWrapper.java</p>

<p>package com.my.wrapper;</p>

<p>/<em>*
 * 包装对象，其它的包装类，都从这个类继承
 * @author ljh
 *
 </em>/
public class RequestWrapper implements Request {</p>

<pre><code>private Request request;



public RequestWrapper(Request request) {
    super();
    this.request = request;
}



@Override
public String getContent() {
    //此处暂时不做任何处理，直接返回
    String content = request.getContent();
    return content;
}
</code></pre>

<p>}</p>

<p>```</p>

<p>&emsp;&emsp;上面三个类，都是由服务器端已经定义好的（也就是先把基本的架子搭起来）。下面这个方法才是我最终要执行的一个目标业务方法。</p>

<p>``` java</p>

<pre><code>/**
 * 此访求接收request接口类型，并感知不到对象已被包装
 * @param req
 */
public static void display(Request req) {
    System.out.println(req.getContent());
}
</code></pre>

<p>```</p>

<p>&emsp;&emsp;接下来，大家看看我实现了一个对敏感关键词进行处理的包装器：</p>

<p>``` java MyRequestWrapper.java</p>

<p>package com.my.concretewrapper;</p>

<p>import com.my.wrapper.Request;
import com.my.wrapper.RequestWrapper;</p>

<p>public class MyRequestWrapper extends RequestWrapper {</p>

<pre><code>public MyRequestWrapper(Request request) {
    super(request);
}

//添加行为或改变现在行为，或新的属性

//比如：我下面进行敏感字符过滤
@Override
public String getContent() {
    String content = super.getContent();
    content = content.replaceAll("江泽民", "***");
    return content;
}
</code></pre>

<p>}</p>

<p>```</p>

<p>&emsp;&emsp;最后是对目标方法的调用了，输入结果是：我是国家主席***。</p>

<p>```</p>

<pre><code>    Request req = new MyRequestWrapper(new OriginalRequest("我是国家主席江泽民"));
    //目标方法的调用
    display(req);
</code></pre>

<p>```</p>

<p>&emsp;&emsp;好，此篇文章就到此吧，2014春节马上就到了，假期临近，一切都显示得非常冷清，很多人已经心不在焉。</p>
]]></content>
  </entry>
  
</feed>
