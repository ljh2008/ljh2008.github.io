<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[☺分类☺：javaEE | 刘江华的博客]]></title>
  <link href="http://yanyaner.com/blog/categories/javaee/atom.xml" rel="self"/>
  <link href="http://yanyaner.com/"/>
  <updated>2014-04-15T15:21:23+08:00</updated>
  <id>http://yanyaner.com/</id>
  <author>
    <name><![CDATA[冰雨]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[java安全那些事之三（RSA及https）]]></title>
    <link href="http://yanyaner.com/blog/2014/04/15/security3/"/>
    <updated>2014-04-15T15:18:00+08:00</updated>
    <id>http://yanyaner.com/blog/2014/04/15/security3</id>
    <content type="html"><![CDATA[<p>&emsp;&emsp;大家也许看到过有些网站的登录功能都使用的是hppts协议开头的网址，这个https就使用了RSA加密算法，可以有效保护敏感信息在传输过程中的安全性（即使被截获也无法破解）。</p>

<p>&emsp;&emsp;RSA算法属于不对称加密算法，信息发送方和接收方使用不同的密钥（即公钥私钥对）进行通讯，其中的公钥是可以对外公开的，私钥必须保密。信息发送方用公钥对信息进行加密，而信息接收方对信息的解密必须使用私钥，除此别无它法。反之，用私钥加密的信息也只能用公钥才能解密，因此，RSA算法不仅可以用作加密解决方案，也可以做为双方通讯过程中不可抵赖的凭证。示意图见下：</p>

<p><span class='caption-wrapper'><img class='caption' src='/uploads/2014/04/rsa.jpg' width='' height='' title='RSA加密解密示意图'><span class='caption-text'>RSA加密解密示意图</span></span></p>

<p>&emsp;&emsp;在进行RSA加密解密之前，首先要生成公钥和私钥对。</p>

<p>&emsp;&emsp;我先给大家介绍一种基于JKS（也就是java keystore）的公钥私钥保存方式，我们用下面的命令是生成一个别名是mykey.mm的test.keystore文件，打开keystore文件的密码我输入的是123456。</p>

<p>```
C:\key>keytool -genkey -alias mykey.mm -keyalg RSA -keystore test.keystore
输入keystore密码：
Keystore 密码太短 -至少必须为6个字符
输入keystore密码：
再次输入新密码:
您的名字与姓氏是什么？
  <a href="sc">Unknown</a>：  liu
您的组织单位名称是什么？
  <a href="sc">Unknown</a>：  maxsoft
您的组织名称是什么？
  <a href="sc">Unknown</a>：  maxsoft.com
您所在的城市或区域名称是什么？
  <a href="sc">Unknown</a>：  cd
您所在的州或省份名称是什么？
  <a href="sc">Unknown</a>：  sc
该单位的两字母国家代码是什么
  <a href="sc">Unknown</a>：  cn
CN=liu, OU=maxsoft, O=maxsoft.com, L=cd, ST=sc, C=cn 正确吗？
  <a href="y">否</a>：  y</p>

<p>输入&lt;my.yy>的主密码</p>

<pre><code>    （如果和 keystore 密码相同，按回车）：
</code></pre>

<p>C:\key>
```</p>

<p>&emsp;&emsp;上面的命令会在c:\key下生成一个test.keystore文件，这个文件中包含了公钥和私钥，java中使用test.keystore文件并进行加密解密的调用代码写法如下：</p>

<p>``` java
public static void main(String[] args) throws Exception {</p>

<pre><code>    String alias = "mykey.mm";
    String password = "123456";

    KeyStore store = KeyStore.getInstance("JKS");
    store.load(new FileInputStream("c://key//test.keystore"), password.toCharArray());

    //得到公钥
    PublicKey publickey =  store.getCertificate(alias).getPublicKey();

    //得到私钥
    PrivateKey privateKey = (PrivateKey)store.getKey(alias, password.toCharArray());

    String orgStr = "言娃娃yanyaner.com";

    //加密处理
    Cipher cipherEncoder = Cipher.getInstance("RSA");
    cipherEncoder.init(Cipher.ENCRYPT_MODE, publickey);
    //加密字串结果
    byte[] strEnc = cipherEncoder.doFinal(orgStr.getBytes());
    System.out.println("RSA加密后的内容是：\r\n" + Base64.encode(strEnc));


    //解密处理
    Cipher cipherDecoder = Cipher.getInstance("RSA");
    cipherDecoder.init(Cipher.DECRYPT_MODE, privateKey);
    byte[] orgDec = cipherDecoder.doFinal(strEnc);
    System.out.println("RSA解密后的内容是：\r\n" + new String(orgDec));
</code></pre>

<p>```</p>

<p>&emsp;&emsp;加密过程用到了公钥，而解密用到了私钥。反之亦然，即加密用私钥，解密用公钥。代码输出的结果是：</p>

<p><code>
RSA加密后的内容是：
Mow+hRU2V8rt6lRjT1ydb7Lmdwmb1QeelDRxVh0O8kb6FZXWfs6fVuNMMDn8G7w5gA4mnheM+A/z
OUaU83q1bsXWFni3p+ER9oOy/Wx0rwHGKIYxvqTyrYJgOVnpNrwwa5b2GljWVKdlai3BPgxzY+kk
Oj2IsLcU9OyXmr5cqYdLlC47Vtb++CUGg+6X071cArTw90KYZk2TYSdawvS3BbgzFcA/BHz36vsK
4Q7sjsHY2SG4ITiq8pAM3pXYHLbTvUH4SLBdJTMry1kEGqvgJA3dy63Ut+Rl43hZ+XJZICPPAvSo
xD3Euo/5bhyO1Y8Jbdrj7C4eHADMZ+Zpn7RfGA==
RSA解密后的内容是：
言娃娃yanyaner.com
</code></p>

<p>&emsp;&emsp;接下来，我们使用另外一种公钥私钥保存的方式，我们通过openssl这种使用更为广泛的基于RSA的工具生成加密公钥私钥对。<!-- more--></p>

<p>&emsp;&emsp;在windows下通过openssl来生成私钥，请在cmd中输入下面的命令，这个命令会生成私钥文件rsa_private.key，我们可以指定文件名：</p>

<p><code>
D:\temp\openssl&gt;openssl genrsa -out rsa_private.key 1024
Generating RSA private key, 1024 bit long modulus
....++++++
........++++++
unable to write 'random state'
e is 65537 (0x10001)
</code></p>

<p>&emsp;&emsp;接下来再根据私钥来生成公钥文件rsa_public.key，如下命令：</p>

<p><code>
D:\temp\openssl&gt;openssl rsa -in  rsa_private.key -out rsa_public.key -pubout
writing RSA key
</code></p>

<p>&emsp;&emsp;通过上面的命令，我们就生成了公钥和私钥文件，这时候的私钥还不能直接被java使用，接下来需要对rsa_private.key私钥文件进行PKCS#8编码，如下命令：</p>

<p><code>
D:\temp\openssl&gt;openssl pkcs8 -topk8 -in rsa_private.key -out pkcs8_rsa_private.key -nocrypt
</code></p>

<p>&emsp;&emsp;通过上面三个命令，我们在d:\temp目录下会存在三个文件，如下图：</p>

<p><span class='caption-wrapper'><img class='caption' src='/uploads/2014/04/ppkey_files.jpg' width='' height='' title='RSA密钥文件'><span class='caption-text'>RSA密钥文件</span></span></p>

<p>&emsp;&emsp;好了，可以写java代码了。</p>

<p>``` java
/**</p>

<pre><code> * 得到公钥对象
 * @param publicKeyFile
 * @return
 * @throws Exception
 */
public static RSAPublicKey getRSAPublicKey(String publicKeyFile) throws Exception {
    X509EncodedKeySpec keySpec= new X509EncodedKeySpec(readKeysAsByteArray(publicKeyFile));  
    KeyFactory keyFactory= KeyFactory.getInstance("RSA");  
    return (RSAPublicKey) keyFactory.generatePublic(keySpec);  
}

/**
 * 得到私钥对象
 * @param priveKeyFile
 * @return
 * @throws Exception
 */
public static RSAPrivateKey getRSAPrivateKey(String priveKeyFile) throws Exception {
    PKCS8EncodedKeySpec keySpec= new PKCS8EncodedKeySpec(readKeysAsByteArray(priveKeyFile));  
    KeyFactory keyFactory= KeyFactory.getInstance("RSA");  
    return  (RSAPrivateKey) keyFactory.generatePrivate(keySpec); 
}


/**
 * 读取密钥文件为byte数组
 * @param fileName
 * @return
 * @throws Exception
 */
public static byte[] readKeysAsByteArray(String fileName) throws Exception {

    BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(fileName)));

    String line = "";
    StringBuilder sb = new StringBuilder();
    while ((line = reader.readLine()) != null) {
        if ( ! line.startsWith("-----")) {
            sb.append(line).append("\r");
        } 
    }

    BASE64Decoder base64Decoder= new BASE64Decoder();

    return  base64Decoder.decodeBuffer(sb.toString());
}
</code></pre>

<p>```</p>

<p>&emsp;&emsp;需要解释的是，上面代码中的readKeysAsByteArray方法，是用来读取key文件的，因为key文件中的多余行我们要去掉，比如，下面就是一个私钥文件内容，文件头和尾都有多余的信息：</p>

<p>```</p>

<p>&mdash;&mdash;-BEGIN PRIVATE KEY&mdash;&mdash;&ndash;
MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBANmxTOBVBVrl25Ge
sCD3b57dxK7LLK2RiSrBvdoaBK/g5mVV5RggG3GI8cCC4gDv2oGWNdwbNJiGZreZ
Knm4G0y5Pq86tuJO6vmYKrD0cEZlp0uh9b2cAeP3ry+87VwpIFnpaiXCzB6xhEb1
2FvP8hbs/K7iHkLbysUB7F/XUbRPAgMBAAECgYEAj84lB6iCghqH4nlexlhOXzcG
v6Ut3XbfkuQrY1F+uSSrblPApCBJoMWjVdXgMFhCEwrEh6NdKkjWwAApZADv3pXj
m/LXQYwRaKExJtTdl38ujSfL/tN5vSaMqmnnDa6IMc0AfjjWHDuX5Jurqi47l8Rh
yF4gSvXTfsAwD8ZT6XECQQD3I8orEj4fAAIKF4KvmHREl9yVKr+iqaT7q4q5C94i
Gs/RyN421NiR9ns5+R3ooJ+mBufMsUTLQFvPgmcB+VfXAkEA4X8/owQ50xlB3lSC
dHotY4rE7N3gCeLxN+FpzxK+6lZjelxjsQ0wFKMrvLjQFZWcDrLcCOFE3ldCJGOS
+3CYSQJALnR0yRnZwXv/5iO7NgSjPk2JciSh9xKKZ6A8KEJ509FUZSur0YS63N0H
FsOkAplGyS+dHNXph4cmeuAZOr7C6wJBAIC5x3Yj326mqHdm/uHHLUn52djuAAsk
xlcEEwbmyJ21mywqua5EvQHK9BjT19W6hk/NwtY+4rWaUmO7hBiNeiECQDhAAYha
huZwqLVB/UUMdqxJreEee5q+SyaAn+aHLWCq0vYQ9DEU72vAhvgnQQ0oTLPkQ5od
NBCD4J/2OGQOIH8=
&mdash;&mdash;-END PRIVATE KEY&mdash;&mdash;&ndash;</p>

<p>```</p>

<p>&emsp;&emsp;信息发送方、接收方的代码，大家可以参照下面的示例代码写出：</p>

<p>``` java
public static void main(String[] args) throws Exception {</p>

<pre><code>    RSAPublicKey publickey = getRSAPublicKey("D:/temp/openssl/rsa_public.key");
    RSAPrivateKey privateKey = getRSAPrivateKey("D:/temp/openssl/pkcs8_rsa_private.key");

    String orgStr = "言娃娃-yanyaner.com";

    //加密处理
    Cipher cipherEncoder = Cipher.getInstance("RSA");
    cipherEncoder.init(Cipher.ENCRYPT_MODE, publickey);

    //加密字串结果
    byte[] strEnc = cipherEncoder.doFinal(orgStr.getBytes());

    System.out.println("加密后的内容是：\r\n" + Base64.encode(strEnc));


    //解密处理
    Cipher cipherDecoder = Cipher.getInstance("RSA");
    cipherDecoder.init(Cipher.DECRYPT_MODE, privateKey);

    byte[] orgDec = cipherDecoder.doFinal(strEnc);
    System.out.println("解密后的内容是：\r\n" + new String(orgDec));

}
</code></pre>

<p>```</p>

<p>&emsp;&emsp;最终输出结果是：</p>

<p>```</p>

<p>加密后的内容是：
dzxXcllos3pROKeWGShl3uu0KQdRrJiYHhUGqcHT6DkPRW71cYFITj0XlwkIjaWGw8CyJbc5r/AR
qwtuVFN/IybI/kUdfuAVrmDuIVn86rlkAEVbZTel8WOoUlRmlyflhbYUk0SeflcKdFgVELk5WVZ+
J/DGn1kJ23KcIXbC1YM=</p>

<p>解密后的内容是：
言娃娃-yanyaner.com</p>

<p>```</p>

<p>&emsp;&emsp;通过阅读上面的调用代码，我想大家对RSA加密算法已经有了一些认识，在这些代码中我们发现，RSA的私钥的存放必须要得到很好的保护，如果私钥被他人得到，那么双方的通讯的内容也就公开了。</p>

<p>&emsp;&emsp;最后，我给大家简单介绍一下tomcat中的基于RSA的https配置内容。配置tomcat的https支持hppts，首先也是要建立RSA证书，同样是基于JKS的，如下命令即可：</p>

<p>```
D:\temp\tomcat-cer>keytool -genkey -alias mytomcat -keyalg RSA -keystore tomcat.keystore
输入密钥库口令:
再次输入新口令:
您的名字与姓氏是什么?
您的组织单位名称是什么?
您的组织名称是什么?
您所在的城市或区域名称是什么?
您所在的省/市/自治区名称是什么?
该单位的双字母国家/地区代码是什么?
CN=liu, OU=maxsoft, O=org, L=cd, ST=sc, C=cn是否正确?
输入 <mytomcat> 的密钥口令</p>

<pre><code>    (如果和密钥库口令相同, 按回车):
</code></pre>

<p>```</p>

<p>&emsp;&emsp;接下来修改tomcat 的 server.xml中Connector部分的配置：</p>

<p>``` xml server.xml
&lt;Connector protocol=&ldquo;org.apache.coyote.http11.Http11Protocol&rdquo;</p>

<pre><code>           port="8443"  SSLEnabled="true"
           maxThreads="150" scheme="https" secure="true"
           clientAuth="false" sslProtocol="TLS" 
           keystoreFile="D:/temp/tomcat-cer/tomcat.keystore"
           keystorePass="123456"
           /&gt;
</code></pre>

<p>```</p>

<p>&emsp;&emsp;要注意的是，我将文件中的protocol由protocol=&ldquo;HTTP/1.1&rdquo; 改为了protocol=&ldquo;org.apache.coyote.http11.Http11Protocol"，因为我的tomcat6是6.0.36，会报No Certificate file specified or invalid file format错误，高版本的tomcat默认AprLifecycleListener是高为on的，你在配置文件中可以看到这个开关SSLEngine="on&rdquo; ，只有修改后才可以正确运行。</p>

<p>&emsp;&emsp;进入浏览器访问你的项目，会发现https已经生效。</p>

<p><span class='caption-wrapper'><img class='caption' src='/uploads/2014/04/browser_ssl_warning.jpg' width='' height='' title='浏览器中https警告'><span class='caption-text'>浏览器中https警告</span></span></p>

<p>&emsp;&emsp;如果你不想让浏览器出现这样的警告，那么你就得到第三方认证的证书机构去申请密钥了，而不能像上面一样通过命令行自己生成密钥，因为我们生成的密钥浏览器认为有风险而不被信任(当然如果用户通过添加例外，浏览器仍然可以继续访问这个https的网站)。</p>

<p>&emsp;&emsp;关于RSA的介绍先到此，下篇文章接着讲一些架构级的安全认证设计知识，请大家关注。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[java安全那些事之二（base64,des）]]></title>
    <link href="http://yanyaner.com/blog/2014/04/14/security2/"/>
    <updated>2014-04-14T15:18:00+08:00</updated>
    <id>http://yanyaner.com/blog/2014/04/14/security2</id>
    <content type="html"><![CDATA[<p>&emsp;&emsp;和Hash的不可逆相比，还有一些算法是可逆的，也就是数据在发送方经过加密后，再传输至接收方，接收方对收到的信息后进行解密得到明文。</p>

<p>&emsp;&emsp;我们先来看可逆算法中最简单的一种：Base64，请先看代码。</p>

<p><code>java
String b64result = new String(Base64.encodeBase64("刘江华".getBytes()));
System.out.println("base64加密后密文是：" + b64result);
String orgStr = new String(Base64.decodeBase64(b64result.getBytes()));
System.out.println("base64解密为明文是：" + orgStr);
</code></p>

<p>&emsp;&emsp;上面代码的输出是：</p>

<p><code>
base64加密后密文是：5YiY5rGf5Y2O
base64解密为明文是：刘江华
</code></p>

<p>&emsp;&emsp;由此可见，base64加密算法会把明文加密后变成我们看不明白的密文，但我们也可以通过base64算法很快解密得到明文，这也就是说，如果信息在传输过程中被第三方截获，对方又知道你采用的是base64算法，那么你的密文也就无秘密可言。</p>

<p>&emsp;&emsp;既然如此，是不是说base64就完全无用了呢？当然不是！如果我们仔细观察会发现，该算法输出的内容都是数字和字母之类的ascii可显示字符，而无论你的输入是中文还是特殊字符。这一特点对于信息传输过程中，明文中包含特殊字符而可能产生乱码的情况非常有用。比如：对要传输的内容进行base64编码，再通过http协议传输到接收方，接收方再按base64解码得到明文。base64还有其它的一些用处，比方说将byte[] 转换为可显示字符等等，我不再多说。base64运行示意图如下：</p>

<p><span class='caption-wrapper'><img class='caption' src='/uploads/2014/04/base64.jpg' width='' height='' title='base64加密解密示意图'><span class='caption-text'>base64加密解密示意图</span></span></p>

<p>&emsp;&emsp;接下来，我们再来看看另外一种加密强度更好的方法：DES加密算法。DES属于对称加密算法，信息发送者通过一个私钥来加密信息后再传输，而信息接收者也使用同样的一个私钥完成信息的解密。</p>

<p><span class='caption-wrapper'><img class='caption' src='/uploads/2014/04/des.jpg' width='' height='' title='des加密解密示意图'><span class='caption-text'>des加密解密示意图</span></span></p>

<p>&emsp;&emsp;之所以称DES为对称加密算法，主要原因是信息发送方和信息接收方使用的是相同的密钥，上图中的private key就是。代码写出来就是下面这样的：<!-- more--></p>

<p>``` java</p>

<pre><code>/**
 * des加密示例代码
 * @param orgData
 * @param privateKey
 * @return
 * @throws Exception
 */
public static byte[] desEncode(byte[] orgData, String privateKey) throws Exception {

    KeyGenerator kgenerator = KeyGenerator.getInstance("DES");
    kgenerator.init(new SecureRandom(privateKey.getBytes()));

    Cipher cipher = Cipher.getInstance("DES");
    cipher.init(Cipher.ENCRYPT_MODE, kgenerator.generateKey());

    return cipher.doFinal(orgData);
}

/**
 * des解密示例代码
 * @param passedData
 * @param privateKey
 * @return
 * @throws Exception
 */
public static byte[] desDecode(byte[] passedData, String privateKey) throws Exception {

    KeyGenerator kgenerator = KeyGenerator.getInstance("DES");
    kgenerator.init(new SecureRandom(privateKey.getBytes()));

    Cipher cipher = Cipher.getInstance("DES");
    cipher.init(Cipher.DECRYPT_MODE, kgenerator.generateKey());

    return cipher.doFinal(passedData);
}
</code></pre>

<p>```</p>

<p>&emsp;&emsp;上面的加密和解密方法中，均传入了一个desPrivateKey，这个key是两方共用的，调用示例代码如下，其中的desPrivateKey是随机生成的一个私钥，两方共同持有。</p>

<p>``` java</p>

<pre><code>    String orgStr = "hello,刘江华";

    String desPrivateKey = "3c9909afec25354d551dae21590bb26e3";

    byte[] en_bytes = desEncode(orgStr.getBytes(), desPrivateKey);

    System.out.println("DES加密后的内容是：" + new BASE64Encoder().encode(en_bytes));

    byte[] de_bytes = desDecode(en_bytes, desPrivateKey);
    System.out.println("DES解密后的内容是：" + new String(de_bytes));
</code></pre>

<p>```</p>

<p>&emsp;&emsp;代码执行后的输出如下：</p>

<p><code>
DES加密后的内容是：VExT39v/M504pQY/L+d84w==
DES解密后的内容是：hello,刘江华
</code></p>

<p>&emsp;&emsp;由此我们可以得出结论，DES算法的关键在于私钥的安全保管，如果信息发送方和接收方中的任何一个泄露了私钥，双方的通讯过程也就无法保密了，因此，密钥的保密是一个关键。</p>

<p>&emsp;&emsp;下一篇文章，我继续给大家讲解RSA算法及其应用，RSA这是一种非对称加密算法，请大家随时关注我的博客。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[java安全那些事之一(md5、sha)]]></title>
    <link href="http://yanyaner.com/blog/2014/04/13/security1/"/>
    <updated>2014-04-13T15:18:00+08:00</updated>
    <id>http://yanyaner.com/blog/2014/04/13/security1</id>
    <content type="html"><![CDATA[<p>&emsp;&emsp;安全攻防的世界，永远是道高一尺魔高一丈的世界，再强的安全防护在FBI面前几乎无密码可言，如果你去看看美国的楞镜门事件相关新闻就知道了。我并不是安全密码方面的专家，本文不想研究算法，只是从应用角度给大家普及些许web应用系统中安全相关的一些知识，希望对大家开发普通的企业级应用及互联网应用有帮助。</p>

<p>&emsp;&emsp;先来看看加密及解密。</p>

<p>&emsp;&emsp;登录是任何一个系统都有的功能，在登录的过程中需要对用户提供的密码进行验证以检测其身份合法性，这点对于我们应用开发者而言，就是如何持久化用户的密码。如果仅仅以明文方式将用户密码保存在数据库中，那未免有些太“瓜西西”了，这就像CSDN所犯错一样低级。因此，我们一定要对用户密码进行相应的处理后再保存，即使被黑客拖库也可以防止用户密码的泄露。</p>

<p>&emsp;&emsp;Hash是常用的方法。Hash一般翻译为"散列"或直接音译为"哈希"，就是把任意长度的输入变换成固定长度的散列输出。这种转换是一种压缩映射，也就是散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，而不可能从散列值来唯一的确定输入值，简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要。</p>

<p>&emsp;&emsp;Hash常用的算法有md5、sha等，比如下面的代码：</p>

<p>``` java
System.out.println(DigestUtils.md5Hex(&ldquo;ljh&rdquo;));
System.out.println(DigestUtils.sha256Hex(&ldquo;ljh&rdquo;));
System.out.println(DigestUtils.sha384Hex(&ldquo;ljh&rdquo;));
System.out.println(DigestUtils.sha512Hex(&ldquo;ljh&rdquo;));</p>

<p><code>
&amp;emsp;&amp;emsp;大家要注意上面这4行代码的输出结果长度分别是：32，64，96，128位长，如何你决定采用其中的一种hash来处理用户密码的消息接要并持久化，一定要注意数据库字段的长度设定哦。
</code>
67f87c9b32834504b4ddf432055d88bd
871ca93f9e215997cc2d65b4a6924c706b69b09c4d419f89c24746d3ae04727b
d24d011e9d67511deea2f1296adaa65db2c161f8537ed48d5893c06d712abdf4a229c98f8d0fd2776fd8119248949a72
1def79cd9d613a9ceefa285902cd1eb2397b176fd16a09525f52947518c196e8e3349d017182b12726e6a74a0f553af2b6991034f0a9361671176c5f96c5a21b5YiY5rGf5Y2O
```</p>

<!-- more-->


<p>&emsp;&emsp;上面我用到了MD5与SHA1 Hash算法，这两种算法的区别在于：MD5比SHA1运算速度快，但SHA1比MD5强度高，其中，hash输出结果长度越长代表保密强度越好。Hash算法理论上是不可逆的，这意味着你不可能通过hash值反向计算出原始信息，因此，如果你的数据库中保存的是用户密码的hash值，将无人能够知道用户的原始密码是什么了，就好比你的银行密码遗忘了，只有带有效证件去银行重新设置密码，而老的密码将夫人知晓，包括DBA、开发人员。</p>

<p>&emsp;&emsp;那么，对于程序员来说，如何通过用户输入的密码来验证用户的身份呢？非常简单，基本流程是：得到用户输入的用户名及密码&mdash;>对输入的密码进行hash运算&mdash;>根据用户名到数据库中查询出这个用户&mdash;>取得数据库中保存的用户曾经的密码hash值&mdash;>比对两个hash值得出结论。</p>

<p>&emsp;&emsp;既然Hash加密密码有这么多的好处，那Hash保存密码真的可以高枕无忧了么？非也。hash是可以进行暴力破解的（虽然代价非常大的，一般情况下不会采用，但也不能排除），现在比较流行的做法是反向hash查询，就是预先在一张巨大的表中保存事先计算出来的hash值，通过询这个表就可以得到明文了。因此，如果用户的密码足够简单而常见，通过一次hash计算出来的结果几乎无秘密可言。另外，你也可以到网上了解一下“彩虹表”RainbowCrack相关的内容<a href="http://my.oschina.net/jgy/blog/38252">彩虹表-破解哈希算法 MD5加密法</a>，以空间换时间。</p>

<p>&emsp;&emsp;既然一次hash计算出来的保密性不好，那就多计算几次效果如何？比如：md5(md5(pwd))，答案是,这样的计算结果也是不安全，互联网上已经有多次hash计算结果的查询（有的是要收费的）。</p>

<p>&emsp;&emsp;其中，最好的一种办法是，加“随机盐”，也就是为每个用户保存一个足够长的随机字符串，使用这个salt参与计算，再进行多次hash计算。比如：md5(md5(pwd + salt))，这种做法相对来说就安全多了。在具体的项目中，你可以再改进一下这个算法，增加些复杂性（比如:md5(username.hashcode() + sha384Hex(salt + md5(pwd + slat)))），并且，程序在生成每个用户的salt时，要足够随机、足够长，这种方式对付hash反向查询就十分有效了。</p>

<p>&emsp;&emsp;hash算法除了用于密码的安全性外，还经常用于数据签名，这一块的应用我在随后的文章中会提到。</p>

<p>&emsp;&emsp;好了，这一部分先简单介绍到这，下一篇我们来看看Base64,DES,RSA等与加密解决信息有关的内容。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[监控系统中的异步消息使用实例（二）]]></title>
    <link href="http://yanyaner.com/blog/2014/04/09/async_message_architect2/"/>
    <updated>2014-04-09T12:18:00+08:00</updated>
    <id>http://yanyaner.com/blog/2014/04/09/async_message_architect2</id>
    <content type="html"><![CDATA[<p>&emsp;&emsp;接上节，再次贴出架构图，我们接下来要讲的是图中黄色部分的配置。</p>

<p><span class='caption-wrapper'><img class='caption' src='/uploads/2014/04/monitor_jms1.jpg' width='' height='' title='业务方法监控架构'><span class='caption-text'>业务方法监控架构</span></span></p>

<p>&emsp;&emsp;先将spy程序导成一个jar包，加入到需要监控的目标服务器lib目录，monitor_spy.jar结构如下所示：</p>

<p><span class='caption-wrapper'><img class='caption' src='/uploads/2014/04/jarinfo.jpg' width='' height='' title='monitor_spy.jar结构'><span class='caption-text'>monitor_spy.jar结构</span></span></p>

<p>&emsp;&emsp;为了能够实现对目标系统业务方法执行情况进行监控，需要将我们已经写好的拦截器配置到目标系统中去，下面是我的一个配置示例：</p>

<p>``` xml spring-spy.xml</p>

<pre><code>&lt;!-- jms连接工厂 --&gt;         
&lt;bean id="jmsFactory" class="org.apache.activemq.pool.PooledConnectionFactoryBean"&gt;
    &lt;property name="connectionFactory"&gt;
        &lt;bean class="org.apache.activemq.ActiveMQConnectionFactory"&gt;
            &lt;property name="brokerURL" value="tcp://localhost:61616"&gt;&lt;/property&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
    &lt;!-- 配置池中最大连接数据以及最大活动连接数 --&gt;
    &lt;property name="maxConnections" value="100"&gt;&lt;/property&gt;
    &lt;property name="maximumActive" value="100"&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;!-- jms模板方法 --&gt;    
&lt;bean id="jmsTemplate" class="org.springframework.jms.core.JmsTemplate"&gt;
    &lt;constructor-arg ref="jmsFactory"&gt;
    &lt;/constructor-arg&gt;
    &lt;!-- 默认会创建queue类型的目标
    &lt;property name="defaultDestinationName" value="queue/methodSpyLogger"&gt;&lt;/property&gt; --&gt;
    &lt;property name="defaultDestination" ref="destinationQueue1"&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;!-- 发送消息的目的地 --&gt;
&lt;bean id="destinationQueue1" class="org.apache.activemq.command.ActiveMQQueue"&gt;
    &lt;!-- 设置消息队列的名字 --&gt;
    &lt;constructor-arg  value="queue/methodSpyLogger" /&gt;
&lt;/bean&gt;


&lt;!-- 配置Spring和方法相关的监控 --&gt;
&lt;bean id="method-pointcut" class="org.springframework.aop.support.JdkRegexpMethodPointcut"&gt;
    &lt;property name="patterns"&gt;
        &lt;list&gt;
            &lt;value&gt;com.lovo.mis.xjgl.service.impl.*&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;!-- 方法AOP拦截器 --&gt;
&lt;bean id="spy-method-interceptor"
      class="com.monitor.client.spy.SpyMethodIntercepter"&gt;
      &lt;property name="messageDao"&gt;
        &lt;bean class="com.monitor.client.dao.JMSMessageDaoImpl"&gt;
            &lt;property name="jmsTemplate" ref="jmsTemplate"&gt;&lt;/property&gt;
        &lt;/bean&gt;
      &lt;/property&gt;
      &lt;property name="userNameSessionKey" value="loginUserName"&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;!-- 将切面应用到通知上 --&gt;
&lt;aop:config proxy-target-class="true"&gt;
    &lt;aop:advisor advice-ref="spy-method-interceptor"
                 pointcut-ref="method-pointcut" /&gt;
&lt;/aop:config&gt;
</code></pre>

<p>```</p>

<p>&emsp;&emsp;配置文件中有几个地方需要进行说明：<!-- more --></p>

<p>&emsp;&emsp;1、目标机器要修改的部分是JdkRegexpMethodPointcut中的patterns，由patterns指定需要监控的业务类所在的位置。</p>

<p>&emsp;&emsp;2、jmsFactory部分配置你的异步消息服务器连接信息，比如brokerURL等。</p>

<p>&emsp;&emsp;3、jmsTemplate中，通过defaultDestination指定一个Destination，因为一个消息服务器上存在多个Destination。也可以通过defaultDestinationName直接指定消息Destination的名称，系统默认创建的是queue，也就是说，如果你要使用topic类型的消息，就必须通过defaultDestination指定一个Destination。</p>

<p>&emsp;&emsp;4、messageDao可自由替换为其它实现类，比如你可以写一个mongoDB版本的实现以提供更好的性性，支持更大数据量。</p>

<p>&emsp;&emsp;最后来看看消费者代码，是直接使用ActiveMQ驱动实现的。</p>

<p>``` java</p>

<pre><code>    ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory("tcp://localhost:61616");

    Connection connection = factory.createConnection();

    //尝试真正建立连接，这里可以catch Exception
    connection.start();

    //得到一个会话，只有得到会话后，才可进行后续的操作
    Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);

    //创建一个目标队列
    Destination queue = session.createQueue("queue/methodSpyLogger"); 

    MessageConsumer consumer = session.createConsumer(queue);

    //可通过其它一些机制，来改变flag为false，以退出处理
    boolean flag = true;

    while (flag) {
        ObjectMessage msg = (ObjectMessage)consumer.receive();
        MethodLoggerMessage myMsg = (MethodLoggerMessage)msg.getObject();

        System.out.println(myMsg);
        //这里，可调用dao或service，向关系数据库(或nosql)中保存msg中的内容");

    }

    session.close();

    connection.close();
</code></pre>

<p>```</p>

<p>&emsp;&emsp;注意，如果队列中已经没有消息了，代码中的consumer.receive()会阻塞，直到有新的消息后再处理。我们也可以采用监听器的方式来处理消息服务器中的消息，比如下面的代码：</p>

<p>``` java</p>

<pre><code>    //处理消息者
    MessageConsumer consumer = session.createConsumer(queue);

    //处理多条消息
    consumer.setMessageListener(new MessageListener() {
        public void onMessage(Message msg) {
           //转换，这可以对类型进行检测，使用instance of
            TextMessage txtMsg = (TextMessage)msg;
            try {
                System.out.println("得到消息内容："+txtMsg.getText());
                System.out.println("处理完一条消息！！");
                //如果开启了事务，请session.commit();
            } catch (JMSException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
    });
</code></pre>

<p>```</p>

<p>&emsp;&emsp;当目标程序运行时，我们可以打开ActiveMQ的管理界面，即可发现这个queue及上面的消费者。</p>

<p><span class='caption-wrapper'><img class='caption' src='/uploads/2014/04/active_mq_admin.jpg' width='' height='' title='ActiveMQ的管理界面'><span class='caption-text'>ActiveMQ的管理界面</span></span></p>

<p>&emsp;&emsp;大家还要注意的是，我们的AOP通知中，还获取了调用者的ip，访问者姓名等信息，这些和web环境相关的信息是通过类似于下面的代码实现的：</p>

<p>``` java</p>

<p>ServletRequestAttributes sas = (ServletRequestAttributes)RequestContextHolder.getRequestAttributes();
HttpServletRequest req = sas.getRequest();</p>

<p>logger.setIp(req.getLocalAddr());
logger.setSessionId(sas.getSessionId());</p>

<p>if (req.getSession() != null) {</p>

<pre><code>logger.setOperater((String)req.getSession().getAttribute(userNameSessionKey));
</code></pre>

<p>}</p>

<p>```
 &emsp;&emsp;其中的RequestContextHolder是由spring封装，具体做法是将用户web相关的信息通过filter或listener放入ThreadLocal对象中，在需要的地方通过RequestContextHolder从ThreadLocal中取得，因此，你想让上面的代码正常工作，要记得在web.xml中添加一个spring已经写好的RequestContextListener监听器哦。</p>

<p>``` xml  web.xml</p>

<pre><code>&lt;listener&gt;
    &lt;listener-class&gt;
        org.springframework.web.context.request.RequestContextListener
    &lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre>

<p>```</p>

<p> &emsp;&emsp;当然，本例中所使用的消息服务器是ActiveMQ，这个服务器实现了JMS规范，在企业级应用场景中不会存在问题。如果在互联网行业中，由于会面临高并发、大流量等情况，ActiveMQ不能保证高可用性、稳定性及性能要求，这个时候我们可以考虑其它的第三方消息服务器，比如淘宝的taobao-metaq，alibaba-rocketmq等，这些服务器是经过实际考验的开源产品，值得在互联网场景中使用。当然，这些MQ服务器和JMS规范没有任何关系，JMS企业级要求中并没有考虑过多的并发、大数据量的需求。</p>

<p> &emsp;&emsp;另外，kafka，rabbitmq等消息服务器也具有不错的性能，都可以进入架构的技术方案选型范围。比如，下面是一段rabbitmq的调用示例代码(注：rabbitmq需要er_lang并发程序包支持哦)，和JMS的调用相当类似。</p>

<p>``` java
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;</p>

<p>&hellip;&hellip;.//略去代码</p>

<pre><code>@Test
public void testSendMessage() throws Exception {
    SimpleDateFormat sf = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");

    ConnectionFactory factory = new ConnectionFactory();
    factory.setHost("localhost");

    Connection connection = factory.newConnection();
    Channel channel = connection.createChannel();

    String message = sf.format(new Date()) + ":Hello!!!";
    channel.basicPublish("", "queue/sendEmail", null, message.getBytes());


    channel.close();
    connection.close();

    System.out.println("send message ok!");



}


@Test
public void testReciveMessage() throws Exception {

    System.out.println("recever starting.....");

    String QUEUE_NAME = "queue/sendEmail";

    SimpleDateFormat sf = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");

    ConnectionFactory factory = new ConnectionFactory();
    factory.setHost("localhost");

    Connection connection = factory.newConnection();
    Channel channel = connection.createChannel();

    channel.queueDeclare(QUEUE_NAME, false, false, false, null);

    QueueingConsumer consumer = new QueueingConsumer(channel);
    channel.basicConsume(QUEUE_NAME, false, consumer);

    QueueingConsumer.Delivery delivery = consumer.nextDelivery();

    String msg = new String(delivery.getBody());

    System.out.println(msg);

    System.out.println("rec end!!!");
}
</code></pre>

<p>```</p>

<p> &emsp;&emsp;先说到这吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[监控系统中的异步消息使用实例（一）]]></title>
    <link href="http://yanyaner.com/blog/2014/04/08/async_message_architect1/"/>
    <updated>2014-04-08T12:18:00+08:00</updated>
    <id>http://yanyaner.com/blog/2014/04/08/async_message_architect1</id>
    <content type="html"><![CDATA[<p>&emsp;&emsp;以后的文章要尽量做到通俗，让非技术人员都读得懂，道理就跟艺术作品一样，一件好的作品，不需要配任何文字说明就足以打动普通观众，做到雅俗共赏而且有深度和内涵，其实，这需要作者相当的功力。</p>

<p>&emsp;&emsp;近期一些童鞋在实现一个监控系统，其中的一个功能是：对监控平台上布署的第三方应用业务方法执行细节进行监控，比如：方法调用者，调用者ip，应用系统名称，子系统名称，方法名称，执行耗时等信息。如何能够让监控系统得到目标机器上需要监控的业务方法执行情况呢？如何保证在监控的过程中不影响对方的业务的正常执行？下面我给出一种参考架构实现，这也是在概要设计的时候就应该明确的东西（专业名词叫架构原型）。</p>

<p><span class='caption-wrapper'><img class='caption' src='/uploads/2014/04/monitor_jms1.jpg' width='' height='' title='业务方法监控架构'><span class='caption-text'>业务方法监控架构</span></span></p>

<p>&emsp;&emsp;首先，MonitorPlatform是我们的监控平台（图中青色部分），targetServer上运行着需要监控的系统hotel project（图中黄色部分）,如果我们想要获得目标机器上的我们需要的信息，最简单的办法是运行一个spy程序在对方的机器上，图中的spy app是起这个作用的（当然你也可以使用jmx规范来实现类似功能），举个不恰当的例子，就好比你在某人的机器上安装了一个木马程序，通过远程控制端你就可以得到对方机器上你感兴趣的任何东西，甚至包括控制摄像头哦。</p>

<p>&emsp;&emsp;其次，监控平台同时要监控多个目标系统，就我们例子中监控业务方法执行情况而言，就需要把监控得到的信息加以持久化以备后查，如果目标系统业务繁忙，而我们的spy app又要将取到的信息进行数据库持久化，数据库很可能会成为性能瓶颈从而造成性能问题，因此，我在这里采用了异步消息系统的设计，以缓解持久化压力。正如图所示，spy app将采集到的业务方法执行数据直接写入异步消息服务器的queue中，而monitor platform中的处理程序将从queue中取出消息，再进行后续的持久化处理。这种异步的消息设计方式可以有效缓解系统的压力，在很多项目中都可以采用（互联网项目中可用这种方式来"削峰"，缓解高并发压力）。</p>

<p>&emsp;&emsp;最后一个问题,spy如何采集到目标机器业务方法的执行情况呢。最佳答案当然是AOP。大家可以参考我的另一篇文章<a href="/blog/2013/03/26/logger/">一种日志记录解决方案</a>。</p>

<p>&emsp;&emsp;下面，我们一起来看看架构原型中的原代码实现吧。MethodLoggerMessage是需要持久化的消息对象，请注意实现Serializable接口。<!-- more --></p>

<p>``` java MethodLoggerMessage.java</p>

<p>package com.monitor.client.commons;</p>

<p>import java.io.Serializable;
import java.util.Date;</p>

<p>/<em>*
 * 需要持久化的对象消息
 * @author ljh
 *
 </em>/
public class MethodLoggerMessage implements Serializable {</p>

<pre><code>//方法执行时间，单位：毫秒
private double howLong;
//方法名
private String methodName;
//执行者ip地址
private String ip;
//执行者session会话id
private String sessionId;
//执行者
private String operater = "";
//执行时间
private Date execTimer;

public double getHowLong() {
    return howLong;
}
public void setHowLong(double howLong) {
    this.howLong = howLong;
}
public String getMethodName() {
    return methodName;
}
public void setMethodName(String methodName) {
    this.methodName = methodName;
}
public String getIp() {
    return ip;
}
public void setIp(String ip) {
    this.ip = ip;
}
public String getOperater() {
    return operater;
}
public void setOperater(String operater) {
    this.operater = operater;
}
public String getSessionId() {
    return sessionId;
}
public void setSessionId(String sessionId) {
    this.sessionId = sessionId;
}
public Date getExecTimer() {
    return execTimer;
}
public void setExecTimer(Date execTimer) {
    this.execTimer = execTimer;
}
@Override
public String toString() {
    return "MethodLoggerMessage [howLong=" + howLong + ", methodName="
            + methodName + ", ip=" + ip + ", sessionId=" + sessionId
            + ", operater=" + operater + ", execTimer=" + execTimer + "]";
}
</code></pre>

<p>```</p>

<p>&emsp;&emsp;IMessageDao接口用来定义消息持久化行为，可以有很同种不同的实现版本，如基于消息的，关系数据库的或nosql的等等，有了这个接口，我们在intercepter中就可以做到拦截代码和持久化代码的解耦。</p>

<p>``` java IMessageDao.java
package com.monitor.client.dao;</p>

<p>import java.io.Serializable;</p>

<p>/<em>*
 * 持久化消息服务
 * @author ljh
 *
 </em>/
public interface IMessageDao {</p>

<pre><code>public void persist(Serializable msg);
</code></pre>

<p>}
```</p>

<p>&emsp;&emsp;接下来是消息持久化实现类源代码。因为采用了jms，因此我直接使用了spring对jms封装的模板方法实现。</p>

<p>``` java JMSMessageDaoImpl.java
package com.monitor.client.dao;</p>

<p>import java.io.Serializable;</p>

<p>import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.ObjectMessage;
import javax.jms.Session;</p>

<p>import org.springframework.jms.core.JmsTemplate;
import org.springframework.jms.core.MessageCreator;</p>

<p>/<em>*
 * jms消息处理实现
 * @author ljh
 *
 </em>/
public class JMSMessageDaoImpl implements IMessageDao {</p>

<pre><code>//jms模板
private JmsTemplate jmsTemplate;
//目标队列名称
private String destinationName;

@Override
public void persist(final Serializable msg) {

    MessageCreator mc = new MessageCreator() {

        @Override
        public Message createMessage(Session session) throws JMSException {
            //创建对象消息，并发送之
            ObjectMessage objMsg = session.createObjectMessage();   
            objMsg.setObject(msg);

            return objMsg;
        }
    };

    if (destinationName == null) {
        jmsTemplate.send(mc);
    } else {
        //发送到指定的目标
        jmsTemplate.send(destinationName, mc);
    }


}

public void setJmsTemplate(JmsTemplate jmsTemplate) {
    this.jmsTemplate = jmsTemplate;
}

public void setDestinationName(String destinationName) {
    this.destinationName = destinationName;
}
</code></pre>

<p>}
```</p>

<p>&emsp;&emsp;最重要的就是这个拦截器实现了。环绕拦截器，功能最为强大。</p>

<p>``` java SpyMethodIntercepter.java
package com.monitor.client.spy;</p>

<p>import java.util.Date;</p>

<p>import javax.servlet.http.HttpServletRequest;</p>

<p>import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;</p>

<p>import com.monitor.client.commons.MethodLoggerMessage;
import com.monitor.client.dao.IMessageDao;
/<em>*
 * 目标服务器方法拦截器，调用信息可以通过异步消息机制持久化，具体要看IMessageDao实现
 * @author ljh
 *
 </em>/
public class SpyMethodIntercepter implements MethodInterceptor{</p>

<pre><code>public static final Logger LOG = LoggerFactory.getLogger(SpyMethodIntercepter.class);

//消息处理dao
private IMessageDao messageDao;
//当前登录者在目标系统中的登录用户名之key,在配置第三方程序时注入
private String userNameSessionKey = "loginedUserName";

@Override
public Object invoke(MethodInvocation method) throws Throwable {

    //取方法执行时的开始时间
    long start = System.nanoTime();

    try {
        return method.proceed();
    } catch (Exception ex) {
        throw ex;
    } finally {

        try {
            //为了不影响目标方法的运行，这里再次try
            //得到访问者request对象
            ServletRequestAttributes sas = (ServletRequestAttributes)RequestContextHolder.getRequestAttributes();
            HttpServletRequest req = sas.getRequest();

            //取方法执行后的时间
            long end = System.nanoTime();

            //方法执行时间
            long howLong = end - start;
            String methodName = method.getMethod().getName();

            //持久化方法调用日志
            MethodLoggerMessage logger = new MethodLoggerMessage();

            logger.setMethodName(methodName);

            //方法执行时间，单位：毫秒
            logger.setHowLong((double)howLong/(1000*1000));

            logger.setIp(req.getLocalAddr());
            logger.setSessionId(sas.getSessionId());

            if (req.getSession() != null) {
                logger.setOperater((String)req.getSession().getAttribute(userNameSessionKey));
            }

            logger.setExecTimer(new Date());

            messageDao.persist(logger);
        } catch (Exception exc) {
            //do nothing or LOG.debug(ex.getMessage());
            LOG.warn("Error in spy: {}", exc);
        }

    }

}

public void setMessageDao(IMessageDao messageDao) {
    this.messageDao = messageDao;
}

public void setUserNameSessionKey(String userNameSessionKey) {
    this.userNameSessionKey = userNameSessionKey;
}
</code></pre>

<p>}</p>

<p>```</p>

<p>&emsp;&emsp;至此，spy程序这边基本开发完成了。目标服务器上，该如何配置呢？监控平台的消息处理者又该如何实现呢？</p>

<p>&emsp;&emsp;且听下回分解。</p>
]]></content>
  </entry>
  
</feed>
