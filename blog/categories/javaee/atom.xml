<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[☺分类☺：javaEE | 刘江华的博客]]></title>
  <link href="http://yanyaner.com/blog/categories/javaee/atom.xml" rel="self"/>
  <link href="http://yanyaner.com/"/>
  <updated>2013-12-24T14:18:15+08:00</updated>
  <id>http://yanyaner.com/</id>
  <author>
    <name><![CDATA[冰雨]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[在项目中使用maven之二--项目实例]]></title>
    <link href="http://yanyaner.com/blog/2013/12/24/maven-project/"/>
    <updated>2013-12-24T15:18:00+08:00</updated>
    <id>http://yanyaner.com/blog/2013/12/24/maven-project</id>
    <content type="html"><![CDATA[<p>&emsp;&emsp;本篇文章介绍如何搭建一个maven工程。</p>

<p>&emsp;&emsp;我们以eclipse kepler为例，kepler版本的eclipse自带有maven插件，可以省去我们自己安装的过程，着实比较方便。</p>

<p>&emsp;&emsp;在新建项目向导中，我们选择maven工程，在Archetype中选择项目类型，要注意的是，一般的项目模块，选择maven-archetype-quickstart类型即可，如果是web项目请选择maven-archetype-webapp，当然你也可以根据个人喜好选择其它的项目模板类型。</p>

<p><span class='caption-wrapper'><img class='caption' src='/uploads/2013/12/project_waizd1.jpg' width='' height='' title='选择maven工程类型'><span class='caption-text'>选择maven工程类型</span></span></p>

<p>&emsp;&emsp;接下来输入项目坐标信息，如下图。groupId为组织标识，一般填写公司域名（请倒过来写，呵呵)，artifactId为产品标识，多字母间请用-连接，version是这个产品的版本号，一般有SNAPSHOT快照版与RELEASE稳定版。</p>

<p><span class='caption-wrapper'><img class='caption' src='/uploads/2013/12/project_waizd2.jpg' width='' height='' title='输入maven项目的组织、公司、版本信息'><span class='caption-text'>输入maven项目的组织、公司、版本信息</span></span></p>

<p>&emsp;&emsp;接下来，我们来看看如何规划你的项目工程。如果是非常庞大的项目，采用Maven管理会非常的合适，因为在大的项目中，不同的模块，不同的子系统，不同的分层都有可能是不同的团队去完成，请看我下面的一个项目规划。<!--more--></p>

<p><span class='caption-wrapper'><img class='caption' src='/uploads/2013/12/project_struct.jpg' width='' height='' title='管理系统模块划分'><span class='caption-text'>管理系统模块划分</span></span></p>

<p>&emsp;&emsp;在上面的项目结构图中，你可以发现，我对项目模块进行了很好的分配。</p>

<ul>
<li>car_parents为父项目，其它的子项目都将继承这个项目中的配置，以省去了在每个子项目中都进行重复配置的麻烦。</li>
<li>framework项目，是整个系统的基础框架封装。</li>
<li>car-core项目是系统核心，主要是系统的领域对象（也有人叫业务对象）。</li>
<li>car-dao是项目持久层实现。</li>
<li>car-service是系统的核心业务逻辑实现。</li>
<li>car-web是系统对外部的调用接口，取名为car-facade也许更为合适（针对webservice类型），当然，我在这里主要存放的是restful接口及一些前端页面之类的文件。</li>
</ul>


<p>&emsp;&emsp;下面，我展示一个普通项目的目录结构，maven的项目结构和eclipse所建默认工程项目结构有很大的区别，最明显的感觉是目录的划分、规划更为合理、清晰。</p>

<p><span class='caption-wrapper'><img class='caption' src='/uploads/2013/12/project_struct2.jpg' width='' height='' title='一个普通maven项目的目录结构'><span class='caption-text'>一个普通maven项目的目录结构</span></span></p>

<p>&emsp;&emsp;上图中的结构我说明如下：</p>

<ul>
<li>src/main/java，该目录存放项目的源代码。</li>
<li>src/main/resources，该目录存放项目相关的资源文件，比如：properties文件, xml文件等等。</li>
<li>src/test/java，此目录下存放测试文件（注意，在maven中的测试类要以test开头或结尾，或以testCase结尾，这是规范要求）</li>
<li>target，该目录一般会存放编译打包后产生的文件，比如jar或war。</li>
</ul>


<p>&emsp;&emsp;接下来带大家看看具体的配置文件，先看parents这个项目，该项目工程基本上只有一个pom.xml文件，用来定义各个项目共同的东西。</p>

<p>``` xml pom.xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion></p>

<p>  <groupId>com.ljh.ms</groupId>
  <artifactId>car-parents</artifactId>
  <version>0.0.1-SNAPSHOT</version>
  <packaging>pom</packaging></p>

<p>  <modules></p>

<pre><code>&lt;module&gt;../framework&lt;/module&gt;
&lt;module&gt;../car-core&lt;/module&gt;
&lt;module&gt;../car-dao&lt;/module&gt;
&lt;module&gt;../car-service&lt;/module&gt;
&lt;module&gt;../car-web&lt;/module&gt;
</code></pre>

<p>  </modules></p>

<p>  <!-- 定义发行、快照的打包上传服务器路径 -->
  <distributionManagement></p>

<pre><code>    &lt;repository&gt;
        &lt;id&gt;carManagerProjectRelease&lt;/id&gt;
        &lt;name&gt;Car ManagerSystem Release&lt;/name&gt;
        &lt;url&gt;http://127.0.0.1:8081/nexus/content/repositories/car_ms_release/&lt;/url&gt;
    &lt;/repository&gt;
    &lt;snapshotRepository&gt;
        &lt;id&gt;carManagerProjectSnapshot&lt;/id&gt;
        &lt;name&gt;Car ManagerSystem Snapshots&lt;/name&gt;
        &lt;url&gt;http://127.0.0.1:8081/nexus/content/repositories/car_ms_snapshot/&lt;/url&gt;
    &lt;/snapshotRepository&gt;
</code></pre>

<p></distributionManagement></p>

<p>  <name>car-parents</name>
  <url><a href="http://maven.apache.org">http://maven.apache.org</a></url></p>

<p>  <!-- 定义公共的变量值 -->
  <properties></p>

<pre><code>&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
&lt;spring.version&gt;3.2.5.RELEASE&lt;/spring.version&gt;
</code></pre>

<p>  </properties></p>

<p>  <!-- 定义依赖包 -->
  <dependencies></p>

<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;junit&lt;/groupId&gt;
  &lt;artifactId&gt;junit&lt;/artifactId&gt;
  &lt;version&gt;4.10&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;

&lt;!-- =======begin spring 3.2.4.RELEASE========= --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
    &lt;version&gt;${spring.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;
    &lt;version&gt;${spring.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-core&lt;/artifactId&gt;
    &lt;version&gt;${spring.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;
    &lt;version&gt;${spring.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;
    &lt;version&gt;${spring.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
    &lt;version&gt;${spring.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
    &lt;version&gt;${spring.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-expression&lt;/artifactId&gt;
    &lt;version&gt;${spring.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-instrument&lt;/artifactId&gt;
    &lt;version&gt;${spring.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
    &lt;version&gt;${spring.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-web&lt;/artifactId&gt;
    &lt;version&gt;${spring.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- =====end spring 3.2.4.RELEASE===== --&gt;

&lt;!-- =====start hibernate3 ====== --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
    &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;
    &lt;version&gt;3.6.10.Final&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
    &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
    &lt;version&gt;1.7.5&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
    &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
    &lt;version&gt;1.7.5&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javassist&lt;/groupId&gt;
    &lt;artifactId&gt;javassist&lt;/artifactId&gt;
    &lt;version&gt;3.12.1.GA&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;antlr&lt;/groupId&gt;
    &lt;artifactId&gt;antlr&lt;/artifactId&gt;
    &lt;version&gt;2.7.7&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;cglib&lt;/groupId&gt;
    &lt;artifactId&gt;cglib-nodep&lt;/artifactId&gt;
    &lt;version&gt;2.2.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- =====end hibernate3 ====== --&gt;

&lt;!-- =====commoms start =====--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;commons-collections&lt;/groupId&gt;
    &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;
    &lt;version&gt;3.2.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;commons-io&lt;/groupId&gt;
    &lt;artifactId&gt;commons-io&lt;/artifactId&gt;
    &lt;version&gt;2.3&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;commons-logging&lt;/groupId&gt;
    &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;
    &lt;version&gt;1.1.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
    &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
    &lt;version&gt;1.2.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;commons-dbcp&lt;/groupId&gt;
    &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt;
    &lt;version&gt;1.4&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;commons-digester&lt;/groupId&gt;
    &lt;artifactId&gt;commons-digester&lt;/artifactId&gt;
    &lt;version&gt;2.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;commons-pool&lt;/groupId&gt;
    &lt;artifactId&gt;commons-pool&lt;/artifactId&gt;
    &lt;version&gt;1.6&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;dom4j&lt;/groupId&gt;
    &lt;artifactId&gt;dom4j&lt;/artifactId&gt;
    &lt;version&gt;1.6.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j&lt;/artifactId&gt;
    &lt;version&gt;1.2.9&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- =====end commoms  =====--&gt;

&lt;!-- =====database start===== --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;version&gt;5.1.19&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- =====database end===== --&gt;

&lt;!-- ===== start servlet+jstl+jsp ===== --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;servletapi&lt;/groupId&gt;
    &lt;artifactId&gt;servletapi&lt;/artifactId&gt;
    &lt;version&gt;2.4&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;
    &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;
    &lt;version&gt;2.2&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;jstl&lt;/groupId&gt;
    &lt;artifactId&gt;jstl&lt;/artifactId&gt;
    &lt;version&gt;1.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;taglibs&lt;/groupId&gt;
    &lt;artifactId&gt;standard&lt;/artifactId&gt;
    &lt;version&gt;1.1.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- ===== end servlet+jstl+jsp ===== --&gt;

&lt;!-- ===== start json ===== --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-core-asl&lt;/artifactId&gt;
    &lt;version&gt;1.9.6&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt;
    &lt;version&gt;1.9.6&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- ===== end json ===== --&gt;
</code></pre>

<p>  </dependencies></p>

<p>  <build></p>

<pre><code>&lt;pluginManagement&gt;
    &lt;plugins&gt;

        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
            &lt;version&gt;2.3.2&lt;/version&gt;
            &lt;configuration&gt;
                &lt;source&gt;1.6&lt;/source&gt;
                &lt;target&gt;1.6&lt;/target&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;

        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;
            &lt;version&gt;2.6&lt;/version&gt;
            &lt;configuration&gt;
                &lt;encoding&gt;UTF-8&lt;/encoding&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;

        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;
            &lt;version&gt;2.4&lt;/version&gt;
            &lt;inherited&gt;true&lt;/inherited&gt;
            &lt;configuration&gt;
                &lt;archive&gt;                   
                    &lt;manifest&gt;
                        &lt;addDefaultImplementationEntries&gt;true&lt;/addDefaultImplementationEntries&gt;
                        &lt;addDefaultSpecificationEntries&gt;true&lt;/addDefaultSpecificationEntries&gt;
                    &lt;/manifest&gt;
                &lt;/archive&gt;
            &lt;/configuration&gt;
            &lt;!--  定义打war包要排除的文件
            &lt;executions&gt;
                &lt;execution&gt;
                    &lt;phase&gt;package&lt;/phase&gt;
                    &lt;goals&gt;
                        &lt;goal&gt;jar&lt;/goal&gt;
                    &lt;/goals&gt;
                    &lt;configuration&gt;
                        &lt;classifier&gt;lib&lt;/classifier&gt;
                        &lt;excludes&gt;
                            &lt;exclude&gt;*.properties&lt;/exclude&gt;
                        &lt;/excludes&gt;
                    &lt;/configuration&gt;
                &lt;/execution&gt;
            &lt;/executions&gt;
            --&gt;
        &lt;/plugin&gt;

        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;
            &lt;version&gt;2.4&lt;/version&gt;
            &lt;configuration&gt;
                &lt;archive&gt;                   
                    &lt;manifest&gt;
                        &lt;addDefaultImplementationEntries&gt;true&lt;/addDefaultImplementationEntries&gt;
                        &lt;addDefaultSpecificationEntries&gt;true&lt;/addDefaultSpecificationEntries&gt;
                    &lt;/manifest&gt;
                &lt;/archive&gt;
                &lt;archiveClasses&gt;true&lt;/archiveClasses&gt;
                &lt;warName&gt;car_ms&lt;/warName&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;

        &lt;plugin&gt;
            &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt;
            &lt;!-- 使用的是jetty-maven-plugin的插件 --&gt;
            &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt;
            &lt;version&gt;8.1.14.v20131031&lt;/version&gt;
            &lt;configuration&gt;
                &lt;scanIntervalSeconds&gt;2000&lt;/scanIntervalSeconds&gt;
                &lt;webApp&gt;
                    &lt;!-- 上下文路径 --&gt;
                    &lt;contextPath&gt;/car_ms&lt;/contextPath&gt;
                &lt;/webApp&gt;
                &lt;connectors&gt;
                    &lt;!-- 注意要使用将implementation 由org.eclipse.jetty.server.nio.SelectChannelConnector --&gt;
                    &lt;!-- 换为org.eclipse.jetty.server.bio.SocketConnector，否则静态页面无法修改 --&gt;

                    &lt;connector implementation="org.eclipse.jetty.server.bio.SocketConnector"&gt;
                        &lt;!-- 端口号 --&gt;
                        &lt;port&gt;8787&lt;/port&gt;
                        &lt;maxIdleTime&gt;500000&lt;/maxIdleTime&gt;
                    &lt;/connector&gt;
                &lt;/connectors&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
 &lt;/pluginManagement&gt;
</code></pre>

<p>  </build></p>

<p></project>
```</p>

<p>&emsp;&emsp;当然，这篇配置示例还有优化改进的地方，我没有详细去做。比如，可以把所有的dependencie放入<dependencyManagement>节点中以更好的独立定义每个子项目的依赖关系，比如：把很多重复属性定义成变量以便于统一维护等等，但这个文件也足以说明问题，比如下面这段配置代码：</p>

<p>``` xml
 <modules></p>

<pre><code>&lt;module&gt;../framework&lt;/module&gt;
&lt;module&gt;../car-core&lt;/module&gt;
&lt;module&gt;../car-dao&lt;/module&gt;
&lt;module&gt;../car-service&lt;/module&gt;
&lt;module&gt;../car-web&lt;/module&gt;
</code></pre>

<p>  </modules>
```
&emsp;&emsp;这段代码定义了项目间的依赖关系，其中的.. ，表示上一级目录，也就是和本项目同级的项目中定义的model名称，在这个项目上运行test, install, deploy等命令，将会对所有的子项目执行相同的命令。</p>

<p>&emsp;&emsp;好，今天就简单说到这，下篇关于maven的技术细节，敬请期待。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在项目中使用maven之一--环境配置]]></title>
    <link href="http://yanyaner.com/blog/2013/12/23/maven/"/>
    <updated>2013-12-23T15:18:00+08:00</updated>
    <id>http://yanyaner.com/blog/2013/12/23/maven</id>
    <content type="html"><![CDATA[<p>&emsp;&emsp;Apache Maven是一个软件项目综合管理工具，它基于项目对象模型（POM）的概念来统一管理项目，使用Maven可以更好地管理项目的模块化，更好地管理项目之间的依赖，更好地管理jar包依赖及其版本，也更加贴近项目管理的各个阶段。</p>

<p>&emsp;&emsp;你是否碰到过这样的一些困扰，比如：你现在要搭建一个现今比较流行的SSH javaEE框架原型，按照传统的方式，你得把项目所依赖的第三方框架jar包拷贝到工程的lib目录下再进行整合，但是，在你的架构原型中，每一个框架要用什么版本，各个版本的jar包之间是否会有不兼容的情况？这些都会给整个过程带来麻烦，并花费大量的调试时间。</p>

<p>&emsp;&emsp;如果有了Maven，这个事情会变得简单，你也许只需要声明一个依赖关系，所有的一切都自动完成了。</p>

<p>&emsp;&emsp;例如，我要写一个activeMQ的JMS项目，我的pom.xml中，只要添加如下的一个依赖，即可开始编码了：</p>

<p>``` xml pom.xml
<dependencies></p>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;
    &lt;artifactId&gt;activemq-core&lt;/artifactId&gt;
    &lt;version&gt;5.7.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<p>  </dependencies>
```</p>

<p><span class='caption-wrapper'><img class='caption' src='/uploads/2013/12/maven1.jpg' width='' height='' title='activeMQ项目中maven依赖的项目包'><span class='caption-text'>activeMQ项目中maven依赖的项目包</span></span></p>

<p>&emsp;&emsp;当然，上面的示例中使用maven也有一点约束，那就是你的开发机器必须要能够连接到互联网上，并且网速不能太卡（这点可能有些开发者的环境无法满足而制约了maven在国内的普及速度），原因显而易见：所有的jar包需要从网上的仓库中下载到本地。<!--more--></p>

<p>&emsp;&emsp;你可能通过上面的那段配置文件已经发现，在maven中世界中，每一个你所依赖的组件都是通过groupId、artifactId、version三个字段来定位的，好比x、y、h可以定位一个三维空间中的目标一样。如果你要问，我怎么知道所依赖的包的三维坐标信息呢，答案是：到<a href="http://mvnrepository.com/">mvnrepository.com</a>上查询。</p>

<p>&emsp;&emsp;如果公司的开发环境处在一个封闭的局域网内，就得需要安装一些工具，另加一些额外的配置了，nexus是值得选择的内网Maven仓库，下面我给大家简单介绍一下nexus的安装、配置以及maven的基本配置。</p>

<p>&emsp;&emsp;步骤如下：</p>

<ul>
<li>到nexus官网，下载nexus-2.7.0-04-bundle.zip文件（当然，你下载的版本号可能和我不同）</li>
<li>解压到自已的一个目录中，比如我放到了D:\dev_tools\nexus-2.7.0-04-bundle\下</li>
<li>接着，添加到路径变量到path中，注意是bin目录，我添加的是D:\dev_tools\nexus-2.7.0-04-bundle\nexus-2.7.0-04\bin</li>
<li>安装系统服务，进入cmd中，运行：nexus install，这个时候，你可以在window的系统服务中看到这样的路径信息：D:\dev_tools\nexus-2.7.0-04-bundle\nexus-2.7.0-04\bin\jsw\windows-x86-32\wrapper.exe -s D:\dev_tools\nexus-2.7.0-04-bundle\nexus-2.7.0-04\bin\jsw\conf\wrapper.conf,实际运行的就是这个命令</li>
<li>启动服务：nexus start，如果不出意外的话，你可以看到下面的界面，这证明安装成功了，。</li>
</ul>


<p><span class='caption-wrapper'><img class='caption' src='/uploads/2013/12/nexus1.jpg' width='' height='' title='启动nexus cmd界面'><span class='caption-text'>启动nexus cmd界面</span></span></p>

<p>&emsp;&emsp;在浏览器中，输入 htt p:/ / localhost:8081/nexus/  ，在主页面中输入用户名admin，密码admin123即可完成登录。</p>

<p>&emsp;&emsp;在Repositories中建立自己的仓库，如下图表中的Car ManagerSystem Release、Car ManagerSystem Snapshots就是我为车辆租赁管理系统建立的Release及Snapshort版本（这里注意，一般Repository ID有多个单词的情况下用-连接，我当时的命名并不规范）。</p>

<p><span class='caption-wrapper'><img class='caption' src='/uploads/2013/12/nexus2.jpg' width='' height='' title='我的项目中nexus截图'><span class='caption-text'>我的项目中nexus截图</span></span></p>

<p>&emsp;&emsp;接下来，找到Security菜单项，针对新建的两个仓库分别配置Privileges,Roles,Users。关于nexus的详细教程，大家可以自行在网上搜索，我在这还再详述。</p>

<p>&emsp;&emsp;下面要安装MAVEN了，步骤如下：</p>

<ul>
<li>到官网上下载apache-maven-3.1.1-bin.zip（你的版本可能跟我不一样），解压到目录D:\dev_tools\maven-3.1.1下（这个目录大家自行决定）。</li>
<li>在环境变量中，将maven的bin目录加入到path中。</li>
</ul>


<p>&emsp;&emsp;回到命令行下，输入mvn，出现下面界面，说明maven安装成功（当然，添加环境变量，只是为了你可以在命令行手工运行maven）。</p>

<p><span class='caption-wrapper'><img class='caption' src='/uploads/2013/12/maven2.jpg' width='' height='' title='安装成功的cmd窗口'><span class='caption-text'>安装成功的cmd窗口</span></span></p>

<p>&emsp;&emsp;目前的新版eclipse集成了maven，一般建议大家使用本地安装的maven以达到版本的统一，你可以在eclipse中进行选择配置，界面如下：</p>

<p><span class='caption-wrapper'><img class='caption' src='/uploads/2013/12/maven3.jpg' width='' height='' title='在eclipse中配置非集成maven'><span class='caption-text'>在eclipse中配置非集成maven</span></span></p>

<p>&emsp;&emsp;接下来，我们对maven进行参数进行配置，一般配置文件位于C:\Documents and Settings\Administrator.m2下，文件名为settings.xml，下面是我节选的部分修改过的配置代码：</p>

<p>``` xml settings.xml</p>

<pre><code> &lt;localRepository&gt;F:/java/maven&lt;/localRepository&gt;
</code></pre>

<p><servers></p>

<pre><code> &lt;server&gt;
  &lt;id&gt;carManagerProjectRelease&lt;/id&gt;
  &lt;username&gt;deployment&lt;/username&gt;
  &lt;password&gt;deployment123&lt;/password&gt;
&lt;/server&gt;

&lt;server&gt;
  &lt;id&gt;carManagerProjectSnapshot&lt;/id&gt;
  &lt;username&gt;deployment&lt;/username&gt;
  &lt;password&gt;deployment123&lt;/password&gt;
&lt;/server&gt;
</code></pre>

<p></servers></p>

<pre><code>&lt;profiles&gt;
   &lt;profile&gt;
   &lt;id&gt;central-repos&lt;/id&gt;
   &lt;repositories&gt;
        &lt;repository&gt;
          &lt;id&gt;central&lt;/id&gt;
          &lt;name&gt;Central&lt;/name&gt;
          &lt;url&gt;http://127.0.0.1:8081/nexus/content/groups/public/&lt;/url&gt;
          &lt;releases&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/releases&gt;
          &lt;snapshots&gt;
            &lt;enabled&gt;true&lt;/enabled&gt;
          &lt;/snapshots&gt;
        &lt;/repository&gt;
      &lt;/repositories&gt;
    &lt;/profile&gt;
&lt;/profiles&gt;

&lt;activeProfiles&gt;
    &lt;activeProfile&gt;central-repos&lt;/activeProfile&gt;
&lt;/activeProfiles&gt;
</code></pre>

<p>```</p>

<p>&emsp;&emsp;上面的文件中，我主要配置了本地仓库所在的位置，maven从网上下载的第三方依赖包，都将存放在这个地方。我放到了F:/java/maven，如果你的这个目录下已经有了非常多的jar包，你可以将这个目录直接copy给其它的开发同事机器上，避免重复下载。</p>

<p>&emsp;&emsp;server部分配置了可以上传到nexus中的相关账户的登录名及密码，这些信息都是在nexus的管理界面中配置的。而http : / /127.0.0.1:8081/nexus/content/groups/public 则是本地maven库所在的服务器路径。</p>

<p>&emsp;&emsp;好了，今天先到这，下一篇文章会详细介绍如何在项目中使用maven.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[spring aop实现机制]]></title>
    <link href="http://yanyaner.com/blog/2013/07/01/spring-aop/"/>
    <updated>2013-07-01T15:18:00+08:00</updated>
    <id>http://yanyaner.com/blog/2013/07/01/spring-aop</id>
    <content type="html"><![CDATA[<p>&emsp;&emsp;spring对持久层的事务管理采用的aop实现，在spring底层，aop是使用的代理模式实现的，代理模式在java中一般有jdk 动态代理以及cglib实现的更为高效的代理，jdk动态代理采用的是标准代理模式（大家可以看看标准代理模式的uml图），被代理对象必须要实现接口，而cglib就没有这一强制性要求了。</p>

<p>&emsp;&emsp;下面，我要实现一个环绕通知，分别用jdk动态代理，cglib，以及在spring中的配置实现。</p>

<p>&emsp;&emsp;我有两个接口，IMyService1，IMyService2，实现类MyServiceImpl实现了这两个接口，另外，还写了一个没有实现任何接口的service ,NoInterfaceService。</p>

<p>&emsp;&emsp;<strong>一、jdk动态代理</strong></p>

<p>``` java MyInvocationHandler.java</p>

<p>//调用处理程序，相当于aop中的环绕通知
public class MyInvocationHandler implements java.lang.reflect.InvocationHandler {</p>

<pre><code>//被代理的对象
private Object target;

//构造方法传入被代理的对象
public MyInvocationHandler(Object target) {
    this.target = target;
}

@Override
public Object invoke(Object proxy, Method method, Object[] args)
        throws Throwable {
    //proxy就是$proxy0,里面包含一个target属性，为代理的目标对象

    System.out.println(method.getName() + "方法调用前！");

    Object result = method.invoke(target, args);

    System.out.println(method.getName() + "方法调用后！");
    return result;
}
</code></pre>

<p>}
```</p>

<p>&emsp;&emsp;测试代码：</p>

<p>``` java</p>

<p>//目标对象</p>

<pre><code>    MyServiceImpl ms = new MyServiceImpl();

    //创建代理对象，interface是代理要
    IMyService1 ms1 = 
            (IMyService1)Proxy.newProxyInstance(ms.getClass().getClassLoader(),
            ms.getClass().getInterfaces(), new MyInvocationHandler(ms));

    ms1.biz1();

    IMyService2 ms2 = (IMyService2)ms1;
    ms2.biz2();
</code></pre>

<p>```</p>

<p>&emsp;&emsp;请大家注意，需要动态代理的接口，由上面ms.getClass().getInterfaces()的代码传入，并且，我们可以发现，代理产生的对象，可以强转为其中任意一个接口，但如果强转为MyServiceImpl会报错：$proxy0不能转换为MyServiceImpl。</p>

<p>&emsp;&emsp;<strong>二、cglib实现</strong></p>

<p>``` java MyAdvice.java</p>

<p>//这个是通知类</p>

<p>class MyAdvice implements MethodInterceptor {</p>

<pre><code>@Override
public Object intercept(Object object, Method method, Object[] args,
        MethodProxy methodProxy) throws Throwable {

    System.out.println(method.getName() + "执行之前..............");
    Object result = methodProxy.invokeSuper(object, args);
    System.out.println(method.getName() + "执行之后..............");
    return result;
}
</code></pre>

<p>}</p>

<p>```</p>

<p>&emsp;&emsp;产生代理的测试类：</p>

<p>``` java</p>

<pre><code>    Enhancer eh = new Enhancer();
    eh.setSuperclass(NoInterfaceService.class);
    //如果不需要通知代码
    //eh.setCallback(NoOp.INSTANCE);
    eh.setCallback(new MyAdvice());

    NoInterfaceService ns = (NoInterfaceService)eh.create();
    ns.hello();
</code></pre>

<p>```</p>

<p>&emsp;&emsp;上面的代理，可以对无接口对象实现代理，有接口的当然也是不存在问题的。</p>

<p>&emsp;&emsp;<strong>三、spring代理配置实现</strong></p>

<p>``` java LoggerAdvice.java</p>

<p>public class LoggerAdvice implements MethodInterceptor {</p>

<pre><code>@Override
public Object invoke(MethodInvocation mi) throws Throwable {
    System.out.println(mi.getMethod().getName() + "开始执行！！！");
    Object result = mi.proceed();
    System.out.println(mi.getMethod().getName() + "执行完毕！！！");
    return result;
}
</code></pre>

<p>}
```</p>

<p>&emsp;&emsp;配置文件：</p>

<p>``` xml</p>

<pre><code>&lt;!-- 代理对象 --&gt;
&lt;bean id="myServiceProxy"
    class="org.springframework.aop.framework.ProxyFactoryBean"
&gt;
    &lt;property name="target" ref="myService"&gt;&lt;/property&gt;
    &lt;property name="interceptorNames"&gt;
        &lt;list&gt;
            &lt;value&gt;loggerAdvice&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>

<p>```</p>

<p>&emsp;&emsp;测试代码：</p>

<p>``` java</p>

<p>BeanFactory bf</p>

<pre><code>    = new ClassPathXmlApplicationContext("beans.xml");

    IMyService1 ms1 = (IMyService1)bf.getBean("myServiceProxy");
    ms1.biz1();

    IMyService2 ms2 = (IMyService2)bf.getBean("myServiceProxy");
    ms2.biz2();
</code></pre>

<p>```</p>

<p>&emsp;&emsp;如果被代理对象实现了接口，默认情况下spring会使用jdk动态代理，因此，如果代把上面取到的对象强转为MyServiceImpl会报错：$proxy0不能转换为MyServiceImpl，但转换为其它所实现的两个接口，都不会存在问题。</p>

<p>&emsp;&emsp;我们也可以通过proxyInterfaces指定，代理哪个接口（默认情况下，会自动代理该类所实现的所有接口）。</p>

<p>``` xml</p>

<pre><code>    &lt;property name="proxyInterfaces"&gt;
        &lt;list&gt;
            &lt;value&gt;com.my.service.IMyService1&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
</code></pre>

<p>```</p>

<p>&emsp;&emsp;如果被代理的类没有实现接口，spring会自动使用cblib作为底层代理实现，如果你的lib下没有该jar包，系统会报错。</p>

<p>&emsp;&emsp;当然，在被代理的类有接口的情况下，你也可以通过配置，强制使用cglib代理，配置如下：</p>

<p>``` xml</p>

<p><property name="proxyTargetClass" value="true"></property></p>

<p>```</p>

<p>&emsp;&emsp;以下代码中可以看出，代理对象可直接强转为实现类：</p>

<p>``` java</p>

<p>NoInterfaceService is =  (NoInterfaceService)bf.getBean(&ldquo;myServiceProxy&rdquo;);
is.hello();</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[事务中的并发处理]]></title>
    <link href="http://yanyaner.com/blog/2013/06/27/hibernate-transaction/"/>
    <updated>2013-06-27T15:18:00+08:00</updated>
    <id>http://yanyaner.com/blog/2013/06/27/hibernate-transaction</id>
    <content type="html"><![CDATA[<p>&emsp;&emsp;在项目中，事务是不可缺少的，但是如何在一个业务事务中正确的处理并发，确不是一件容易的事。下面，我通过一个简单的例子来说明这个问题，并给出一些解决办法。</p>

<p>&emsp;&emsp;这个例子也许并不恰当，但足够简单：宠物&mdash;&ndash;>宠物日记，一对多双向关联，持久层使用hibernate框架实现。</p>

<p>``` java Epet.java
public class Epet{</p>

<pre><code>private int id;
private String name;
private String password;

//日记集合
private Set&lt;Diary&gt; diarys = new HashSet&lt;Diary&gt;();
//日记的总积分，为了提高效率而设置的冗余字段
private int integralCount;
</code></pre>

<p>}
```</p>

<p>``` java Diary.java
public class Diary{</p>

<pre><code>private int id;
private String title;
private Date publishDate;
//日记积分
private int integral;
//日记所属宠物
private Epet epet;
</code></pre>

<p>}
```</p>

<p>&emsp;&emsp;假设为了提高效率，我们在epet对象中，添加了该宠物所有日记的总积分，我们现在需要一个业务方法，用来计算宠物的总积分，并持久化到数据库中。</p>

<p>&emsp;&emsp;实现代码如下：</p>

<p>``` java</p>

<pre><code>    Epet e = (Epet)ht.get(Epet.class, epetId, LockMode.UPGRADE);
    int count = 0;
    for (Iterator&lt;Diary&gt; its = e.getDiarys().iterator();its.hasNext();) {
        count = count + its.next().getIntegral();
    }
    e.setIntegralCount(count);

    epetDao.updateEpet(e);
</code></pre>

<p>```</p>

<p>&emsp;&emsp;上面的代码，考虑到要修改总积分，首先对读取的epet加锁，然后取出每一篇日记，累加积分，最后更新宠物对象，通过观察输出的sql语句，我们会发现这段代码有问题，并不能保存业务约束的完整性。系统对日记的查询，并没有加锁，也就是说，这段时间内，完全有可能存在其它事务修改日志积分，或添加、删除日记的情况。</p>

<p>&emsp;&emsp;也许你会说，把该方法的数据库隔离级别设置为ISOLATION_REPEATABLE_READ，但经过我的测试，这个级别在mysql,orcle中也是存在问题的，原因是：mysql的可重复读是通过内部缓存实现，也说是说，你在事务中查完的数据，它会缓存起来，事务中再说，返回的是缓存中的数据，在这个过程中，其它事务是可以成功修改数据的；oracle是不支持可重复读的，所以，设置隔离级别不靠谱。</p>

<p>&emsp;&emsp;那我们把代码改进一下，自己来加锁，代码如下：</p>

<p>``` java</p>

<pre><code>    ht.execute(new HibernateCallback() {    
        @Override
        public Object doInHibernate(Session session) throws HibernateException,
                SQLException {

            Epet e = (Epet)ht.get(Epet.class, epetid);

            List&lt;Diary&gt; ds = session.createQuery("from Diary d where d.epet.id = ?")
            .setParameter(0, 1).setLockMode("d", LockMode.UPGRADE)
            .list();
            int count = 0;
            for (Diary d : ds) {
                count = count + d.getIntegral();
            }
            e.setIntegralCount(count);
            epetDao.updateEpet(e);

            return null;
        }
    });
</code></pre>

<p>```</p>

<p>&emsp;&emsp;注意setLockMode(&ldquo;d&rdquo;, LockMode.UPGRADE)部分的代码，这段代码可以保证在事务期间，没有人修改日记积分，因此，从业务上说，在事务执行这段期间，统计的总积分是正确的。</p>

<p>&emsp;&emsp;用悲观锁把部分数据锁定，在项目中并不建议使用，因为这样会在并发环境中带来性能问题。</p>

<p>&emsp;&emsp;再次改进，在Epet对象和Diary对象中，都加上version字段，使用乐观锁控制事务，代码如下：</p>

<p>``` java</p>

<pre><code>    Epet e = (Epet)ht.get(Epet.class, epetId);
    int count = 0;
    for (Iterator&lt;Diary&gt; its = e.getDiarys().iterator();its.hasNext();) {
        count = count + its.next().getIntegral();
    }
    e.setIntegralCount(count);

    epetDao.updateEpet(e);

    //再次查询状态每个diary的状态，看是否被它人修改过
    for (Iterator&lt;Diary&gt; its = e.getDiarys().iterator();its.hasNext();) {
        Diary d = its.next();
        int ver = d.getVersion();
        //注意，在mysql中，要想成功refresh得到最新数据，必须设置隔离级别是ISOLATION_READ_COMMITTED
        ht.refresh(d);
        if (d.getVersion() != ver) {
            throw new RuntimeException("订单状态已被改变！");
        }
    }
</code></pre>

<p>```</p>

<p>&emsp;&emsp;上面的这段代码在最后再次检查是否有人修改了日记，如果日记版本号与之前一致，则提交事务，但是，这段代码也并非没有问题，因为在事务最后提交的过程中，还是会存在并发修改日记的情况，所以，业务事务的处理非常麻烦，要考虑到业务规则的满足，并不是我们想像的那么简单。</p>

<p>&emsp;&emsp;从业务上来讲，我们只关心在我的事务中，日记的积分不被它人修改，因此，上面的代码还可以再次修改，只关注积分值，减少并发冲突问题，代码如下：</p>

<p>``` java</p>

<pre><code>     //再次查询状态每个diary的状态，看是否被它人修改过
    for (Iterator&lt;Diary&gt; its = e.getDiarys().iterator();its.hasNext();) {
        Diary d = its.next();
        int integral = d.getIntegral();
        //注意，在mysql中，要想成功refresh得到最新数据，必须设置隔离级别是ISOLATION_READ_COMMITTED
        ht.refresh(d);
        if (d.getIntegral() != integral) {
            throw new RuntimeException("订单状态已被改变！");
        }
</code></pre>

<p>```</p>

<p>&emsp;&emsp;红色字体部分，取日记的积分，只是为了减少并发冲突出现的可能性，但依然没办法保证业务约束完整，要想保存业务约束及规则的满足，最好的办法是使用富血模型去做，对日记的任何操作，都必须通过它的聚合根，也就是epet对象去实现，示例代码如下：</p>

<p>&emsp;&emsp;以下方法都是写在Epet对象中的：</p>

<p>``` java</p>

<pre><code>/**
 * 重新计算积分
 */
public void reCalculateIntegral() {
    int count = 0;
    for (Iterator&lt;Diary&gt; its = this.getDiarys().iterator();its.hasNext();) {
        count = count + its.next().getIntegral();
    }
    this.setIntegralCount(count);
}

/**
 * 添加日记
 */  

 public void addDiary(Diary d) {
    this.getBaseDao().save(d);
    this.getDiarys().add(d);
    d.setEpet(this);
    reCalculateIntegral();
    this.getBaseDao().update(this);
}

/**
 * 修改日记
 */
public void updateDiary(Diary d) {
    this.getBaseDao().update(d);
    reCalculateIntegral();
    this.getBaseDao().update(this);
}
</code></pre>

<p>```</p>

<p>&emsp;&emsp;而对应的facade中的代码如下（注意：事务是控制在facade上的哦）：</p>

<p>``` java</p>

<p>  //增删改日记(事务控制在此，乐观锁保证业务约束的完整性)</p>

<pre><code>public void addDiary(int petId, Diary d) {
    Epet e = (Epet)ht.get(Epet.class, petId);
    e.addDiary(d); 
}

public void updateDiary(Diary d){
    //这里再次按id查询epet，无性能损耗，因为有缓存
    Epet e = (Epet)ht.get(Epet.class, d.getEpet().getId());
    e.updateDiary(d);
}
</code></pre>

<p>```</p>

<p>&emsp;&emsp;从上面的代码可以看到，所有对日记的修改，都必须通过聚合根epet对象，而epet上是有基于version的乐观锁的，因些，最后的这部分代码基本满足了我们的业务约束及事务的并发控制。</p>

<p>&emsp;&emsp;还有一种情况，如果在我们这个场景中，如果事务的失败对用户来说是不能容忍的，比如：添加一篇宠物日记会花费用户30分钟的录入时间，如果最终事务失败，用户无疑非常的沮丧，这种情况该如何应对了？接下来，我给大家继续讲解离线事务锁的示例。</p>

<p>&emsp;&emsp;先看乐观离线事务锁，这种锁不是用来解决事务失败而用户不能接受的情况，而是一个超长的业务事务，比如30分钟，而在最终提交事务时，系统要检测到这种冲突，下面是乐观离线锁的实现示例代码：</p>

<p>``` java</p>

<pre><code>    //长事务，离线乐观锁
    Epet e = ss.getEpetById(1);
    Map&lt;String, Epet&gt; session = new HashMap&lt;String, Epet&gt;();

    session.put("epet_in_http_session", e);
    //给用户发回响应resopnse

    //长时间的编辑
    Thread.sleep(10000);

    //最后一步，提交
    //这里不要从数据库中重查，而是直接使用先前保存的那个，可能是httpsession，也可能是序列化至外部
    Epet e2 = session.get("epet_in_http_session");
    e2.setName("小强22");
    //重新保存，version乐观锁会保证并发冲突，如果出现冲突，你会得到类似org.hibernate.StaleObjectStateException: Row was updated or deleted by another transaction (or unsaved-value mapping was incorrect)的错误信息。
    ss.updateEpet(e2);
</code></pre>

<p>```</p>

<p>&emsp;&emsp;如果用户对事务冲突不可容忍，我们就只能使用悲观离线锁，本质上来就，就是用户自己去实现对象的锁定，代码如下：</p>

<p> &emsp;&emsp;先在epet中加上这三个新的属性：</p>

<p>``` java</p>

<pre><code>//锁定标示： true已锁定，false:未锁定
private boolean locked;
//锁定者
private String locker;
//锁定时间
private Date lockedTime;
</code></pre>

<p>```</p>

<p>&emsp;&emsp;epet中再加上和悲观锁相关的几个方法：</p>

<p>``` java</p>

<p>   /**</p>

<pre><code> * 锁定对象
 * @param locker
 */
public void lockEpet(String locker) {
    if (this.isLockedBy(locker)) {
        return;
    }
    if (this.isLocked()) {
        throw new RuntimeException("该对象已被"+this.getLocker()+"被锁定！");
    }
    this.setLocked(true);
    this.setLocker(locker);
    this.setLockedTime(new Date());
    getBaseDao().update(this);
}

/**
 * 解锁对象
 * @param locker
 */
public void unLockEpet(String locker) {
    if (!this.getLocker().equals(locker)) {
        throw new RuntimeException("解锁失败：解铃还需系铃人！");
    }
    this.setLocked(false);
    getBaseDao().update(this);
}
/**
 * 检测对象是否被某人锁定
 * @param locker
 * @return
 */
public boolean isLockedBy(String locker) {
    if (locker.equals(this.getLocker())  &amp;&amp;  this.isLocked()) {
        return true;
    }
    return false;
}
</code></pre>

<p>```</p>

<p>&emsp;&emsp;在业务类中，我们也需要加上几个类似的方法实现，事务也控制在这个上面：</p>

<p>``` java</p>

<pre><code>public void lockEpet(int epetid, String locker) {
    Epet e = (Epet)ht.get(Epet.class, epetid, LockMode.UPGRADE);
    e.lockEpet(locker);
}

public void unLockEpet(int epetid, String locker) {
    Epet e = (Epet)ht.get(Epet.class, epetid, LockMode.UPGRADE);
    e.unLockEpet(locker);    
}
</code></pre>

<p>```</p>

<p>&emsp;&emsp;在悲观离线锁的使用过程中要特别小心，做某些业务操作时，一定要确保已经成功获得了锁，写相关功能的程序员必须要清楚地知道这一点，因为，这种锁是程序员自己去实现的。</p>

<p>&emsp;&emsp;这种悲观锁的实现中，还需要防止死锁，比如：对多个对象的锁定，还有就是，需要某种检测机制，把超过某个业务时间的锁释放。</p>

<p>&emsp;&emsp;要想解决好事务的并发处理非常的不容易，因为这个问题本来就是和业务领域密切相关的一个问题，需要我们从业务方面去分析解决。转换为一对多，关系越简单越好。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hibernate多对多查询]]></title>
    <link href="http://yanyaner.com/blog/2013/06/17/hibernate-many-to-many/"/>
    <updated>2013-06-17T15:18:00+08:00</updated>
    <id>http://yanyaner.com/blog/2013/06/17/hibernate-many-to-many</id>
    <content type="html"><![CDATA[<p>&emsp;&emsp;在hibernate中，一般情况下要减少多对多关系的存在，主要原因是性能。hibernater中的多对多是采用的内存分页，如果你的数据量比较大，就很杯具了。如果遇到多对多，我们可以为中间表建立新的对象，从而转换为多对一关系。</p>

<p>&emsp;&emsp;下面大家看一个用户和用户组多对多的hql分页写法。</p>

<p>``` java</p>

<pre><code>    //下面查到的就是当某一页的数据，hibernate使用的是内在分页，使用distinct由hibernate去除重复

      String hql = " select distinct(u) from GameUser u left join fetch " +
                "u.groups g where g.name like '%组%'";

        List&lt;GameUser&gt; gus = session.createQuery(hql)
                .setFirstResult(0).setMaxResults(1).list();
</code></pre>

<p>```</p>

<p>&emsp;&emsp;在JPA规范中，你可以看到：</p>

<p>&emsp;&emsp;&ldquo;The effect of applying setMaxResults or setFirstResult to a query involving fetch joins over collections is undefined&rdquo;</p>

<p>&emsp;&emsp;如果细心观察过日志，你也会发现hibernate有如下输出：</p>

<p>&emsp;&emsp;WARNING: firstResult/maxResults specified with collection fetch; applying in memory!</p>

<p>&emsp;&emsp;这就说明，使用了left join的语句无法再使用数据库分页，和多对多关系，没有必然联系。</p>

<p>``` java</p>

<pre><code>       //这是统计总记录条数的hql，需要使用in
        String hql4cont = "select count(*) from GameUser gu where gu.id in (select u.id from GameUser u left join  " +
                "u.groups g where g.name like '%组%')";

        Number count = (Number)session.createQuery(hql4cont).uniqueResult();
</code></pre>

<p>```</p>

<p>&emsp;&emsp;那么，如何将上面的多对多关系改造成一对多关系呢，当然是要对中间表建立对象了，如下：</p>

<p>&emsp;&emsp;用户对象：</p>

<p>``` java GameUser.java
@Entity
@Table(name=&ldquo;t_gameuser&rdquo;)
public class GameUser {</p>

<pre><code>@Id
@GeneratedValue(strategy=GenerationType.IDENTITY)
@Column(name="pk_id")
private int id;

@Column(name="f_name")
private String name;


@OneToMany(mappedBy="user",cascade=CascadeType.ALL, fetch=FetchType.LAZY)
@JoinColumn(name="fk_user_id")
@BatchSize(size=2)
private Set&lt;UserInGroup&gt; userInGroupSet = new HashSet&lt;UserInGroup&gt;();
</code></pre>

<p>```</p>

<p>&emsp;&emsp;用户组对象：</p>

<p>``` java Group.java
@Entity
@Table(name=&ldquo;t_group&rdquo;)
public class Group {</p>

<pre><code>@Id
@GeneratedValue(strategy=GenerationType.IDENTITY)
@Column(name="pk_id")
private int id;

@Column(name="f_name")
private String name;

@OneToMany(mappedBy="group")
@JoinColumn(name="fk_group_id")
private Set&lt;UserInGroup&gt; userInGroupSet = new HashSet&lt;UserInGroup&gt;();
</code></pre>

<p>```</p>

<p>&emsp;&emsp;中间对象（中间对象中引用对象加载方式，请大家设置为EAGER以提升系统查询效率,cascade须设置为save_update）：</p>

<p>``` java UserInGroup.java
@Entity
@Table(name=&ldquo;t_user_group&rdquo;)
public class UserInGroup {</p>

<pre><code>@Id
@GeneratedValue(strategy=GenerationType.IDENTITY)
@Column(name="pk_id")
private int id;

@ManyToOne(fetch=FetchType.EAGER)

@Cascade(value={org.hibernate.annotations.CascadeType.SAVE_UPDATE})
@JoinColumn(name="fk_user_id")
private GameUser user;


@ManyToOne(fetch=FetchType.EAGER)

@Cascade(value={org.hibernate.annotations.CascadeType.SAVE_UPDATE})
@JoinColumn(name="fk_group_id")
private Group group;
</code></pre>

<p>```</p>

<p>&emsp;&emsp;大家注意一下，中间对象的主键id实际并无意义，添加上只是为了映射方便，你也可以将两外键建成联合主键（但似乎jap注解方式不支持这种配置， xml中倒是可以做到）。</p>

<p>&emsp;&emsp;最后看分页查询怎么写：</p>

<p>``` java</p>

<p>String hql = &ldquo;select distinct(uig.user) from UserInGroup uig &rdquo; +</p>

<pre><code>                "where uig.group.name like '%组%' and uig.user.name like '%%'";


       List&lt;GameUser&gt; gus = session.createQuery(hql)
        .setFirstResult(0).setMaxResults(100).list();
        for (GameUser gu : gus) {
            System.out.println(gu.getName());
            System.out.println(gu.getUserInGroupSet().size());
        }
</code></pre>

<p>```</p>

<p>&emsp;&emsp;这个时候，将是纯正的数据库级分页，很好地满足了我们的要求。</p>

<p>``` java</p>

<pre><code>      String hql4cont = "select distinct(uig.user.id) from UserInGroup uig " +
                "where uig.group.name like '%组%' and uig.user.name like '%%'";


        Number count = (Number)session.createQuery(hql4cont).list().size();
</code></pre>

<p>```</p>

<p>&emsp;&emsp;统计总记录数的hql，就像上面这个写法，就ok了，因为只取的id，没有创建完整的对象，性能不存在大的问题。</p>

<p>&emsp;&emsp;但是大家要注意，这个时候我们没有用left join之类的加载方式，意味着查出来的对象，其中的集合属性没有初始化，如果在后续业务中需要访问集合属性，hibernate会再次去查询加载，为了性能考虑，我们一般会加上@BatchSize注解为提高集合加载效率，如果不写@BatchSize，默认是一条一条加载的，写上之后，会有类似下面的sql出现，？的最大个数，就是BatchSize设定的大小：</p>

<p>``` java
select</p>

<pre><code>    useringrou0_.fk_user_id as fk3_1_,
    useringrou0_.pk_id as pk1_1_,
    useringrou0_.pk_id as pk1_9_0_,
    useringrou0_.fk_group_id as fk2_9_0_,
    useringrou0_.fk_user_id as fk3_9_0_ 
from
    t_user_group useringrou0_ 
where
    useringrou0_.fk_user_id in (
        ?, ?
    )
</code></pre>

<p>```</p>

<p>&emsp;&emsp;在一般的项目中，我们把@BatchSize设置界面每页显示记录数一致即可,多对多转换为一对多，关系越简单越好。</p>
]]></content>
  </entry>
  
</feed>
