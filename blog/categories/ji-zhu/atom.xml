<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[☺分类☺：技术 | 刘江华的博客]]></title>
  <link href="http://yanyaner.com/blog/categories/ji-zhu/atom.xml" rel="self"/>
  <link href="http://yanyaner.com/"/>
  <updated>2014-01-23T16:32:51+08:00</updated>
  <id>http://yanyaner.com/</id>
  <author>
    <name><![CDATA[冰雨]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[关于servlet规范中的几个设计模式解析]]></title>
    <link href="http://yanyaner.com/blog/2014/01/22/servlet-container-pattern/"/>
    <updated>2014-01-22T12:18:00+08:00</updated>
    <id>http://yanyaner.com/blog/2014/01/22/servlet-container-pattern</id>
    <content type="html"><![CDATA[<p>&emsp;&emsp;本文属于入门类型文章，给大家简单介绍一下javax.servlet中用到的几个设计模式。</p>

<h3>先看职责链模式</h3>

<p>&emsp;&emsp;这个模式的应用就是大家所熟悉的filter过滤器,演示代码如下：</p>

<p>``` java  Filter.java
package com.my.filter;</p>

<p>/<em>*
 * 定义每一个处理者的通用行为，即对传入的参数进行处理
 * @author ljh
 *
 </em>/
public interface Filter {</p>

<pre><code>public void doFilter(String param, FilterChain fc);
</code></pre>

<p>}</p>

<p>```</p>

<p>&emsp;&emsp;接下来定义一个职责链接口，以规范形为（当然，这个接口也可以不定义，直接给出实现类即可）。</p>

<p>``` java  FilterChain.java
package com.my.filter;</p>

<p>/<em>*
 * 过滤器链接口定义
 * @author ljh
 *
 </em>/
public interface FilterChain {</p>

<pre><code>/**
 * 将请求传给下一个处理者
 * @param param
 */
public void doFilter(String param);
</code></pre>

<p>}</p>

<p>```</p>

<p>&emsp;&emsp;一个具体的责任链实现（注：这个通常是由服务器去实现的，比如tomcat），里面包含了所有的要承担处理责任的处理者（也就是过滤器）。</p>

<p>``` java ConcreteFilterChain.java
package com.my.server;</p>

<p>import java.util.ArrayList;
import java.util.List;</p>

<p>import com.my.biz.Processor;
import com.my.filter.Filter;
import com.my.filter.FilterChain;
/<em>*
 * 一个职责链具体实现
 * @author ljh
 *
 </em>/
public class ConcreteFilterChain implements FilterChain {</p>

<pre><code>//链集合
private List&lt;Filter&gt; filters = new ArrayList&lt;Filter&gt;();
//初始已处理过滤器下标
private int processIndex = -1;

public ConcreteFilterChain(List&lt;Filter&gt; filters) {
    this.filters = filters;
}

@Override
public void doFilter(String param) {
    //处理的过滤器下标
    processIndex = processIndex + 1;

    if (processIndex &gt;= filters.size()) {
        Processor p = new Processor();
        p.working(param);
    } else {
        filters.get(processIndex).doFilter(param, this);
    }

}

/**
 * 返回一个新的FilterChain（这个方法保留待用）
 * 因为在多线程环境下，每一个请求会有自己的processIndex
 * 这个新建的processIndex将设置为初始值-1，表示还没有进入任何一个过滤器
 * @return
 */
public FilterChain cloneFilterChain() {
    return new ConcreteFilterChain(filters);
}
</code></pre>

<p>}
```</p>

<p>&emsp;&emsp;好了，到这里，服务器上该做的事都已经做完，来看看程序员要做的事吧。<!--more-->我们先写一个业务处理类，模拟最终要进行的操作，如下：</p>

<p>``` java Processor.java
package com.my.biz;</p>

<p>public class Processor {</p>

<pre><code>public void working(String param) {

    System.out.println("最后的业务执行与处理....:" + param);
}
</code></pre>

<p>}
```</p>

<p>&emsp;&emsp;在working处理消息前，我定义了两个过滤器。在第一个过滤器中，进行了参数检测，如果参数是"abc"，将终止后续业务的执行。同时，两个过滤器都对消息进行了处理，在消息中添加了自己的东西。</p>

<p>``` java MyFilter1.java与MyFilter2.java
package com.my.concretefilter;</p>

<p>import com.my.filter.Filter;
import com.my.filter.FilterChain;
/<em>*
 * 第一个过滤器,会对消息进行处理
 * @author ljh
 *
 </em>/
public class MyFilter1 implements Filter {</p>

<pre><code>@Override
public void doFilter(String param, FilterChain fc) {

    System.out.println("进入MyFilter1的处理 ....");
    if ("abc".equals(param)) {
        System.out.println("发现参数是abc，终止执行!!!!");
        return;
    }
    fc.doFilter(param + "[●modify by MyFilter1●]");
    System.out.println("离开MyFilter1的处理 ....");

}
</code></pre>

<p>}</p>

<p>/<em>*
 * 第一个过滤器,会对消息进行处理
 * @author ljh
 *
 </em>/
public class MyFilter2 implements Filter {</p>

<pre><code>@Override
public void doFilter(String param, FilterChain fc) {

    System.out.println("进入MyFilter2的处理 ....");
    fc.doFilter(param + "[★modify by MyFilter2★]");
    System.out.println("离开MyFilter2的处理 ....");

}
</code></pre>

<p>}
```</p>

<p>&emsp;&emsp;接下来又是服务器上的处理代码了，我直接写出简单示例，生产环境中的服务器，肯定是读取web.xml反射创建过滤器对象。</p>

<p>``` java Server.java</p>

<pre><code>    //链集合(读取配置文件，反射创建filter，并加入过滤器链)
    List&lt;Filter&gt; filters = new ArrayList&lt;Filter&gt;();
    filters.add(new MyFilter1());
    filters.add(new MyFilter2());
    FilterChain fc = new ConcreteFilterChain(filters);

    //派发请求
    fc.doFilter("abcd");
</code></pre>

<p>```</p>

<p>&emsp;&emsp;输出的结果是如下，和我们的预期相同。</p>

<p><code>
进入MyFilter1的处理 ....
进入MyFilter2的处理 ....
最后的业务执行与处理....:abcd[●modify by MyFilter1●][★modify by MyFilter2★]
离开MyFilter2的处理 ....
离开MyFilter1的处理 ....
</code></p>

<p>&emsp;&emsp;如果用户的输入参数是abc，即fc.doFilter(&ldquo;abc&rdquo;);，执行输出是：</p>

<p><code>
进入MyFilter1的处理 ....
发现参数是abc，终止执行!!!!
</code></p>

<p>&emsp;&emsp;这就有点类似于权限检测的filter一样，呵呵。</p>

<h3>另一个是监听器（观察者模式）</h3>

<p>&emsp;&emsp;通过监听器，容器会把我们感兴趣的事告诉我们，当然前提是我们必须先向服务器注册。监听器使用了观察者模式。下面我定义了一个会话监听器。</p>

<p>``` java HttpSessionListener.java</p>

<p>package com.my.listener;
/<em>*
 * 会话监听器
 * @author Administrator
 *
 </em>/
public interface HttpSessionListener {</p>

<pre><code>public void sessionCreated(String  event);
public void sessionDestroyed(String  event);
</code></pre>

<p>}</p>

<p>```</p>

<p>&emsp;&emsp;接下来由程序员定义自己的监听器，并在配置文件中进行配置。</p>

<p>``` java MyHttpSessionListener1.java和MyHttpSessionListener2.java
package com.my.concretelistener;</p>

<p>import com.my.listener.HttpSessionListener;</p>

<p>/<em>*
 * 我的会话监听器1
 * @author Administrator
 *
 </em>/
public class MyHttpSessionListener1 implements HttpSessionListener {</p>

<pre><code>private String myName = "监听器1";

@Override
public void sessionCreated(String event) {

    System.out.println(myName + " 监听到创建事件：" + event);

}

@Override
public void sessionDestroyed(String event) {

    System.out.println(myName + "监听到销毁事件：" + event);

}
</code></pre>

<p>}</p>

<p>/<em>*
 * 我的会话监听器2
 * @author Administrator
 *
 </em>/
public class MyHttpSessionListener2 implements HttpSessionListener {</p>

<pre><code>private String myName = "监听器2";

@Override
public void sessionCreated(String event) {

    System.out.println(myName + " 监听到创建事件：" + event);

}

@Override
public void sessionDestroyed(String event) {

    System.out.println(myName + "监听到销毁事件：" + event);

}
</code></pre>

<p>}</p>

<p>```</p>

<p>&emsp;&emsp;服务器上的处理代码如下：</p>

<p>``` java Server.java</p>

<pre><code>    //监听器对队
    HttpSessionListener[] listeners = new HttpSessionListener[2];
    listeners[0] = new MyHttpSessionListener1();
    listeners[1] = new MyHttpSessionListener2();

    //当容器中发生事件的时候，进行通知
    //比如：创建事件
    System.out.println("服务器发生创建事件！");
    for (HttpSessionListener listener : listeners) {
        listener.sessionCreated(new Date() + "创建事件发生了！" );
    }
</code></pre>

<p>```</p>

<p>&emsp;&emsp;下面就是运行的结果，我们可以发现，这就是一个观察者模式的标准应用。</p>

<p>```</p>

<p>服务器发生创建事件！
监听器1 监听到创建事件：Thu Jan 23 15:34:14 CST 2014创建事件发生了！
监听器2 监听到创建事件：Thu Jan 23 15:34:14 CST 2014创建事件发生了！</p>

<p>```</p>

<h3>最后，给大家说一下包装器</h3>

<p>&emsp;&emsp;包装器，也叫装饰器，这个模式的本意是在不改变原有类的情况下，增强类的功能（包括添加行为或添加状态）。</p>

<p>``` java  Request.java</p>

<p>package com.my.wrapper;
/<em>*
 * 抽象请求对象
 * @author ljh
 *
 </em>/
public interface Request {</p>

<pre><code>//得到内容
public String getContent();
</code></pre>

<p>}</p>

<p>```</p>

<p>``` java OriginalRequest.java</p>

<p>package com.my.wrapper;</p>

<p>/<em>*
 * 原始请求
 * @author ljh
 *
 </em>/
public class OriginalRequest implements Request {</p>

<pre><code>private String content;

public OriginalRequest(String content) {
    this.content = content;
}

@Override
public String getContent() {
    // TODO Auto-generated method stub
    return content;
}
</code></pre>

<p>}</p>

<p>```</p>

<p>``` java RequestWrapper.java</p>

<p>package com.my.wrapper;</p>

<p>/<em>*
 * 包装对象，其它的包装类，都从这个类继承
 * @author ljh
 *
 </em>/
public class RequestWrapper implements Request {</p>

<pre><code>private Request request;



public RequestWrapper(Request request) {
    super();
    this.request = request;
}



@Override
public String getContent() {
    //此处暂时不做任何处理，直接返回
    String content = request.getContent();
    return content;
}
</code></pre>

<p>}</p>

<p>```</p>

<p>&emsp;&emsp;上面三个类，都是由服务器端已经定义好的（也就是先把基本的架子搭起来）。下面这个方法才是我最终要执行的一个目标业务方法。</p>

<p>``` java</p>

<pre><code>/**
 * 此访求接收request接口类型，并感知不到对象已被包装
 * @param req
 */
public static void display(Request req) {
    System.out.println(req.getContent());
}
</code></pre>

<p>```</p>

<p>&emsp;&emsp;接下来，大家看看我实现了一个对敏感关键词进行处理的包装器：</p>

<p>``` java MyRequestWrapper.java</p>

<p>package com.my.concretewrapper;</p>

<p>import com.my.wrapper.Request;
import com.my.wrapper.RequestWrapper;</p>

<p>public class MyRequestWrapper extends RequestWrapper {</p>

<pre><code>public MyRequestWrapper(Request request) {
    super(request);
}

//添加行为或改变现在行为，或新的属性

//比如：我下面进行敏感字符过滤
@Override
public String getContent() {
    String content = super.getContent();
    content = content.replaceAll("江泽民", "***");
    return content;
}
</code></pre>

<p>}</p>

<p>```</p>

<p>&emsp;&emsp;最后是对目标方法的调用了，输入结果是：我是国家主席***。</p>

<p>```</p>

<pre><code>    Request req = new MyRequestWrapper(new OriginalRequest("我是国家主席江泽民"));
    //目标方法的调用
    display(req);
</code></pre>

<p>```</p>

<p>&emsp;&emsp;好，此篇文章就到此吧，2014春节马上就到了，假期临近，一切都显示得非常冷清，很多人已经心不在焉。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为你的项目加入Hudson持续集成]]></title>
    <link href="http://yanyaner.com/blog/2013/12/26/hudson-ci/"/>
    <updated>2013-12-26T15:18:00+08:00</updated>
    <id>http://yanyaner.com/blog/2013/12/26/hudson-ci</id>
    <content type="html"><![CDATA[<p><span class='caption-wrapper'><img class='caption' src='/uploads/2013/12/hudson-logo.jpg' width='' height='' title=''><span class='caption-text'></span></span></p>

<p>&emsp;&emsp;Hudson是一个使用非常广泛的持续集成CI服务器，大家可以到<a href="http://hudson-ci.org/">Hudson官网</a>上了解更多内容。我们把hudson叫做持续集成服务器，就像官方的描述：Hudson is an extensible Continuous Integration Server，在采用敏捷开发流程的项目中CI几乎是一个必备的工具。</p>

<p>&emsp;&emsp;为什么取hudson这个名字，我想这个系统应该和项目管理密切相关，在软件工程的项目启动流程中，有一种叫哈德森式项目启动方式，说的是要尽早启动一个项目，尽早检测项目后期的资源是否齐备，更早发现一些潜在的风险。</p>

<p>&emsp;&emsp;我们可以试想一下这样的场景：开发团队中，每个成员都在努力完成自己的功能模块，在接近某个迭代周期终点时开始整合，然后再交由测试人员，但对于敏捷开发流程的项目，这似乎有点太慢了。测试人员能否尽早地参与测试？开发成员能否每天看到项目的整体效率、成果?管理人员能否了解每天项目的状况（健康情况）?CI工具可以帮助我们做到这一点。</p>

<p>&emsp;&emsp;简单点来说，CI可以自动化地帮助我们从SCM中check out代码，编译、运行测试、打包、部署到服务器一条龙服务，这样一来，我们就可以及时了解项目的整体状态，比如：编译失败，测试失败，部署后测试人员发现bug等等。我们随时都可以得到可以运行的软件，这对团队成员的信心有很大的鼓舞。</p>

<p>&emsp;&emsp;CI的可供选择软件比较多，除了Hudson外，还有apache continuum等，这些CI同样也具备上面的这些能力，相对来说，Hudson配置起来更为简单，也是更为老牌的CI系统。</p>

<p>&emsp;&emsp;啰嗦了这么多，开始正式的内容吧。先从hudson官网上下载程序包hudson.war（一般都是3.0以上的版本哦），把这个war包直接放在tomcat的webapps目录，启动tomcat即可完成安装，足够简单吧。但要提醒各位的是，最好是下载集成版本的Hudson(即3.0.0-bundled)，这个版本集成了常用的插件，就不再需要在线更新安装插件了，另外，这个集成版程序包是经过测试的，不会出现不兼容的情况发生。我当初就是下载的3.1.1，在线安装了maven的插件，但运行时遇到了包不兼容的问题，花费了很多的调试时间，最后下载了这个集成版本，一切正常。</p>

<p>&emsp;&emsp;运行start.bat启动tomcat，打开浏览器，输入地址http : / / localhost:8080/hudson/，就可以看到Hudson首页面，第一次进入有点缓慢，你可以看到有Please wait while Hudson is getting ready to work..Your browser will reload automatically when Hudson is ready.提示信息。等待片刻后后进入主界面，选择新建一个任务，如下图：<!--more--></p>

<p><span class='caption-wrapper'><img class='caption' src='/uploads/2013/12/hudson-new-job1.jpg' width='' height='' title='新建一个hudson工作任务'><span class='caption-text'>新建一个hudson工作任务</span></span></p>

<p>&emsp;&emsp;我们选择【构建一个自由风格的软件项目】，输入任务名称、描述等信息，有几个重要的配置地方，我要给大家着重讲解。</p>

<ul>
<li>配置SCM。我选择的是svn，路径对应到项目的trunk主干目录。如果要输入svn的用户名及密码，请点Update credentials，在弹出的新窗口中填入验证信息。
<span class='caption-wrapper'><img class='caption' src='/uploads/2013/12/hudson-new-job2-scm.jpg' width='' height='' title='Hudson的svn配置界面'><span class='caption-text'>Hudson的svn配置界面</span></span></li>
</ul>


<p>&emsp;&emsp;而我们的svn目录是这样的，要注意的是我们的maven总项目位是car_parents：</p>

<p><span class='caption-wrapper'><img class='caption' src='/uploads/2013/12/svn_struct.jpg' width='' height='' title='svn中的项目目录结构'><span class='caption-text'>svn中的项目目录结构</span></span></p>

<ul>
<li>配置任务的触发条件。找到build triggers中的Build periodically选项，输入符合contab格式的时间表达式，如下图，我配置每个小时构建发布一次（一般可设置为下班前半个小时开始构建，团队要约定在这个时间点前向SCM提交当天的工作，在构建完成后查看阶段成果，如果没有通过构建，通过分析命令行输出，找到问题所在并进行修正）：</li>
</ul>


<p><span class='caption-wrapper'><img class='caption' src='/uploads/2013/12/hudson-build-triggers.jpg' width='' height='' title='配置运行时机'><span class='caption-text'>配置运行时机</span></span></p>

<ul>
<li>配置maven选项，这里请选择Bundled的maven，以免出现运行失败的情况。另请注意，我们的项目中要运行的pom.xml在主项目中，所以大家要点SAdvanced选择，手动设定POM文件所在路径，如下图。</li>
</ul>


<p><span class='caption-wrapper'><img class='caption' src='/uploads/2013/12/Hudson-maven-build.jpg' width='' height='' title='配置maven选择'><span class='caption-text'>配置maven选择</span></span></p>

<ul>
<li>配置自动部署选项。请在Post-build Actions中，找到Deploy war/ear to a container 部分，输入部署到tomcat中的war包所在路径，以及tomcat的管理账号、密码（tomcat管理信息请到tomcat的conf/server.xml中去配置，在此不再复述），如下图所示：</li>
</ul>


<p><span class='caption-wrapper'><img class='caption' src='/uploads/2013/12/hudson-tomcat.jpg' width='' height='' title='配置自动部署选项'><span class='caption-text'>配置自动部署选项</span></span></p>

<ul>
<li>最后保存，即完成该任务的建立。如果你想立即执行一次以观察效果，可以点【立即构建】，系统会出现一个构建进度条，在构建完成后，可以通过点击【  Latest Console output】查看到构建日志，比如观察下面的日志就可以发现构建及部署成功。</li>
</ul>


<p><code>
[INFO] Reactor Summary:
[INFO]
[INFO] car-parents ....................................... SUCCESS [0.313s]
[INFO] framework ......................................... SUCCESS [2.172s]
[INFO] car-core .......................................... SUCCESS [1.360s]
[INFO] car-dao ........................................... SUCCESS [3.969s]
[INFO] car-service ....................................... SUCCESS [4.984s]
[INFO] car-web Maven Webapp .............................. SUCCESS [4.594s]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 17.719s
[INFO] Finished at: Fri Dec 27 11:03:28 CST 2013
[INFO] Final Memory: 52M/126M
[INFO] ------------------------------------------------------------------------
[DEBUG] Closing connection to remote
[DEBUG] Waiting for process to finish
[DEBUG] Result: 0
Deploying C:\Documents and Settings\Administrator\.hudson\jobs\mycar_ms\workspace\trunk\car-web\target\car_ms.war to container Tomcat 6.x Remote
  Redeploying [C:\Documents and Settings\Administrator\.hudson\jobs\mycar_ms\workspace\trunk\car-web\target\car_ms.war]
  Undeploying [C:\Documents and Settings\Administrator\.hudson\jobs\mycar_ms\workspace\trunk\car-web\target\car_ms.war]
  Deploying [C:\Documents and Settings\Administrator\.hudson\jobs\mycar_ms\workspace\trunk\car-web\target\car_ms.war]
[DEBUG] Skipping watched dependency update; build not configured with trigger: mycar_ms #23
Finished: SUCCESS
</code></p>

<p>&emsp;&emsp;经过一段时间的运行后，你可以看到很多的构建历史，如下图所示，我们可以通过图标了解到构建的状态：</p>

<p><span class='caption-wrapper'><img class='caption' src='/uploads/2013/12/Hudson-build-log.jpg' width='' height='' title='Hudson查看构建历史'><span class='caption-text'>Hudson查看构建历史</span></span></p>

<p>&emsp;&emsp;同时，我们的项目也有了睛雨表，你也可理解为这个项目的健康状态。</p>

<p><span class='caption-wrapper'><img class='caption' src='/uploads/2013/12/hudson-icon.jpg' width='' height='' title='Hudson图标示例'><span class='caption-text'>Hudson图标示例</span></span></p>

<p>&emsp;&emsp;暂时写这些吧，以后继续补充。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在项目中使用maven之三--深入细节]]></title>
    <link href="http://yanyaner.com/blog/2013/12/25/maven-project-detail/"/>
    <updated>2013-12-25T15:18:00+08:00</updated>
    <id>http://yanyaner.com/blog/2013/12/25/maven-project-detail</id>
    <content type="html"><![CDATA[<p>&emsp;&emsp;在我们的子项目中，可以使用parent节点继承父项目的pom，如下：</p>

<p>``` xml
<parent></p>

<pre><code>  &lt;groupId&gt;com.ljh.ms&lt;/groupId&gt;
  &lt;artifactId&gt;car-parents&lt;/artifactId&gt;
  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
  &lt;relativePath&gt;../car_parents/pom.xml&lt;/relativePath&gt;
</code></pre>

<p></parent>
```</p>

<p>&emsp;&emsp;这段配置文件中，首先定义了我们要继承的父项目坐标信息，再使用relativePath节点具体指明父POM所在的物理路径（要注意：父项目的packaging类型设定的是pom，而不是jar或war哦）。</p>

<p>&emsp;&emsp;接下来，我贴出dao项目模块的pom文件，内容如下：<!--more--></p>

<p>``` xml pom.xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion></p>

<p>  <groupId>com.ljh.ms</groupId>
  <artifactId>car-dao</artifactId>
  <version>0.0.1-SNAPSHOT</version>
  <packaging>jar</packaging></p>

<p>  <parent></p>

<pre><code>  &lt;groupId&gt;com.ljh.ms&lt;/groupId&gt;
  &lt;artifactId&gt;car-parents&lt;/artifactId&gt;
  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
  &lt;relativePath&gt;../car_parents/pom.xml&lt;/relativePath&gt;
</code></pre>

<p>  </parent></p>

<p>  <name>car-dao</name>
  <url><a href="http://maven.apache.org">http://maven.apache.org</a></url></p>

<p>  <properties></p>

<pre><code>&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
</code></pre>

<p>  </properties></p>

<p>  <dependencies></p>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;com.ljh.ms&lt;/groupId&gt;
    &lt;artifactId&gt;car-core&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<p>  </dependencies>
</project>
```</p>

<p>&emsp;&emsp;大家可以看到，这个pom继承了parent pom中的内容，dependency部分看起来才会这么简洁（当然，也有人不建议这么做，做法是在每个子项目dependency中明确定义了所有的依赖，这样感觉会更严谨些）。</p>

<p>&emsp;&emsp;另外，我们这篇文件中仅定义了对car-core的依赖，car-core又依赖了framework子项目，maven可以正确的处理这样的依赖传递。</p>

<p>&emsp;&emsp;在完成了dao的实现代码后，我们要编写相应的测试代码来验证实现的正确性，部分代码在下面已贴出，大家要注意一下这个文件所在的路径。</p>

<p>``` java /car-dao/src/test/java/com/ljh/ms/car/dao/UserDaoTest.java
@Transactional
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations={&ldquo;classpath:config/spring/spring*.xml&rdquo;})
public class UserDaoTest {</p>

<pre><code>@Resource
private IUserDao userDao;

@Test
public void testUserDao() {
    List&lt;User&gt; us = userDao.getAllUsers();
    Assert.assertEquals(9, us.size());
.......
</code></pre>

<p>}
```</p>

<p>&emsp;&emsp;在这个测试类上，我们可以在文件上点右键，run As JUnit test，即可看到结果。但是，我更加建议大家用maven的统一测试，在pom.xml上，选择run as maven test，如下图：</p>

<p><span class='caption-wrapper'><img class='caption' src='/uploads/2013/12/maven_run_as.jpg' width='' height='' title='运行maven测试'><span class='caption-text'>运行maven测试</span></span></p>

<p>&emsp;&emsp;通过观察控制台的输出，即可知道测试是否成功。</p>

<p>```
&hellip;..
2013-12-25 11:45:08,625 INFO [org.hibernate.impl.SessionFactoryImpl] &ndash; closing</p>

<p>Results :</p>

<p>Tests run: 1, Failures: 0, Errors: 0, Skipped: 0</p>

<p>[INFO] &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
[INFO] BUILD SUCCESS
[INFO] &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
[INFO] Total time: 17.234s
[INFO] Finished at: Wed Dec 25 11:45:08 CST 2013
[INFO] Final Memory: 4M/8M
[INFO] &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
```</p>

<p>&emsp;&emsp;按照同样的TDD流程，我们完成对service子项目的开发，最近完成对web端的开发。</p>

<p>&emsp;&emsp;maven的web项目目录结构跟eclipse标准Dyna web项目结构不同，下面贴出项目结构图。</p>

<p><span class='caption-wrapper'><img class='caption' src='/uploads/2013/12/project_struct3.jpg' width='' height='' title='maven web项目结构'><span class='caption-text'>maven web项目结构</span></span></p>

<p>&emsp;&emsp;在maven web工程项目中，有些目录需要大家手工建立，比如resources，默认建出的web工程中是不存在这个目录的。另外，在maven的web项目中，我们所依赖的其它模块都已打包成jar的形式存放在WEB-INF/lib目录中，而在classes目录下则会没有东西，这样一来，以前的一些配置可能要进行修改，比如，下面是加载spring配置文件的代码。</p>

<p>``` xml web.xml
&lt;context-param></p>

<pre><code>&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
&lt;param-value&gt;/WEB-INF/classes/config/spring/spring*.xml&lt;/param-value&gt;
</code></pre>

<p>&lt;/context-param>
```</p>

<p>&emsp;&emsp;需要改成下面这样，才不会有问题：</p>

<p><code>xml
&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
&lt;param-value&gt;classpath*:config/spring/spring*.xml&lt;/param-value&gt;
</code></p>

<p>&emsp;&emsp;另外，如果项目中有对spring文件引用的地方，也要修改为import引入的方式，配置代码如下：</p>

<p><code>xml
 &lt;!-- 引入其它jar包中的文件，须用这种方式 --&gt;    
&lt;import resource="classpath*:config/spring/spring-core.xml"/&gt;
</code>
&emsp;&emsp;最后，给大家介绍一下maven的常用命令。</p>

<ul>
<li>编译源代码: mvn compile</li>
<li>编译测试代码：mvn test-compile</li>
<li>单元测试: mvn test</li>
<li>构建并打包： mvn package</li>
<li>清理： mvn clean</li>
<li>安装： mvn clean install</li>
<li>发布： mvn clean deploy</li>
<li>在服务器上运行： mvn jetty:run</li>
<li>等等&hellip;&hellip;</li>
</ul>


<p>&emsp;&emsp;上面的命令可以组合使用，大家要注意的是：package只是本地打包，install会部署包到本地仓库，而deploy则会将artifact发布到仓库服务器中，比如：nexus的私有仓库。另外，在命令中还可以加一些参数，比如： -X 会显示更多的信息， -U 会强制从私服上下载SNAPSHOT最新版本。</p>

<p>如果要对整个项目进行打包，发布，我们只需要在car_parents项目中的pom.xml文件上运行相应的maven命令即可，下面是我在总项目中运行instlll的输出，我们可以看到，每个子项目的都进行了test,install：</p>

<p>```
Tests run: 0, Failures: 0, Errors: 0, Skipped: 0</p>

<p>[INFO]
[INFO] &mdash;&ndash; maven-war-plugin:2.4:war (default-war) @ car-web &mdash;&ndash;
[INFO] Packaging webapp
[INFO] Assembling webapp [car-web] in [F:\lovo\my\car-web\target\car-web]
[INFO] Processing war project
[INFO] Copying webapp resources [F:\lovo\my\car-web\src\main\webapp]
[INFO] Building jar: F:\lovo\my\car-web\target\car-web\WEB-INF\lib\car-web-0.0.1-SNAPSHOT.jar
[INFO] Webapp assembled in [2375 msecs]
[INFO] Building war: F:\lovo\my\car-web\target\car_ms.war
[INFO]
[INFO] &mdash;&ndash; maven-install-plugin:2.3.1:install (default-install) @ car-web &mdash;&ndash;
[INFO] Installing F:\lovo\my\car-web\target\car_ms.war to F:\java\maven\com\ljh\ms\car-web\0.0.1-SNAPSHOT\car-web-0.0.1-SNAPSHOT.war
[INFO] Installing F:\lovo\my\car-web\pom.xml to F:\java\maven\com\ljh\ms\car-web\0.0.1-SNAPSHOT\car-web-0.0.1-SNAPSHOT.pom
[INFO] &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
[INFO] Reactor Summary:
[INFO]
[INFO] car-parents &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; SUCCESS [0.719s]
[INFO] framework &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.. SUCCESS [1.969s]
[INFO] car-core &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; SUCCESS [0.531s]
[INFO] car-dao &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;. SUCCESS [2.937s]
[INFO] car-service &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; SUCCESS [2.719s]
[INFO] car-web Maven Webapp &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; SUCCESS [7.203s]
[INFO] &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
[INFO] BUILD SUCCESS
[INFO] &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
[INFO] Total time: 16.297s
[INFO] Finished at: Wed Dec 25 16:31:53 CST 2013
[INFO] Final Memory: 6M/12M
[INFO] &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</p>

<p>```</p>

<p>&emsp;&emsp;总的来说，maven的所有操作都是通过相应插件完成的，而maven本身仅充当了一个平台，大家在实际的工作中可以寻找更多有用的插件来增强maven功能。</p>

<p>&emsp;&emsp;好了，maven的入门介绍先到此为止吧。</p>

<p>```
2013-1-3补充：
如果大家要引用第三方artifact，而这个artifact在maven仓库中（包括本地和私服）并没有登记，这是就需要我们手工注册了。
比如，我要引用mynio-0.1.1.jar这个包到项目中，须在cmd窗口中执行下面的命令：
mvn install:install-file -DgroupId=com.my.nio -DartifactId=mynio -Dversion=0.1.1 -Dpackaging=jar -Dfile=C:\temp\mynio-0.1.1.jar
如此，maven将会把temp下的jar复制到本地仓库中，要注意articfactId的命名，maven会用artifactId+version做为包的名称哦。
最后，在项目中定义这个artifact的依赖即可：
<dependency></p>

<pre><code>  &lt;groupId&gt;com.my.nio&lt;/groupId&gt;
  &lt;artifactId&gt;mynio&lt;/artifactId&gt;
  &lt;version&gt;0.1.1&lt;/version&gt;
</code></pre>

<p></dependency>
```</p>

<p>```
2013-1-16再补充：
有这样的应用场景，在打war过程中，需要将一些配置文件
（比如数据库连接信息的properties文件）打包到WEB-INF/classes下。
而这些配置文件又在另一个maven工程中，解决办法如下：
<plugin></p>

<pre><code>            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;
            &lt;version&gt;2.4&lt;/version&gt;
            &lt;configuration&gt; 
                &lt;webResources&gt;
                    &lt;resource&gt;
                        &lt;directory&gt;../car-core/src/main/resources&lt;/directory&gt;
                        &lt;includes&gt;
                           &lt;include&gt;**/*.*&lt;/include&gt;
                        &lt;/includes&gt;
                        &lt;targetPath&gt;WEB-INF/classes&lt;/targetPath&gt;
                    &lt;/resource&gt;
                &lt;/webResources&gt;

                &lt;archive&gt;              
                ..............以下略去
</code></pre>

<p>请注意上面的resource节点中的内容。
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在项目中使用maven之二--项目实例]]></title>
    <link href="http://yanyaner.com/blog/2013/12/24/maven-project/"/>
    <updated>2013-12-24T15:18:00+08:00</updated>
    <id>http://yanyaner.com/blog/2013/12/24/maven-project</id>
    <content type="html"><![CDATA[<p>&emsp;&emsp;本篇文章介绍如何搭建一个maven工程。</p>

<p>&emsp;&emsp;我们以eclipse kepler为例，kepler版本的eclipse自带有maven插件，可以省去我们自己安装的过程，着实比较方便。</p>

<p>&emsp;&emsp;在新建项目向导中，我们选择maven工程，在Archetype中选择项目类型，要注意的是，一般的项目模块，选择maven-archetype-quickstart类型即可，如果是web项目请选择maven-archetype-webapp，当然你也可以根据个人喜好选择其它的项目模板类型。</p>

<p><span class='caption-wrapper'><img class='caption' src='/uploads/2013/12/project_waizd1.jpg' width='' height='' title='选择maven工程类型'><span class='caption-text'>选择maven工程类型</span></span></p>

<p>&emsp;&emsp;接下来输入项目坐标信息，如下图。groupId为组织标识，一般填写公司域名+项目名（请倒过来写，呵呵)，artifactId为产品标识或模块名、子系统名，多字母间请用-连接，version是这个产品的版本号，一般有SNAPSHOT快照版与RELEASE稳定版（关于maven版本的更多信息请参阅<a href="http://www.blogjava.net/hjh/archive/2009/05/14/270545.html">maven version usage</a>,<a href="http://juvenshun.iteye.com/blog/376422">Maven最佳实践：版本管理</a>）。</p>

<p><span class='caption-wrapper'><img class='caption' src='/uploads/2013/12/project_waizd2.jpg' width='' height='' title='输入maven项目的组织、公司、版本信息'><span class='caption-text'>输入maven项目的组织、公司、版本信息</span></span></p>

<p>&emsp;&emsp;接下来，我们来看看如何规划你的项目工程。如果是非常庞大的项目，采用Maven管理会非常的合适，因为在大的项目中，不同的模块，不同的子系统，不同的分层都有可能是不同的团队去完成，请看我下面的一个项目规划。<!--more--></p>

<p><span class='caption-wrapper'><img class='caption' src='/uploads/2013/12/project_struct.jpg' width='' height='' title='管理系统模块划分'><span class='caption-text'>管理系统模块划分</span></span></p>

<p>&emsp;&emsp;在上面的项目结构图中，你可以发现，我对项目模块进行了很好的分配。</p>

<ul>
<li>car_parents为父项目，其它的子项目都将继承这个项目中的配置，以省去了在每个子项目中都进行重复配置的麻烦。</li>
<li>framework项目，是整个系统的基础框架封装。</li>
<li>car-core项目是系统核心，主要是系统的领域对象（也有人叫业务对象）。</li>
<li>car-dao是项目持久层实现。</li>
<li>car-service是系统的核心业务逻辑实现。</li>
<li>car-web是系统对外部的调用接口，取名为car-facade也许更为合适（针对webservice类型），当然，我在这里主要存放的是restful接口及一些前端页面之类的文件。</li>
</ul>


<p>&emsp;&emsp;下面，我展示一个普通项目的目录结构，maven的项目结构和eclipse所建默认工程项目结构有很大的区别，最明显的感觉是目录的划分、规划更为合理、清晰。</p>

<p><span class='caption-wrapper'><img class='caption' src='/uploads/2013/12/project_struct2.jpg' width='' height='' title='一个普通maven项目的目录结构'><span class='caption-text'>一个普通maven项目的目录结构</span></span></p>

<p>&emsp;&emsp;上图中的结构我说明如下：</p>

<ul>
<li>src/main/java，该目录存放项目的源代码。</li>
<li>src/main/resources，该目录存放项目相关的资源文件，比如：properties文件, xml文件等等。</li>
<li>src/test/java，此目录下存放测试文件（注意，在maven中的测试类要以test开头或结尾，或以testCase结尾，这是规范要求）</li>
<li>target，该目录一般会存放编译打包后产生的文件，比如jar或war。</li>
</ul>


<p>&emsp;&emsp;接下来带大家看看具体的配置文件，先看parents这个项目，该项目工程基本上只有一个pom.xml文件，用来定义各个项目共同的东西（该项目的packaging必须是pom类型，因为这个项目是用来继承的）。</p>

<p>``` xml pom.xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion></p>

<p>  <groupId>com.ljh.ms</groupId>
  <artifactId>car-parents</artifactId>
  <version>0.0.1-SNAPSHOT</version>
  <packaging>pom</packaging></p>

<p>  <modules></p>

<pre><code>&lt;module&gt;../framework&lt;/module&gt;
&lt;module&gt;../car-core&lt;/module&gt;
&lt;module&gt;../car-dao&lt;/module&gt;
&lt;module&gt;../car-service&lt;/module&gt;
&lt;module&gt;../car-web&lt;/module&gt;
</code></pre>

<p>  </modules></p>

<p>  <!-- 定义发行、快照的打包上传服务器路径 -->
  <distributionManagement></p>

<pre><code>    &lt;repository&gt;
        &lt;id&gt;carManagerProjectRelease&lt;/id&gt;
        &lt;name&gt;Car ManagerSystem Release&lt;/name&gt;
        &lt;url&gt;http://127.0.0.1:8081/nexus/content/repositories/car_ms_release/&lt;/url&gt;
    &lt;/repository&gt;
    &lt;snapshotRepository&gt;
        &lt;id&gt;carManagerProjectSnapshot&lt;/id&gt;
        &lt;name&gt;Car ManagerSystem Snapshots&lt;/name&gt;
        &lt;url&gt;http://127.0.0.1:8081/nexus/content/repositories/car_ms_snapshot/&lt;/url&gt;
    &lt;/snapshotRepository&gt;
</code></pre>

<p></distributionManagement></p>

<p>  <name>car-parents</name>
  <url><a href="http://maven.apache.org">http://maven.apache.org</a></url></p>

<p>  <!-- 定义公共的变量值 -->
  <properties></p>

<pre><code>&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
&lt;spring.version&gt;3.2.5.RELEASE&lt;/spring.version&gt;
</code></pre>

<p>  </properties></p>

<p>  <!-- 定义依赖包 -->
  <dependencies></p>

<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;junit&lt;/groupId&gt;
  &lt;artifactId&gt;junit&lt;/artifactId&gt;
  &lt;version&gt;4.10&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;

&lt;!-- =======begin spring 3.2.4.RELEASE========= --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
    &lt;version&gt;${spring.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;
    &lt;version&gt;${spring.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-core&lt;/artifactId&gt;
    &lt;version&gt;${spring.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;
    &lt;version&gt;${spring.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;
    &lt;version&gt;${spring.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
    &lt;version&gt;${spring.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
    &lt;version&gt;${spring.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-expression&lt;/artifactId&gt;
    &lt;version&gt;${spring.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-instrument&lt;/artifactId&gt;
    &lt;version&gt;${spring.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
    &lt;version&gt;${spring.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-web&lt;/artifactId&gt;
    &lt;version&gt;${spring.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- =====end spring 3.2.4.RELEASE===== --&gt;

&lt;!-- =====start hibernate3 ====== --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
    &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;
    &lt;version&gt;3.6.10.Final&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
    &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
    &lt;version&gt;1.7.5&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
    &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
    &lt;version&gt;1.7.5&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javassist&lt;/groupId&gt;
    &lt;artifactId&gt;javassist&lt;/artifactId&gt;
    &lt;version&gt;3.12.1.GA&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;antlr&lt;/groupId&gt;
    &lt;artifactId&gt;antlr&lt;/artifactId&gt;
    &lt;version&gt;2.7.7&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;cglib&lt;/groupId&gt;
    &lt;artifactId&gt;cglib-nodep&lt;/artifactId&gt;
    &lt;version&gt;2.2.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- =====end hibernate3 ====== --&gt;

&lt;!-- =====commoms start =====--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;commons-collections&lt;/groupId&gt;
    &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;
    &lt;version&gt;3.2.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;commons-io&lt;/groupId&gt;
    &lt;artifactId&gt;commons-io&lt;/artifactId&gt;
    &lt;version&gt;2.3&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;commons-logging&lt;/groupId&gt;
    &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;
    &lt;version&gt;1.1.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
    &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
    &lt;version&gt;1.2.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;commons-dbcp&lt;/groupId&gt;
    &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt;
    &lt;version&gt;1.4&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;commons-digester&lt;/groupId&gt;
    &lt;artifactId&gt;commons-digester&lt;/artifactId&gt;
    &lt;version&gt;2.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;commons-pool&lt;/groupId&gt;
    &lt;artifactId&gt;commons-pool&lt;/artifactId&gt;
    &lt;version&gt;1.6&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;dom4j&lt;/groupId&gt;
    &lt;artifactId&gt;dom4j&lt;/artifactId&gt;
    &lt;version&gt;1.6.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j&lt;/artifactId&gt;
    &lt;version&gt;1.2.9&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- =====end commoms  =====--&gt;

&lt;!-- =====database start===== --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;version&gt;5.1.19&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- =====database end===== --&gt;

&lt;!-- ===== start servlet+jstl+jsp ===== --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;servletapi&lt;/groupId&gt;
    &lt;artifactId&gt;servletapi&lt;/artifactId&gt;
    &lt;version&gt;2.4&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;
    &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;
    &lt;version&gt;2.2&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;jstl&lt;/groupId&gt;
    &lt;artifactId&gt;jstl&lt;/artifactId&gt;
    &lt;version&gt;1.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;taglibs&lt;/groupId&gt;
    &lt;artifactId&gt;standard&lt;/artifactId&gt;
    &lt;version&gt;1.1.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- ===== end servlet+jstl+jsp ===== --&gt;

&lt;!-- ===== start json ===== --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-core-asl&lt;/artifactId&gt;
    &lt;version&gt;1.9.6&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt;
    &lt;version&gt;1.9.6&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- ===== end json ===== --&gt;
</code></pre>

<p>  </dependencies></p>

<p>  <build></p>

<pre><code>&lt;pluginManagement&gt;
    &lt;plugins&gt;

        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
            &lt;version&gt;2.3.2&lt;/version&gt;
            &lt;configuration&gt;
                &lt;source&gt;1.6&lt;/source&gt;
                &lt;target&gt;1.6&lt;/target&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;

        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;
            &lt;version&gt;2.6&lt;/version&gt;
            &lt;configuration&gt;
                &lt;encoding&gt;UTF-8&lt;/encoding&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;

        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;
            &lt;version&gt;2.4&lt;/version&gt;
            &lt;inherited&gt;true&lt;/inherited&gt;
            &lt;configuration&gt;
                &lt;archive&gt;                   
                    &lt;manifest&gt;
                        &lt;addDefaultImplementationEntries&gt;true&lt;/addDefaultImplementationEntries&gt;
                        &lt;addDefaultSpecificationEntries&gt;true&lt;/addDefaultSpecificationEntries&gt;
                    &lt;/manifest&gt;
                &lt;/archive&gt;
            &lt;/configuration&gt;
            &lt;!--  定义打war包要排除的文件
            &lt;executions&gt;
                &lt;execution&gt;
                    &lt;phase&gt;package&lt;/phase&gt;
                    &lt;goals&gt;
                        &lt;goal&gt;jar&lt;/goal&gt;
                    &lt;/goals&gt;
                    &lt;configuration&gt;
                        &lt;classifier&gt;lib&lt;/classifier&gt;
                        &lt;excludes&gt;
                            &lt;exclude&gt;*.properties&lt;/exclude&gt;
                        &lt;/excludes&gt;
                    &lt;/configuration&gt;
                &lt;/execution&gt;
            &lt;/executions&gt;
            --&gt;
        &lt;/plugin&gt;

        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;
            &lt;version&gt;2.4&lt;/version&gt;
            &lt;configuration&gt;
                &lt;archive&gt;                   
                    &lt;manifest&gt;
                        &lt;addDefaultImplementationEntries&gt;true&lt;/addDefaultImplementationEntries&gt;
                        &lt;addDefaultSpecificationEntries&gt;true&lt;/addDefaultSpecificationEntries&gt;
                    &lt;/manifest&gt;
                &lt;/archive&gt;
                &lt;archiveClasses&gt;true&lt;/archiveClasses&gt;
                &lt;warName&gt;car_ms&lt;/warName&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;

        &lt;plugin&gt;
            &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt;
            &lt;!-- 使用的是jetty-maven-plugin的插件 --&gt;
            &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt;
            &lt;version&gt;8.1.14.v20131031&lt;/version&gt;
            &lt;configuration&gt;
                &lt;scanIntervalSeconds&gt;2000&lt;/scanIntervalSeconds&gt;
                &lt;webApp&gt;
                    &lt;!-- 上下文路径 --&gt;
                    &lt;contextPath&gt;/car_ms&lt;/contextPath&gt;
                &lt;/webApp&gt;
                &lt;connectors&gt;
                    &lt;!-- 注意要使用将implementation 由org.eclipse.jetty.server.nio.SelectChannelConnector --&gt;
                    &lt;!-- 换为org.eclipse.jetty.server.bio.SocketConnector，否则静态页面无法修改 --&gt;

                    &lt;connector implementation="org.eclipse.jetty.server.bio.SocketConnector"&gt;
                        &lt;!-- 端口号 --&gt;
                        &lt;port&gt;8787&lt;/port&gt;
                        &lt;maxIdleTime&gt;500000&lt;/maxIdleTime&gt;
                    &lt;/connector&gt;
                &lt;/connectors&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
 &lt;/pluginManagement&gt;
</code></pre>

<p>  </build></p>

<p></project>
```</p>

<p>&emsp;&emsp;当然，这篇配置示例还有优化改进的地方，我没有详细去做。比如，可以把所有的dependencie放入<dependencyManagement>节点中以更好的独立定义每个子项目的依赖关系，比如：把很多重复属性定义成变量以便于统一维护等等，但这个文件也足以说明问题，比如下面这段配置代码：</p>

<p>``` xml
 <modules></p>

<pre><code>&lt;module&gt;../framework&lt;/module&gt;
&lt;module&gt;../car-core&lt;/module&gt;
&lt;module&gt;../car-dao&lt;/module&gt;
&lt;module&gt;../car-service&lt;/module&gt;
&lt;module&gt;../car-web&lt;/module&gt;
</code></pre>

<p>  </modules>
```
&emsp;&emsp;这段代码定义了项目间的依赖关系，其中的.. ，表示上一级目录，也就是和本项目同级的项目中定义的model名称，在这个项目上运行test, install, deploy等命令，将会对所有的子项目执行相同的命令。</p>

<p>&emsp;&emsp;好，今天就简单说到这，下篇关于maven的技术细节，敬请期待。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在项目中使用maven之一--环境配置]]></title>
    <link href="http://yanyaner.com/blog/2013/12/23/maven/"/>
    <updated>2013-12-23T15:18:00+08:00</updated>
    <id>http://yanyaner.com/blog/2013/12/23/maven</id>
    <content type="html"><![CDATA[<p>&emsp;&emsp;Apache Maven是一个软件项目综合管理工具，它基于项目对象模型（POM）的概念来统一管理项目，使用Maven可以更好地管理项目的模块化，更好地管理项目之间的依赖，更好地管理jar包依赖及其版本，也更加贴近项目管理的各个阶段。</p>

<p>&emsp;&emsp;你是否碰到过这样的一些困扰，比如：你现在要搭建一个现今比较流行的SSH javaEE框架原型，按照传统的方式，你得把项目所依赖的第三方框架jar包拷贝到工程的lib目录下再进行整合，但是，在你的架构原型中，每一个框架要用什么版本，各个版本的jar包之间是否会有不兼容的情况？这些都会给整个过程带来麻烦，并花费大量的调试时间。</p>

<p>&emsp;&emsp;如果有了Maven，这个事情会变得简单，你也许只需要声明一个依赖关系，所有的一切都自动完成了。</p>

<p>&emsp;&emsp;例如，我要写一个activeMQ的JMS项目，我的pom.xml中，只要添加如下的一个依赖，即可开始编码了：</p>

<p>``` xml pom.xml
<dependencies></p>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;
    &lt;artifactId&gt;activemq-core&lt;/artifactId&gt;
    &lt;version&gt;5.7.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<p>  </dependencies>
```</p>

<p><span class='caption-wrapper'><img class='caption' src='/uploads/2013/12/maven1.jpg' width='' height='' title='activeMQ项目中maven依赖的项目包'><span class='caption-text'>activeMQ项目中maven依赖的项目包</span></span></p>

<p>&emsp;&emsp;当然，上面的示例中使用maven也有一点约束，那就是你的开发机器必须要能够连接到互联网上，并且网速不能太卡（这点可能有些开发者的环境无法满足而制约了maven在国内的普及速度），原因显而易见：所有的jar包需要从网上的仓库中下载到本地。<!--more--></p>

<p>&emsp;&emsp;你可能通过上面的那段配置文件已经发现，在maven中世界中，每一个你所依赖的组件都是通过groupId、artifactId、version三个字段来定位的，好比x、y、h可以定位一个三维空间中的目标一样。如果你要问，我怎么知道所依赖的包的三维坐标信息呢，答案是：到<a href="http://mvnrepository.com/">mvnrepository.com</a>上查询。</p>

<p>&emsp;&emsp;如果公司的开发环境处在一个封闭的局域网内，就得需要安装一些工具，另加一些额外的配置了，nexus是值得选择的内网Maven仓库，下面我给大家简单介绍一下nexus的安装、配置以及maven的基本配置。</p>

<p>&emsp;&emsp;步骤如下：</p>

<ul>
<li>到nexus官网，下载nexus-2.7.0-04-bundle.zip文件（当然，你下载的版本号可能和我不同）</li>
<li>解压到自已的一个目录中，比如我放到了D:\dev_tools\nexus-2.7.0-04-bundle\下</li>
<li>接着，添加到路径变量到path中，注意是bin目录，我添加的是D:\dev_tools\nexus-2.7.0-04-bundle\nexus-2.7.0-04\bin</li>
<li>安装系统服务，进入cmd中，运行：nexus install，这个时候，你可以在window的系统服务中看到这样的路径信息：D:\dev_tools\nexus-2.7.0-04-bundle\nexus-2.7.0-04\bin\jsw\windows-x86-32\wrapper.exe -s D:\dev_tools\nexus-2.7.0-04-bundle\nexus-2.7.0-04\bin\jsw\conf\wrapper.conf,实际运行的就是这个命令</li>
<li>启动服务：nexus start，如果不出意外的话，你可以看到下面的界面，这证明安装成功了，。</li>
</ul>


<p><span class='caption-wrapper'><img class='caption' src='/uploads/2013/12/nexus1.jpg' width='' height='' title='启动nexus cmd界面'><span class='caption-text'>启动nexus cmd界面</span></span></p>

<p>&emsp;&emsp;在浏览器中，输入 htt p:/ / localhost:8081/nexus/  ，在主页面中输入用户名admin，密码admin123即可完成登录。</p>

<p>&emsp;&emsp;在Repositories中建立自己的仓库，如下图表中的Car ManagerSystem Release、Car ManagerSystem Snapshots就是我为车辆租赁管理系统建立的Release及Snapshort版本（这里注意，一般Repository ID有多个单词的情况下用-连接，我当时的命名并不规范）。</p>

<p><span class='caption-wrapper'><img class='caption' src='/uploads/2013/12/nexus2.jpg' width='' height='' title='我的项目中nexus截图'><span class='caption-text'>我的项目中nexus截图</span></span></p>

<p>&emsp;&emsp;接下来，找到Security菜单项，针对新建的两个仓库分别配置Privileges,Roles,Users。关于nexus的详细教程，大家可以自行在网上搜索，我在这还再详述。</p>

<p>&emsp;&emsp;下面要安装MAVEN了，步骤如下：</p>

<ul>
<li>到官网上下载apache-maven-3.1.1-bin.zip（你的版本可能跟我不一样），解压到目录D:\dev_tools\maven-3.1.1下（这个目录大家自行决定）。</li>
<li>在环境变量中，将maven的bin目录加入到path中。</li>
</ul>


<p>&emsp;&emsp;回到命令行下，输入mvn，出现下面界面，说明maven安装成功（当然，添加环境变量，只是为了你可以在命令行手工运行maven）。</p>

<p><span class='caption-wrapper'><img class='caption' src='/uploads/2013/12/maven2.jpg' width='' height='' title='安装成功的cmd窗口'><span class='caption-text'>安装成功的cmd窗口</span></span></p>

<p>&emsp;&emsp;目前的新版eclipse集成了maven，一般建议大家使用本地安装的maven以达到版本的统一，你可以在eclipse中进行选择配置，界面如下：</p>

<p><span class='caption-wrapper'><img class='caption' src='/uploads/2013/12/maven3.jpg' width='' height='' title='在eclipse中配置非集成maven'><span class='caption-text'>在eclipse中配置非集成maven</span></span></p>

<p>&emsp;&emsp;接下来，我们对maven进行参数进行配置，一般配置文件位于C:\Documents and Settings\Administrator.m2下，文件名为settings.xml，下面是我节选的部分修改过的配置代码：</p>

<p>``` xml settings.xml</p>

<pre><code> &lt;localRepository&gt;F:/java/maven&lt;/localRepository&gt;
</code></pre>

<p><servers></p>

<pre><code> &lt;server&gt;
  &lt;id&gt;carManagerProjectRelease&lt;/id&gt;
  &lt;username&gt;deployment&lt;/username&gt;
  &lt;password&gt;deployment123&lt;/password&gt;
&lt;/server&gt;

&lt;server&gt;
  &lt;id&gt;carManagerProjectSnapshot&lt;/id&gt;
  &lt;username&gt;deployment&lt;/username&gt;
  &lt;password&gt;deployment123&lt;/password&gt;
&lt;/server&gt;
</code></pre>

<p></servers></p>

<pre><code>&lt;profiles&gt;
   &lt;profile&gt;
   &lt;id&gt;central-repos&lt;/id&gt;
   &lt;repositories&gt;
        &lt;repository&gt;
          &lt;id&gt;central&lt;/id&gt;
          &lt;name&gt;Central&lt;/name&gt;
          &lt;url&gt;http://127.0.0.1:8081/nexus/content/groups/public/&lt;/url&gt;
          &lt;releases&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/releases&gt;
          &lt;snapshots&gt;
            &lt;enabled&gt;true&lt;/enabled&gt;
          &lt;/snapshots&gt;
        &lt;/repository&gt;
      &lt;/repositories&gt;
    &lt;/profile&gt;
&lt;/profiles&gt;

&lt;activeProfiles&gt;
    &lt;activeProfile&gt;central-repos&lt;/activeProfile&gt;
&lt;/activeProfiles&gt;
</code></pre>

<p>```</p>

<p>&emsp;&emsp;上面的文件中，我主要配置了本地仓库所在的位置，maven从网上下载的第三方依赖包，都将存放在这个地方。我放到了F:/java/maven，如果你的这个目录下已经有了非常多的jar包，你可以将这个目录直接copy给其它的开发同事机器上，避免重复下载。</p>

<p>&emsp;&emsp;server部分配置了可以上传到nexus中的相关账户的登录名及密码，这些信息都是在nexus的管理界面中配置的。而http : / /127.0.0.1:8081/nexus/content/groups/public 则是本地maven库所在的服务器路径。</p>

<p>&emsp;&emsp;好了，今天先到这，下一篇文章会详细介绍如何在项目中使用maven.</p>
]]></content>
  </entry>
  
</feed>
