<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[☺分类☺：架构 | 刘江华的博客]]></title>
  <link href="http://yanyaner.com/blog/categories/jia-gou/atom.xml" rel="self"/>
  <link href="http://yanyaner.com/"/>
  <updated>2014-03-28T19:34:27+08:00</updated>
  <id>http://yanyaner.com/</id>
  <author>
    <name><![CDATA[冰雨]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[读写分离架构之mysql实例]]></title>
    <link href="http://yanyaner.com/blog/2014/03/10/db-read-write-split/"/>
    <updated>2014-03-10T12:18:00+08:00</updated>
    <id>http://yanyaner.com/blog/2014/03/10/db-read-write-split</id>
    <content type="html"><![CDATA[<p>&emsp;&emsp;读写分离架构对提升系统性能非常重要，特别是在互联网项目中，查询操作可能达到90%以上，而且有较高的并发性。</p>

<p>&emsp;&emsp;对于数据库的读写分离，即是把所有的增、删、改操作发送到主数据库，所有查询操作发送到从数据库，通过增加从数据库实例个数以提升查询性能。当然也可以使用noSql数据库(如mongodb,hbase等)、搜索引擎（如lucene）等技术来做查询，关系数据库做核心数据保存，这种方式也是基于读写分离架构。</p>

<p>&emsp;&emsp;更多性能优化文章，大家可以参考我的文章：
<a href="/blog/2010/11/05/prof-web/">系统性能优化总结之表现层</a>，<a href="/blog/2010/11/08/prof-service/">系统性能优化总结之业务层</a>，<a href="/blog/2010/11/09/prof-dao/">系统性能优化总结之持久层篇</a>，技术在不断发展，这三篇文章是几年前写的，目前看来少了很多东西，我后续将把一些近年来新的内容添加上去以符合一些新的场景。</p>

<p>&emsp;&emsp;目前很多数据库都支持主从复制，读写分离，如：Oracle， SqlServer， Mysql等，主数据库在写入数据时同时同步到从数据库。此文以mysql为例给大家加以介绍。网上也有很多这样的文章，大家可以去搜索阅读，但这些文章基本上都是基于*inux平台的，我将以windows平台的配置为例（其实原理都是一样的，只是配置上的一些差异而已）。</p>

<p>&emsp;&emsp;简单起见，机器用我的笔记本。localhost:3307为主服务器master，localhost:3308为从属服务器slave（可以增加多个slave），mysql版本为5.6。先配置主服务器，编辑my.ini，内容如下：<!-- more--></p>

<p>``` ini</p>

<p>[mysqld]
 basedir =D:/server/db/MySQL Server5.6
 datadir =D:/server/db/mysql_db1/dbfile
 port = 3307
 server_id = 1
 log-bin=mysql-bin</p>

<p> skip-character-set-client-handshake
 init-connect = &lsquo;SET NAMES utf8&rsquo;
 character_set_server=utf8
 sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</p>

<p>```</p>

<p>&emsp;&emsp;从属数据库配置是(和主服务器的差别在于port、server_id与datadir不同)：</p>

<p><code>ini
[mysqld]
 basedir =D:/server/db/MySQL Server5.6
 datadir =D:/server/db/mysql_db2/dbfile
 port = 3308
 server_id = 10
 log-bin=mysql-bin
 skip-character-set-client-handshake
 init-connect = 'SET NAMES utf8'
 character_set_server=utf8
 sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES
</code></p>

<p>&emsp;&emsp;为了方便启动，把这两个数据库都注册为win服务，命令如下：</p>

<p>```
 D:\server\db\MySQL Server5.6\bin>mysqld
 &mdash;install mysql5.6.master
 &mdash;defaults-file=D:\server\db\mysql_db1\my.ini</p>

<p>```</p>

<p>&emsp;&emsp;从属服务器的注册与之类似不在写出，我们接下来在系统服务中分别启动这两个服务器实例。</p>

<p>&emsp;&emsp;再接下来要做的事情是配置主从复制功能，主服务器的增、删、改数据操作都将同步到多台从属服务器上，先在主服务器上给从属服务器分配登录账号，这个账号将是从属服务器进行数据同步操作的授权，命令如下（账号是backup，密码是123）：</p>

<p>```
GRANT REPLICATION SLAVE ON
<em>.</em> to &lsquo;backup&rsquo;@&lsquo;localhost&rsquo;
identified by &lsquo;123’;</p>

<p>```</p>

<p>&emsp;&emsp;继续命令行中运行：show master status; 记录下File及Position两个输出内容，这两个参数在配置slave时需要用到。</p>

<p>&emsp;&emsp;登录从服务器，执行下面的命令：</p>

<p><code>
change master to
master_host=’localhost’,
master_port=3307,
master_user=’backup’,
master_password=’123’,
master_log_file=’mysql-bin.000006’,
master_log_pos=120;
</code></p>

<p>&emsp;&emsp;上面命令中的master_host及master_port是主服务器的地址和端口号，master_user及master_password是授权命令输入的账号、密码，master_log_file及master_log_pos是show master status输出的东西。</p>

<p>&emsp;&emsp;接下来，从属服务器上运行start slave就可以启动从属服务，运行show slave status\G查看状态，如果输出的Slave_IO_Running和Slave_SQL_Running都是yes，则表示配置成功（如果配置有误，可stop slave服务，再次运行change master命令）。</p>

<p>&emsp;&emsp;至此，mysql的主从复制功能就配置完成了。也许你会说，我们的所有增、删、改通过对localhost:3307这个数据库操作，查询通过localhost:3308这个数据库操作不就完成了么？确实如你所说，这种方案是可行的，我们可以在spring中配置两个Datasource，并在技术架构上进行处理，把查询接口单独封装出来以使用不同的数据源。大家可以到我的博客文章<a href="/blog/2010/11/01/p4/">四种持久层设计方案比较</a>中，查看其中的方案三设计。</p>

<p>&emsp;&emsp;当然，上面的访问方式也是有缺陷的，主要体现在，读写分离操作对应用程序并不透明，比如有多台读服务器，你的读操作数据源该如何去配置呢？读写分离会影响到应用代码？因此，我们还得寻找另一种对应用透明的访问方式，这就是用代理模式，屏蔽底层访问细节，这个代理类来负责低层的读写分离，缓存连接（相当于连接池），还包括读操作的负载均衡。</p>

<p>&emsp;&emsp;mysql-proxy就是这样一个程序，我下载的是mysql-proxy-0.8.4-win32-x86.zip，解压后运行bin中的mysql-proxy.exe即可。如果mysql-proxy.exe无法运行，可能是缺少vc2008支持包，大家到微软官网下载vcredist_x86.exe并安装。</p>

<p>&emsp;&emsp;为了后期运行方便，可以配置一个bat批处理文件，启动代理程序：</p>

<p><code>
D:\server\db\mysql-proxy\bin\mysql-proxy.exe
 --proxy-backend-addresses=localhost:3307
 --proxy-read-only-backend-addresses=localhost:3308
 --proxy-lua-script=D:\server\db\mysql-proxy\share\doc\mysql-proxy\rw-splitting.lua
</code></p>

<p>&emsp;&emsp;上面的配置中大家要注意：proxy-read-only-backend-addresses可以写多台服务器，用逗号分割开；rw-splitting.lua是读写分离lua脚本文件，您可以进行编辑以符合你的要求（比如有人修改min_idle_connections及max_idle_connections来观察到读写分离的效果），但一般情况下并不需要；你可以通过&mdash;proxy-address=host:port指定代理服务器端口号，如果不指定默认为4040(另，管理端口默认是4041，可以看到一些状态参数)。</p>

<p>&emsp;&emsp;应用程序中通过连接localhost:4040即可操作mysql数据库了，后台的一切都是通过mysql-proxy去处理的，数据库连接对应用程序变得透明了，我们的任务也就完成了。</p>

<p>&emsp;&emsp;下篇给出读写分离的性能测试数据。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[项目中ibatis与hibernate混用示例详解]]></title>
    <link href="http://yanyaner.com/blog/2014/03/06/ibatis-hibernate-in-query/"/>
    <updated>2014-03-06T12:18:00+08:00</updated>
    <id>http://yanyaner.com/blog/2014/03/06/ibatis-hibernate-in-query</id>
    <content type="html"><![CDATA[<p>&emsp;&emsp;对于一般的项目hibernate足以胜任，但在选择一个框架时都要考虑适用场景（比如非功能性需求），hibernate也不例外，比如：复杂多条件组合查询对于hibernate来说并不方便（我们需要手工拼接sql）。基于这样的原因，很多项目中会引入ibatis来做复杂查询操作以做为补充，这主要是针对编码复杂度的考虑，性能也是其次的一个因素（其实hibernate也不存在问题的，你还记得到hibernater中有SqlQuery么，呵呵）。</p>

<p>&emsp;&emsp;下面我给出一个简单的ibatis与hibernate混用示例，并在最后说明在实际使用过程中应该注意的问题。先来看spring的核心配置文件：</p>

<p>``` xml spring-core.xml</p>

<pre><code>&lt;!-- 读取配置参数 --&gt;
&lt;bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt;
    &lt;property name="location"&gt;
        &lt;value&gt;classpath:database.properties&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;!-- 配置数据源 --&gt;
&lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"
      init-method="init" destroy-method="close"
&gt;
    &lt;property name="driverClassName"&gt;
        &lt;value&gt;${driverClassName}&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="url"&gt;
        &lt;value&gt;${url}&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="username"&gt;
        &lt;value&gt;${username}&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="password"&gt;
        &lt;value&gt;${pwd}&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="defaultAutoCommit"&gt;
        &lt;value&gt;false&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="initialSize" value="1" /&gt;
    &lt;property name="filters" value="stat,log4j" /&gt;
    &lt;property name="name" value="myDatasource1"&gt;&lt;/property&gt;
    &lt;!-- 最大活动连接数，也就是连接池中的最大缓存连接数 --&gt;
    &lt;property name="maxActive" value="20" /&gt;
    &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt;
    &lt;property name="timeBetweenEvictionRunsMillis" value="10000" /&gt;
    &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt;
    &lt;property name="minEvictableIdleTimeMillis" value="10000" /&gt;
    &lt;property name="minIdle" value="1" /&gt; 


&lt;/bean&gt;

&lt;!-- hibernate参数配置文件，包括缓存的信息 --&gt;
&lt;bean id="hibernateProperties" class="org.springframework.beans.factory.config.PropertiesFactoryBean"&gt;
    &lt;property name="location"&gt;
        &lt;value&gt;classpath:hibernate-config.properties&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;


&lt;!--  配置sessionFactory--&gt;
&lt;bean id="sessionFactory" class="org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean"&gt;
    &lt;property name="dataSource"&gt;
        &lt;ref bean="dataSource" /&gt;
    &lt;/property&gt;
    &lt;property name="hibernateProperties" ref="hibernateProperties"&gt;&lt;/property&gt;
    &lt;property name="packagesToScan"&gt;
        &lt;list&gt;
            &lt;value&gt;com.my.monitor.model&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt; 
&lt;/bean&gt;

&lt;!-- 配置事务管理器 --&gt;
&lt;bean id="transactionManager"
    class="org.springframework.orm.hibernate3.HibernateTransactionManager"&gt;
    &lt;property name="sessionFactory" ref="sessionFactory"&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;!-- 对注解事务的支持 --&gt;
&lt;tx:annotation-driven transaction-manager="transactionManager" /&gt;

&lt;!-- 注解驱动 --&gt;
&lt;context:component-scan base-package="com.my.monitor" &gt;&lt;/context:component-scan&gt; 

&lt;!-- hibernate通用dao --&gt;
&lt;bean id="hibernateBaseDao"
    class="com.my.ms.framework.persistence.hibernate.BaseDaoHibernateImpl"&gt;
    &lt;property name="sessionFactory" ref="sessionFactory"&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;!-- ibatis通用dao，一般用于查询 --&gt;
&lt;bean id="ibatisBaseDao" class="com.my.ms.framework.persistence.ibatis.BaseDao"&gt;
    &lt;property name="sqlMapClient"&gt;
        &lt;bean class="org.springframework.orm.ibatis.SqlMapClientFactoryBean"&gt;
            &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;
            &lt;property name="configLocation"&gt;
                &lt;value&gt;classpath:config/ibatis/sqlMapConfig.xml&lt;/value&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>

<p>```</p>

<p>&emsp;&emsp;这里封装了两个baseDao，分别针对的是hibernate与ibatis书写，源代码如下：<!-- more --></p>

<p>``` java BaseDaoHibernateImpl.java
package com.my.ms.framework.persistence.hibernate;</p>

<p>import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;</p>

<p>import org.hibernate.HibernateException;
import org.hibernate.Query;
import org.hibernate.Session;
import org.springframework.orm.hibernate3.HibernateCallback;
import org.springframework.orm.hibernate3.support.HibernateDaoSupport;
import org.springframework.util.Assert;</p>

<p>import com.my.ms.framework.persistence.model.Page;</p>

<p>public class BaseDaoHibernateImpl extends HibernateDaoSupport implements</p>

<pre><code>    IBaseDao {

@Override
public void addEntity(Object entity) {
    getHibernateTemplate().save(entity);
}

@Override
public void updateEntity(Object entity) {
    getHibernateTemplate().update(entity);
}

@Override
public void deleteEntity(Object entity) {
    getHibernateTemplate().delete(entity);
}

@Override
public void deleteEntityById(Class clazz, Serializable id) {
    getHibernateTemplate().delete(this.queryEntityById(clazz, id));
}

@Override
public &lt;T&gt; T queryEntityById(Class&lt;T&gt; clazz, Serializable id) {
    return getHibernateTemplate().get(clazz, id);
}

@Override
public List queryEntitys(String queryString, Object[] values) {
    return getHibernateTemplate().find(queryString, values);
}

@Override
public Page queryEntityByPage(int pageNo, int pageSize, String queryString,
        Object[] parameters) {
    Assert.isTrue(pageNo &gt; 0, "起始页不能小于0！");
    // 去除select 子句，未考虑union的情况
    int beginPos = queryString.toLowerCase().indexOf("from");
    Assert.isTrue(beginPos != -1, queryString + "无效，必须包含from关键字");
    String hql4Count = " select count(*)  "
            + queryString.substring(beginPos);
    return queryEntityByPage(pageNo, pageSize, queryString, hql4Count,
            parameters);
}

@Override
public Page queryEntityByPage(final int pageNo, final int pageSize,
        final String queryString4Data, final String queryString4Count,
        final Object[] parameters) {
    Assert.hasText(queryString4Count, "用于计数的hql不能为空!");
    Assert.hasText(queryString4Data, "用于查询的hql不能为空！");
    Assert.isTrue(pageNo &gt; 0, "起始页不能小于0！");
    return (Page) getHibernateTemplate().execute(new HibernateCallback() {

        public Object doInHibernate(Session session)
                throws HibernateException {

            // 根据指定的参数执行hibernate hql查询
            List countlist = getHibernateTemplate().find(queryString4Count,
                    parameters);

            long totalCount = ((Long) countlist.get(0)).longValue();
            // 如果记录总数小于1则返回空的Page
            if (totalCount &lt; 1)
                return new Page(pageNo, pageSize, new ArrayList(), 0);
            int startIndex = Page.getStartOfPage(pageNo, pageSize);
            Query query = getSession().createQuery(queryString4Data);
            for (int i = 0; i &lt; parameters.length; i++) {
                query.setParameter(i, parameters[i]);
            }
            List list = query.setFirstResult(startIndex)
                    .setMaxResults(pageSize).list();
            return new Page(pageNo, pageSize, list, (int) totalCount);
        }

    });
}
</code></pre>

<p>}</p>

<p>```</p>

<p>针对ibatis的baseDao封装，主要是添加了一个分页方法，代码如下：</p>

<p>``` java BaseDao.java</p>

<p>package com.my.ms.framework.persistence.ibatis;</p>

<p>import java.util.Map;</p>

<p>import org.springframework.orm.ibatis.SqlMapClientTemplate;</p>

<p>import com.my.ms.framework.persistence.model.Page;</p>

<p>public class BaseDao extends SqlMapClientTemplate {</p>

<pre><code>/**
 * 分页查询(sql语句块中的分页参数，请使用start与end)
 * @param pageNo
 * @param pageSize
 * @param sqlId4Data
 * @param sqlId4count
 * @param queryParam
 * @return
 */
public Page queryEntityByPage(int pageNo, int pageSize, String sqlId4Data, String sqlId4Count, Map queryParam) {

    queryParam.put("start", (pageNo - 1) * pageSize);
    queryParam.put("end", pageSize);

    Page page = new Page(pageNo, pageSize);

    page.setData(queryForList(sqlId4Data, queryParam));
    page.setRowcounts(((Number)queryForObject(sqlId4Count, queryParam)).intValue());

    return page;
}
</code></pre>

<p>}</p>

<p>```</p>

<p>&emsp;&emsp;上面两个实现的分页部分，用到了Page对象，请看分页对象的代码：</p>

<p>``` java</p>

<p>package com.my.ms.framework.persistence.model;</p>

<p>import java.util.List;</p>

<p>/<em>*
 * 分页对象
 * @author ljh
 *
 </em>/
public class Page<T> {</p>

<pre><code>/**
 * 数据对象
 */
private List&lt;T&gt; data;

private int rowcounts;
/**
 * 页码
 */
private int pageNo;
/**
 * 最大显示页数
 */
private int pageSize;

public Page(){

}

public Page(int pageNo, int pageSize) {
    this.pageNo = pageNo;
    this.pageSize = pageSize;
}

public Page(int pageNo, int pageSize, List&lt;T&gt; data, int rowcounts) {
    this.pageNo = pageNo;
    this.pageSize = pageSize;
    this.data = data;
    this.rowcounts = rowcounts;
}

//计算该页对应的数据库下标
public static int getStartOfPage(int pageNo, int pageSize) {
    if (0 &gt; pageNo)
        throw new IllegalArgumentException("页面索引不能小于0!");
    return (pageNo - 1) * pageSize;
}


//共有多少页
public int getPages() {
    if (rowcounts % pageSize == 0) 
    {
        return rowcounts/pageSize;
    } else {
        return rowcounts/pageSize + 1;
    }
}

public int getFirstNo() {
    return 1;
}

public int getLastNo() {
    return getPages();
}

public int getPreNo() {
    if (pageNo - 1 &gt; 0 ) {
        return pageNo - 1;
    } else {
        return 1;
    }
} 

public int getNextNo() {
    if (pageNo + 1  &lt;= getPages()) {
        return pageNo + 1;
    }
    return getPages();
}



public List&lt;T&gt; getData() {
    return data;
}

public void setData(List&lt;T&gt; data) {
    this.data = data;
}

public int getPageNo() {
    return pageNo;
}

public void setPageNo(int pageNo) {
    this.pageNo = pageNo;
}

public int getPageSize() {
    return pageSize;
}

public void setPageSize(int pageSize) {
    this.pageSize = pageSize;
}

public int getRowcounts() {
    return rowcounts;
}

public void setRowcounts(int rowcounts) {
    this.rowcounts = rowcounts;
}
</code></pre>

<p>}</p>

<p>```</p>

<p>&emsp;&emsp;具体使用时就比较方便了，下面是一个调用示例：</p>

<p>``` java UserServiceImpl.java</p>

<p>@Service
@Transactional(readOnly=false)
public class UserServiceImpl implements IUserService{</p>

<pre><code>@Resource
private IBaseDao hibernateDao;

@Resource
private BaseDao ibatisDao;

@Override
public User someBizMethod(int userId) {

    ......

    User u1 = (User)hibernateDao.queryEntityById(User.class, userId);
    u1.setUserName(u2.getUserName() + "hibernate");
    hibernateDao.updateEntity(u1);

    User u2 = (User)ibatisDao.queryForObject("znjk.getUserById", userId);
    u2.setUserName(u2.getUserName() + "ibatis");
    ibatisDao.update("znjk.updateUser",  u2);

    ......
</code></pre>

<p>```</p>

<p>&emsp;&emsp;好了，在上面的示例中还存在一些必须要弄明白的问题。</p>

<p>&emsp;&emsp;一、事务管理问题。大家可以看到，我在spring文件中只配置了一个事务管理器，并且是hibernate的事务管理器，那么，有人就有会疑问：hibernater的事务可以应用在ibatis的dao上么？答案是肯定的。至于原因，你想想spring事务管理是通过AOP来实现的，并且最终映射到底层的话，事务是通过在jdbc的connection上完成的，而在我上面的这个业务方法中，两个dao拿到的是同一个连接，因此，方法中的所有操作都在一个事务环境中了，这个事务是通过hibernate事务管理器启动的。</p>

<p>&emsp;&emsp;二、缓存同步问题。两个框架都有自己不同的缓存配置及实现，而且互不相关。因为这个原因，我上面的代码没法对保证缓存的一致性，所以，我的建议是：ibatis仅仅只做复杂查询，hibernate什么都可以做。此外，还有一个方案是，配置ibatis的数据源事务管理器，在不同的方法中，通过@Transactional注解来指定这个业务方法使用的事务管理器（比如：@Transactional(readOnly=false,value=&ldquo;dataSourceTransactionManager&rdquo;)），也就是说，在每一个方法中不存在两个dao混用的情况，而在不同的方法中，用不同的事务管理器操作事务的提交。</p>

<p>&emsp;&emsp;ibatis的优势在于查询，特别是类似下面的组合查询，十分的方便。复杂查询更是如此。</p>

<p>``` xml
<sql id="where4pet"></p>

<pre><code>    &lt;dynamic prepend="where"&gt;
        &lt;isNotNull property="nickName" prepend="and"&gt;
            f_nick_name like '%$nickName$%'
        &lt;/isNotNull&gt;
        &lt;isNotNull property="password" prepend="and"&gt;
            f_password like '%$password$%'
        &lt;/isNotNull&gt;
        &lt;isNotNull property="birthday" prepend="and"&gt;
            f_birthday = #birthday#
        &lt;/isNotNull&gt;
        &lt;isNotNull property="gender" prepend="and"&gt;
            &lt;isEqual compareProperty="gender" compareValue="true"&gt;
                f_gender = 'T'
            &lt;/isEqual&gt;
            &lt;isEqual compareProperty="gender" compareValue="false"&gt;
                f_gender = 'F'
            &lt;/isEqual&gt;
        &lt;/isNotNull&gt;
        &lt;isNotNull property="age" prepend="and"&gt;
            f_age = #age#
        &lt;/isNotNull&gt;
    &lt;/dynamic&gt;
&lt;/sql&gt;

&lt;select id="getPetByPage4data" resultMap="resultMapPet" &gt;
    select *
    from t_pet
    &lt;include refid="where4pet"/&gt;
    order by $field$
    limit #start#, #end#
&lt;/select&gt;
&lt;select id="getPetByPage4count" resultClass="int"&gt;
    select count(*)
    from t_pet
    &lt;include refid="where4pet"/&gt;
&lt;/select&gt;
</code></pre>

<p>```</p>

<p>&emsp;&emsp;这样的话，我们就可以充分利用不同框架的优势，达到取长补短的目的。也许你会说，这种方式就是把增、删、改交由hibernate来做，把查询交由ibatis来做。本质上看确实如此，但实际项目中要灵活去做，比如hibernate除了增删改外也可以做查询，特别是简单的查询，这样也可以更好的利用到hibernate的缓存。</p>

<p>&emsp;&emsp;我在<a href="/blog/2010/11/01/p4">四种持久层设计方案比较</a>中，对查询的分离有所介绍，有兴趣的可以去看看其中的一个方案，另外，CQRS架构、mysql读写分离也有这方面的含义。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[事务中的并发处理]]></title>
    <link href="http://yanyaner.com/blog/2013/06/27/hibernate-transaction/"/>
    <updated>2013-06-27T15:18:00+08:00</updated>
    <id>http://yanyaner.com/blog/2013/06/27/hibernate-transaction</id>
    <content type="html"><![CDATA[<p>&emsp;&emsp;在项目中，事务是不可缺少的，但是如何在一个业务事务中正确的处理并发，确不是一件容易的事。下面，我通过一个简单的例子来说明这个问题，并给出一些解决办法。</p>

<p>&emsp;&emsp;这个例子也许并不恰当，但足够简单：宠物&mdash;&ndash;>宠物日记，一对多双向关联，持久层使用hibernate框架实现。</p>

<p>``` java Epet.java
public class Epet{</p>

<pre><code>private int id;
private String name;
private String password;

//日记集合
private Set&lt;Diary&gt; diarys = new HashSet&lt;Diary&gt;();
//日记的总积分，为了提高效率而设置的冗余字段
private int integralCount;
</code></pre>

<p>}
```</p>

<p>``` java Diary.java
public class Diary{</p>

<pre><code>private int id;
private String title;
private Date publishDate;
//日记积分
private int integral;
//日记所属宠物
private Epet epet;
</code></pre>

<p>}
```</p>

<p>&emsp;&emsp;假设为了提高效率，我们在epet对象中，添加了该宠物所有日记的总积分，我们现在需要一个业务方法，用来计算宠物的总积分，并持久化到数据库中。</p>

<p>&emsp;&emsp;实现代码如下：</p>

<p>``` java</p>

<pre><code>    Epet e = (Epet)ht.get(Epet.class, epetId, LockMode.UPGRADE);
    int count = 0;
    for (Iterator&lt;Diary&gt; its = e.getDiarys().iterator();its.hasNext();) {
        count = count + its.next().getIntegral();
    }
    e.setIntegralCount(count);

    epetDao.updateEpet(e);
</code></pre>

<p>```</p>

<p>&emsp;&emsp;上面的代码，考虑到要修改总积分，首先对读取的epet加锁，然后取出每一篇日记，累加积分，最后更新宠物对象，通过观察输出的sql语句，我们会发现这段代码有问题，并不能保存业务约束的完整性。系统对日记的查询，并没有加锁，也就是说，这段时间内，完全有可能存在其它事务修改日志积分，或添加、删除日记的情况。</p>

<p>&emsp;&emsp;也许你会说，把该方法的数据库隔离级别设置为ISOLATION_REPEATABLE_READ，但经过我的测试，这个级别在mysql,orcle中也是存在问题的，原因是：mysql的可重复读是通过内部缓存实现，也说是说，你在事务中查完的数据，它会缓存起来，事务中再说，返回的是缓存中的数据，在这个过程中，其它事务是可以成功修改数据的；oracle是不支持可重复读的，所以，设置隔离级别不靠谱。</p>

<p>&emsp;&emsp;那我们把代码改进一下，自己来加锁，代码如下：</p>

<p>``` java</p>

<pre><code>    ht.execute(new HibernateCallback() {    
        @Override
        public Object doInHibernate(Session session) throws HibernateException,
                SQLException {

            Epet e = (Epet)ht.get(Epet.class, epetid);

            List&lt;Diary&gt; ds = session.createQuery("from Diary d where d.epet.id = ?")
            .setParameter(0, 1).setLockMode("d", LockMode.UPGRADE)
            .list();
            int count = 0;
            for (Diary d : ds) {
                count = count + d.getIntegral();
            }
            e.setIntegralCount(count);
            epetDao.updateEpet(e);

            return null;
        }
    });
</code></pre>

<p>```</p>

<p>&emsp;&emsp;注意setLockMode(&ldquo;d&rdquo;, LockMode.UPGRADE)部分的代码，这段代码可以保证在事务期间，没有人修改日记积分，因此，从业务上说，在事务执行这段期间，统计的总积分是正确的。</p>

<p>&emsp;&emsp;用悲观锁把部分数据锁定，在项目中并不建议使用，因为这样会在并发环境中带来性能问题。</p>

<p>&emsp;&emsp;再次改进，在Epet对象和Diary对象中，都加上version字段，使用乐观锁控制事务，代码如下：</p>

<p>``` java</p>

<pre><code>    Epet e = (Epet)ht.get(Epet.class, epetId);
    int count = 0;
    for (Iterator&lt;Diary&gt; its = e.getDiarys().iterator();its.hasNext();) {
        count = count + its.next().getIntegral();
    }
    e.setIntegralCount(count);

    epetDao.updateEpet(e);

    //再次查询状态每个diary的状态，看是否被它人修改过
    for (Iterator&lt;Diary&gt; its = e.getDiarys().iterator();its.hasNext();) {
        Diary d = its.next();
        int ver = d.getVersion();
        //注意，在mysql中，要想成功refresh得到最新数据，必须设置隔离级别是ISOLATION_READ_COMMITTED
        ht.refresh(d);
        if (d.getVersion() != ver) {
            throw new RuntimeException("订单状态已被改变！");
        }
    }
</code></pre>

<p>```</p>

<p>&emsp;&emsp;上面的这段代码在最后再次检查是否有人修改了日记，如果日记版本号与之前一致，则提交事务，但是，这段代码也并非没有问题，因为在事务最后提交的过程中，还是会存在并发修改日记的情况，所以，业务事务的处理非常麻烦，要考虑到业务规则的满足，并不是我们想像的那么简单。</p>

<p>&emsp;&emsp;从业务上来讲，我们只关心在我的事务中，日记的积分不被它人修改，因此，上面的代码还可以再次修改，只关注积分值，减少并发冲突问题，代码如下：</p>

<p>``` java</p>

<pre><code>     //再次查询状态每个diary的状态，看是否被它人修改过
    for (Iterator&lt;Diary&gt; its = e.getDiarys().iterator();its.hasNext();) {
        Diary d = its.next();
        int integral = d.getIntegral();
        //注意，在mysql中，要想成功refresh得到最新数据，必须设置隔离级别是ISOLATION_READ_COMMITTED
        ht.refresh(d);
        if (d.getIntegral() != integral) {
            throw new RuntimeException("订单状态已被改变！");
        }
</code></pre>

<p>```</p>

<p>&emsp;&emsp;红色字体部分，取日记的积分，只是为了减少并发冲突出现的可能性，但依然没办法保证业务约束完整，要想保存业务约束及规则的满足，最好的办法是使用富血模型去做，对日记的任何操作，都必须通过它的聚合根，也就是epet对象去实现，示例代码如下：</p>

<p>&emsp;&emsp;以下方法都是写在Epet对象中的：</p>

<p>``` java</p>

<pre><code>/**
 * 重新计算积分
 */
public void reCalculateIntegral() {
    int count = 0;
    for (Iterator&lt;Diary&gt; its = this.getDiarys().iterator();its.hasNext();) {
        count = count + its.next().getIntegral();
    }
    this.setIntegralCount(count);
}

/**
 * 添加日记
 */  

 public void addDiary(Diary d) {
    this.getBaseDao().save(d);
    this.getDiarys().add(d);
    d.setEpet(this);
    reCalculateIntegral();
    this.getBaseDao().update(this);
}

/**
 * 修改日记
 */
public void updateDiary(Diary d) {
    this.getBaseDao().update(d);
    reCalculateIntegral();
    this.getBaseDao().update(this);
}
</code></pre>

<p>```</p>

<p>&emsp;&emsp;而对应的facade中的代码如下（注意：事务是控制在facade上的哦）：</p>

<p>``` java</p>

<p>  //增删改日记(事务控制在此，乐观锁保证业务约束的完整性)</p>

<pre><code>public void addDiary(int petId, Diary d) {
    Epet e = (Epet)ht.get(Epet.class, petId);
    e.addDiary(d); 
}

public void updateDiary(Diary d){
    //这里再次按id查询epet，无性能损耗，因为有缓存
    Epet e = (Epet)ht.get(Epet.class, d.getEpet().getId());
    e.updateDiary(d);
}
</code></pre>

<p>```</p>

<p>&emsp;&emsp;从上面的代码可以看到，所有对日记的修改，都必须通过聚合根epet对象，而epet上是有基于version的乐观锁的，因些，最后的这部分代码基本满足了我们的业务约束及事务的并发控制。</p>

<p>&emsp;&emsp;还有一种情况，如果在我们这个场景中，如果事务的失败对用户来说是不能容忍的，比如：添加一篇宠物日记会花费用户30分钟的录入时间，如果最终事务失败，用户无疑非常的沮丧，这种情况该如何应对了？接下来，我给大家继续讲解离线事务锁的示例。</p>

<p>&emsp;&emsp;先看乐观离线事务锁，这种锁不是用来解决事务失败而用户不能接受的情况，而是一个超长的业务事务，比如30分钟，而在最终提交事务时，系统要检测到这种冲突，下面是乐观离线锁的实现示例代码：</p>

<p>``` java</p>

<pre><code>    //长事务，离线乐观锁
    Epet e = ss.getEpetById(1);
    Map&lt;String, Epet&gt; session = new HashMap&lt;String, Epet&gt;();

    session.put("epet_in_http_session", e);
    //给用户发回响应resopnse

    //长时间的编辑
    Thread.sleep(10000);

    //最后一步，提交
    //这里不要从数据库中重查，而是直接使用先前保存的那个，可能是httpsession，也可能是序列化至外部
    Epet e2 = session.get("epet_in_http_session");
    e2.setName("小强22");
    //重新保存，version乐观锁会保证并发冲突，如果出现冲突，你会得到类似org.hibernate.StaleObjectStateException: Row was updated or deleted by another transaction (or unsaved-value mapping was incorrect)的错误信息。
    ss.updateEpet(e2);
</code></pre>

<p>```</p>

<p>&emsp;&emsp;如果用户对事务冲突不可容忍，我们就只能使用悲观离线锁，本质上来就，就是用户自己去实现对象的锁定，代码如下：</p>

<p> &emsp;&emsp;先在epet中加上这三个新的属性：</p>

<p>``` java</p>

<pre><code>//锁定标示： true已锁定，false:未锁定
private boolean locked;
//锁定者
private String locker;
//锁定时间
private Date lockedTime;
</code></pre>

<p>```</p>

<p>&emsp;&emsp;epet中再加上和悲观锁相关的几个方法：</p>

<p>``` java</p>

<p>   /**</p>

<pre><code> * 锁定对象
 * @param locker
 */
public void lockEpet(String locker) {
    if (this.isLockedBy(locker)) {
        return;
    }
    if (this.isLocked()) {
        throw new RuntimeException("该对象已被"+this.getLocker()+"被锁定！");
    }
    this.setLocked(true);
    this.setLocker(locker);
    this.setLockedTime(new Date());
    getBaseDao().update(this);
}

/**
 * 解锁对象
 * @param locker
 */
public void unLockEpet(String locker) {
    if (!this.getLocker().equals(locker)) {
        throw new RuntimeException("解锁失败：解铃还需系铃人！");
    }
    this.setLocked(false);
    getBaseDao().update(this);
}
/**
 * 检测对象是否被某人锁定
 * @param locker
 * @return
 */
public boolean isLockedBy(String locker) {
    if (locker.equals(this.getLocker())  &amp;&amp;  this.isLocked()) {
        return true;
    }
    return false;
}
</code></pre>

<p>```</p>

<p>&emsp;&emsp;在业务类中，我们也需要加上几个类似的方法实现，事务也控制在这个上面：</p>

<p>``` java</p>

<pre><code>public void lockEpet(int epetid, String locker) {
    Epet e = (Epet)ht.get(Epet.class, epetid, LockMode.UPGRADE);
    e.lockEpet(locker);
}

public void unLockEpet(int epetid, String locker) {
    Epet e = (Epet)ht.get(Epet.class, epetid, LockMode.UPGRADE);
    e.unLockEpet(locker);    
}
</code></pre>

<p>```</p>

<p>&emsp;&emsp;在悲观离线锁的使用过程中要特别小心，做某些业务操作时，一定要确保已经成功获得了锁，写相关功能的程序员必须要清楚地知道这一点，因为，这种锁是程序员自己去实现的。</p>

<p>&emsp;&emsp;这种悲观锁的实现中，还需要防止死锁，比如：对多个对象的锁定，还有就是，需要某种检测机制，把超过某个业务时间的锁释放。</p>

<p>&emsp;&emsp;要想解决好事务的并发处理非常的不容易，因为这个问题本来就是和业务领域密切相关的一个问题，需要我们从业务方面去分析解决。转换为一对多，关系越简单越好。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[cas与shiro集成]]></title>
    <link href="http://yanyaner.com/blog/2013/05/13/shiro-cas/"/>
    <updated>2013-05-13T15:18:00+08:00</updated>
    <id>http://yanyaner.com/blog/2013/05/13/shiro-cas</id>
    <content type="html"><![CDATA[<p>&emsp;&emsp;cas与shiro的集成思路是：子系统的登录入口定位到cas，将用户名与密码的验证交由cas服务器去做，在服务器端登录成功后，重定向到子系统，再由子系统验证凭证号，如果通过，则初始化子系统的会话中的内容及权限等。大家要明白这样两点思想：</p>

<p>&emsp;&emsp;一、子系统不需要再做用户名及密码的验证。</p>

<p>&emsp;&emsp;二、子系统需要查询cas服务器，以确保该用户已经成功登录，凭证有效。</p>

<p>&emsp;&emsp;三、子系统去实现原有的会话管理及权限验证。</p>

<p>&emsp;&emsp;好了，下面看看配置上的代码：</p>

<p>&emsp;&emsp;重写cas验证过滤器，请注意，doGetAuthenticationInfo方法中的红色代码部分，是我在原有CasRealm的源码中新加的，而doGetAuthorizationInfo授权代码，将是你原来的授权代码：</p>

<p>``` java CasAuthRealm.java
/<em>*
 * cas认证类信息
 * @author ljh
 *
 </em>/
public class CasAuthRealm extends CasRealm  {</p>

<pre><code>private static Logger log = LoggerFactory.getLogger(CasAuthRealm.class);

@Resource(name = "studentService")
private IStudentService studentService;

// 认证
@Override
protected AuthenticationInfo doGetAuthenticationInfo(
        AuthenticationToken token) throws AuthenticationException {

    System.out.println("进入登录认证方法doGetAuthenticationInfo");

    CasToken casToken = (CasToken) token;
    if (token == null) {
        return null;
    }

    String ticket = (String)casToken.getCredentials();
    if (!StringUtils.hasText(ticket)) {
        return null;
    }

    TicketValidator ticketValidator = ensureTicketValidator();

    try {
        // contact CAS server to validate service ticket
        Assertion casAssertion = ticketValidator.validate(ticket, getCasService());
        // get principal, user id and attributes
        AttributePrincipal casPrincipal = casAssertion.getPrincipal();
        String userId = casPrincipal.getName();
        log.debug("Validate ticket : {} in CAS server : {} to retrieve user : {}", new Object[]{
                ticket, getCasServerUrlPrefix(), userId
        });

        Map&lt;String, Object&gt; attributes = casPrincipal.getAttributes();
        // refresh authentication token (user id + remember me)
        casToken.setUserId(userId);
        String rememberMeAttributeName = getRememberMeAttributeName();
        String rememberMeStringValue = (String)attributes.get(rememberMeAttributeName);
        boolean isRemembered = rememberMeStringValue != null &amp;&amp; Boolean.parseBoolean(rememberMeStringValue);
        if (isRemembered) {
            casToken.setRememberMe(true);
        }
        // create simple authentication info
        List&lt;Object&gt; principals = CollectionUtils.asList(userId, attributes);
        PrincipalCollection principalCollection = new SimplePrincipalCollection(principals, getName());


        //*************************自定义处理
        User user = studentService.getStudentById(Long.parseLong(userId));
        if (user != null) {
            //要放在作用域中的东西，请在这里进行操作
            SecurityUtils.getSubject().getSession().setAttribute("c_user", user);

            return new SimpleAuthenticationInfo(principalCollection, ticket);
        }

        //认证没有通过
        return null;


    } catch (TicketValidationException e) { 
        throw new CasAuthenticationException("Unable to validate ticket [" + ticket + "]", e);
    }

}

// 授权
@Override
protected AuthorizationInfo doGetAuthorizationInfo(
        PrincipalCollection principalCollection) {

    Long loginId = Long.parseLong((String)principalCollection.fromRealm(getName()).iterator().next());
    System.out.println("doGetAuthorizationInfo: 进行授权，登录id是：" + loginId);
    //取当前用户
    User student = studentService.getStudentById(loginId);
    System.out.println("角色标识是：" + student.getRolesAsString());
    System.out.println("权限标识是：" + student.getOperationPermissionsAsString());
    //System.out.println("用户可操作的菜单：" + student.getMenus());

    //添加角色及权限信息
    SimpleAuthorizationInfo sazi = new SimpleAuthorizationInfo();
    sazi.addRoles(student.getRolesAsString());
    sazi.addStringPermissions(student.getPermissionsAsString());

    return sazi;
}
</code></pre>

<p>}
```</p>

<p>&emsp;&emsp;在spring配置文件中，配置上面的cas过滤器，其中需要大家注意的地方，是“自定义处理“部分，源代码中我有标注，https : / /localhost:8444/cas 是cas服务器地址，http : / / localhost:8080/shiro_demo 是子系统的项目路径：</p>

<p>``` xml
<bean id="myCasRealm" class="com.my.service.impl.CasAuthRealm"></p>

<pre><code>    &lt;property name="casServerUrlPrefix" value="https://localhost:8444/cas"/&gt;
    &lt;property name="casService" value="http://localhost:8080/shiro_demo/login"/&gt;
</code></pre>

<p></bean></p>

<!-- 权限管理器 -->


<pre><code>&lt;bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager"&gt;
    &lt;property name="realms"&gt;
        &lt;list&gt;
            &lt;ref bean="myCasRealm" /&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>

<p> <bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean" depends-on="roleOrFilter"></p>

<pre><code>    &lt;property name="securityManager" ref="securityManager" /&gt;

    &lt;property name="loginUrl" value="https://localhost:8444/cas/login?service=http://localhost:8080/shiro_demo/login" /&gt;
    &lt;property name="successUrl" value="/main" /&gt;
    &lt;property name="unauthorizedUrl" value="/commons/unauth.jsp" /&gt;

&lt;property name="filters"&gt;
        &lt;map&gt;
            &lt;entry key="cas" value-ref="myCasFilter"/&gt; 
            &lt;entry key="roleOrFilter" value-ref="roleOrFilter"&gt;
            &lt;/entry&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>

<p>```</p>

<p>&emsp;&emsp;最后，在配置文件中，配置子系统登录入口至cas</p>

<p>```</p>

<p>/js/<strong> = anon
/css/</strong> = anon
/logout = anon</p>

<p>/error.jsp = anon</p>

<p>/login.jsp = cas  <br/>
/login = cas</p>

<p>```</p>

<p>&emsp;&emsp;当然，在进入主页面的时候，要访问session中的对象，如果hibernate的连接已经关闭，你可以重新将session中的对象与新的连接进行绑定，类似代码如下：</p>

<p>``` java</p>

<p>User u = (User)currentUser.getSession().getAttribute(&ldquo;c_user&rdquo;);</p>

<p>getHibernateTemplate().refresh(u);</p>

<p>```</p>

<p>&emsp;&emsp;再说一下子系统的退出，如果子系统退出，也要退出cas服务器，可以写如下代码：</p>

<p>``` java
@RequestMapping(value=&ldquo;/logout&rdquo;)</p>

<pre><code>public void logout(HttpServletResponse resp) throws IOException {
    Subject currentUser = SecurityUtils.getSubject();
    currentUser.logout(); 
    resp.sendRedirect("https://localhost:8444/cas/logout");
}
</code></pre>

<p>```</p>

<p>&emsp;&emsp;文章内容虽少，但调试成功确需要花费大量的时候，网上很多人写资料的都不能运行，有需要源代码的同鞋，请发消息与我。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[cas单点登录实现]]></title>
    <link href="http://yanyaner.com/blog/2013/05/06/cas1/"/>
    <updated>2013-05-06T15:18:00+08:00</updated>
    <id>http://yanyaner.com/blog/2013/05/06/cas1</id>
    <content type="html"><![CDATA[<p>&emsp;&emsp;企业经过多年的发展，在运行的系统可能有多套并存，而这个时候，一个员工往往会有多个系统的账号，用不同的账号、密码登录不同的系统，获得不同系统的权限并进行操作，这样的场景将加大员工记忆每个系统账号、密码的难度和操作上的繁琐，因此，不少企业提出只需要一次登录，就可访问各种系统的思路，这就是间点登录，即在一个地方登录即可。</p>

<p>&emsp;&emsp;要实现单点登录，各个子系统一定要进行某些改造，否则，实现难度将很大。我考虑了一上，一般会有这样的两种改造方案。</p>

<h2>方案一</h2>

<p>&emsp;&emsp;建立统一的账户密码数据库，做为单点登录认证的数据来源，而其它子系统，也将每个用户在自身系统中的登录账号与单点登录数据库中的账号相统一。在这种方案中，用户首先要登录单点认证服务器，在成功登录后，会得到一个ticket，而在访问子系统时入口时，必须同时携带该ticket，子系统得到ticket后立即向单点登录服务器发出查询请求，服务器会返回持有该ticket是否有效，如果有效，就可得到登录者的账号，子系统根据该账号，即可进行类似原来的登录后业务逻辑处理（注：密码的验证子系统不再需要做），比如：初始化session中的东西，进行用户授权权等。</p>

<p>&emsp;&emsp;当然，这种方式对于子系统的改造并不大，当然，如果子系统采用的是 登录编码 业务主键 做数据库主键，改造难度会大很多。</p>

<h2>方案二</h2>

<p>&emsp;&emsp;各个子系统提供登录调用接口，比如webservice接口，当用户在单点服务器登录时，同时调用子系统登录接口完成登录。</p>

<p>&emsp;&emsp;在下，我主要给大家介绍第一种方案。我们使用开源的cas服务器做为单点登录服务器。</p>

<p>&emsp;&emsp;一、下载服务器端软件，是一个war包，部署到tomcat中。</p>

<p>&emsp;&emsp;二、运行cas服务器，运行前，请先配置https协议所需要的证书，我把windows下的证书配置代码写到了一个windows批处理文件中。</p>

<p>&emsp;&emsp;以下内容写到一个bat文件中，运行即可，如果是linux服务器，自己需要做些小改动即可，比如rem改为echo。我的例子中，JAVA_HOME位置是：C:/Program Files/Java/jdk1.6.0_31/</p>

<p>``` bat
rem 清除系统中可能存在的名字为tomcatsso 的同名证书
cls
rem please set the env JAVA_HOME before run this bat file
rem delete alia tomcat if it is existed
keytool -delete -alias tomcatsso -keystore &ldquo;%JAVA_HOME%/jre/lib/security/cacerts&rdquo; -storepass changeit
keytool -delete -alias tomcatsso -storepass changeit</p>

<p>rem  列出系统证书仓库中存在证书名称列表
rem list all alias in the cacerts
keytool -list -keystore &ldquo;%JAVA_HOME%/jre/lib/security/cacerts&rdquo; -storepass changeit</p>

<p>rem 指定使用RSA算法，生成别名为tomcatsso的证书，存贮口令为changeit
rem generator a key
keytool -genkey -keyalg RSA -alias tomcatsso -dname &ldquo;cn=localhost&rdquo; -storepass changeit</p>

<p>rem 从keystore中导出别名为tomcatsso的证书，生成文件tomcatsso.crt
keytool -export -alias tomcatsso -file &ldquo;%JAVA_HOME%/jre/lib/security/tomcatsso.crt&rdquo; -storepass changeit</p>

<p>rem 将tomcatsso.crt导入jre的可信任证书仓库
rem import into trust cacerts
keytool -import -alias tomcatsso -file &ldquo;%JAVA_HOME%/jre/lib/security/tomcatsso.crt&rdquo; -keystore &ldquo;%JAVA_HOME%/jre/lib/security/cacerts&rdquo; -storepass changeit
rem 列出jre可信任证书仓库中证书名单
rem list all alias in the cacerts
keytool -list -keystore &ldquo;%JAVA_HOME%/jre/lib/security/cacerts&rdquo; -storepass changeit
```</p>

<p>&emsp;&emsp;运行上面的bat文件，即可建立好信任证书。</p>

<p>&emsp;&emsp;三、修改cas服务器的tomcat配置， server.xml</p>

<p>&emsp;&emsp;ssl部分修改如下：</p>

<p>``` xml server.xml</p>

<p> &lt;Connector port=&ldquo;8443&rdquo; protocol=&ldquo;HTTP/1.1&rdquo; SSLEnabled=&ldquo;true&rdquo;</p>

<pre><code>           maxThreads="150" scheme="https" secure="true"
           clientAuth="false" sslProtocol="TLS" 
           keystoreFile="C:/Documents and Settings/Administrator/.keystore" 
           keystorePass="changeit"
           truststoreFile="C:/Program Files/Java/jdk1.6.0_31/jre/lib/security/cacerts" 
           truststorePass="changeit"
           /&gt;
</code></pre>

<p>```</p>

<p>&emsp;&emsp;四、客户端配置</p>

<p>&emsp;&emsp;在子系统中，需要加入cas客户端，其实主要是添加过过滤器，将对子系统入口拦截到cas服务器，并会对302回转的ticket进行验证。</p>

<p>&emsp;&emsp;添加cas-client-core-3.2.1.jar支持包，在cas服务器的lib下有。</p>

<p>&emsp;&emsp;如果你的客户端是运行在另外一个tomcat的，还需要加入信任证书，可以在自己的项目中写一个ServletContextListener，在 contextInitialized中添加如下代码，路径你根据你的环境配置。
<code>java
 System.setProperty("javax.net.ssl.trustStore", "C:/Program Files/Java/jdk1.6.0_31/jre/lib/security/cacerts");
 System.setProperty("javax.net.ssl.trustStorePassword", "changeit");
</code></p>

<p>&emsp;&emsp;五、密码加密方案</p>

<p>&emsp;&emsp;配置服务器，从数据库中取用户名和密码信息，并实现自定义的密码加密处理。我们重写密码处理类，导出jar包，并copy至cas服务器的lib目录下：</p>

<p>``` java MyCasPasswordEncoder.java</p>

<p>import org.apache.commons.codec.digest.DigestUtils;
import org.jasig.cas.authentication.handler.PasswordEncoder;</p>

<p>public class MyCasPasswordEncoder implements PasswordEncoder {</p>

<pre><code>@Override
public String encode(String pwd) {

    return DigestUtils.md5Hex(pwd);
}
</code></pre>

<p>}</p>

<p>```</p>

<p>&emsp;&emsp;修改cas服务器上的deployerConfigContext.xml文件，添加数据源等、密码加密类等信息，配置代码如下：</p>

<p>``` xml deployerConfigContext.xml
&lt;bean id=&ldquo;dataSource&rdquo;</p>

<pre><code>    class="org.apache.commons.dbcp.BasicDataSource"
&gt;
    &lt;property name="driverClassName"&gt;
        &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="url"&gt;
        &lt;value&gt;jdbc:mysql://localhost:3306/cas?setUnicode=true&amp;amp;characterEncoding=utf8&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="username"&gt;
        &lt;value&gt;root&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="password"&gt;
        &lt;value&gt;&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="defaultAutoCommit"&gt;
        &lt;value&gt;false&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>

<p>```</p>

<p>&emsp;&emsp;authenticationManager配置部分，<property name="authenticationHandlers">中的list中，添加</p>

<p>``` xml deployerConfigContext.xml
<bean class="org.jasig.cas.adaptors.jdbc.QueryDatabaseAuthenticationHandler"></p>

<pre><code>                  &lt;property name="dataSource" ref="dataSource" /&gt;
                  &lt;property name="sql" value="select f_password from t_user where lower(f_code) = lower(?)" /&gt;
                  &lt;property name="passwordEncoder"&gt;
                    &lt;bean class="com.my.commons.MyCasPasswordEncoder"/&gt;
                  &lt;/property&gt;
</code></pre>

<p> </bean>
```</p>

<p>&emsp;&emsp;当然，如果你的f_code不是字符类型，请删除sql中的lower。</p>

<p>&emsp;&emsp;注意要将原配置中的SimpleTestUsernamePasswordAuthenticationHandler验证处理类屏蔽。</p>

<p>&emsp;&emsp;上面的代码要成功运行，还需要建立cas数据库，新建表t_user,包含pk_id,f_code,f_password字段，其中后两个字段用于登录。另外，还需要加入cas-server-jdbc-3.0.5-rc3.jar以及mysql驱动包、dbcp驱动包等。</p>

<p>&emsp;&emsp;下篇给大家介绍cas与shiro的整合。</p>

<p>&emsp;&emsp;附：子系统中web.xml中的配置</p>

<p>``` xml web.xml</p>

<p>  <filter></p>

<pre><code>&lt;filter-name&gt;CasSingleSignOutFilter&lt;/filter-name&gt;
&lt;filter-class&gt;org.jasig.cas.client.session.SingleSignOutFilter&lt;/filter-class&gt;
</code></pre>

<p>  </filter>
  <filter></p>

<pre><code>&lt;filter-name&gt;CasAuthenticationFilter&lt;/filter-name&gt;
&lt;filter-class&gt;org.jasig.cas.client.authentication.AuthenticationFilter&lt;/filter-class&gt;
&lt;init-param&gt;
  &lt;param-name&gt;casServerLoginUrl&lt;/param-name&gt;
  &lt;param-value&gt;https://localhost:8443/cas/login&lt;/param-value&gt;
&lt;/init-param&gt;
&lt;init-param&gt;
  &lt;param-name&gt;serverName&lt;/param-name&gt;
  &lt;param-value&gt;http://localhost:8081&lt;/param-value&gt;
&lt;/init-param&gt;
</code></pre>

<p>  </filter>
  <filter></p>

<pre><code>&lt;filter-name&gt;CasValidationFilter&lt;/filter-name&gt;
&lt;filter-class&gt;org.jasig.cas.client.validation.Cas20ProxyReceivingTicketValidationFilter&lt;/filter-class&gt;
&lt;init-param&gt;
  &lt;param-name&gt;casServerUrlPrefix&lt;/param-name&gt;
  &lt;param-value&gt;https://localhost:8443/cas&lt;/param-value&gt;
&lt;/init-param&gt;
&lt;init-param&gt;
  &lt;param-name&gt;serverName&lt;/param-name&gt;
  &lt;param-value&gt;http://localhost:8081&lt;/param-value&gt;
&lt;/init-param&gt;
&lt;init-param&gt;
  &lt;param-name&gt;redirectAfterValidation&lt;/param-name&gt;
  &lt;param-value&gt;true&lt;/param-value&gt;
&lt;/init-param&gt;
</code></pre>

<p>  </filter>
  &lt;filter-mapping></p>

<pre><code>&lt;filter-name&gt;CasSingleSignOutFilter&lt;/filter-name&gt;
&lt;url-pattern&gt;/*&lt;/url-pattern&gt;
</code></pre>

<p>  &lt;/filter-mapping>
  &lt;filter-mapping></p>

<pre><code>&lt;filter-name&gt;CasValidationFilter&lt;/filter-name&gt;
&lt;url-pattern&gt;/*&lt;/url-pattern&gt;
</code></pre>

<p>  &lt;/filter-mapping>
  &lt;filter-mapping></p>

<pre><code>&lt;filter-name&gt;CasAuthenticationFilter&lt;/filter-name&gt;
&lt;url-pattern&gt;/*&lt;/url-pattern&gt;
</code></pre>

<p>  &lt;/filter-mapping>
  <listener></p>

<pre><code>&lt;listener-class&gt;org.jasig.cas.client.session.SingleSignOutHttpSessionListener&lt;/listener-class&gt;
</code></pre>

<p>  </listener>
```</p>
]]></content>
  </entry>
  
</feed>
